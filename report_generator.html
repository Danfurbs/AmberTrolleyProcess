<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amber Trolley - Track Inspection Report Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>if (window.pdfjsLib) pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f2f5; color: #333; }

        .upload-screen {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; padding: 40px;
        }
        .upload-screen h1 { font-size: 28px; margin-bottom: 8px; color: #1a1a2e; }
        .upload-screen p { color: #666; margin-bottom: 30px; }
        .drop-zone {
            width: 500px; max-width: 90vw; height: 200px;
            border: 3px dashed #aab; border-radius: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s; background: #fff;
        }
        .drop-zone:hover, .drop-zone.dragover { border-color: #4a6cf7; background: #f0f4ff; }
        .drop-zone span { font-size: 16px; color: #666; }
        .drop-zone .icon { font-size: 48px; margin-bottom: 12px; }
        .drop-zone input { display: none; }

        .report-container { display: none; max-width: 1400px; margin: 0 auto; padding: 20px; }
        .report-container.active { display: block; }

        .toolbar {
            display: flex; gap: 10px; align-items: center; margin-bottom: 20px;
            padding: 16px 20px; background: #1a1a2e; border-radius: 10px; flex-wrap: wrap;
        }
        .toolbar h2 { color: #fff; font-size: 18px; flex: 1; }
        .toolbar button {
            padding: 8px 18px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 14px; font-weight: 600; transition: all 0.2s;
        }
        .btn-excel { background: #1d6f42; color: #fff; }
        .btn-excel:hover { background: #175c36; }
        .btn-pdf { background: #c0392b; color: #fff; }
        .btn-pdf:hover { background: #a93226; }
        .btn-back { background: #555; color: #fff; }
        .btn-back:hover { background: #444; }

        .tabs {
            display: flex; gap: 4px; margin-bottom: 20px; background: #ddd; padding: 4px;
            border-radius: 8px;
        }
        .tab {
            flex: 1; padding: 12px 16px; text-align: center; border: none; background: none;
            cursor: pointer; border-radius: 6px; font-size: 14px; font-weight: 600;
            color: #666; transition: all 0.2s;
        }
        .tab.active { background: #fff; color: #1a1a2e; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

        .page { display: none; }
        .page.active { display: block; }

        .card {
            background: #fff; border-radius: 10px; padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); margin-bottom: 20px;
        }
        .card h3 { font-size: 16px; color: #1a1a2e; margin-bottom: 16px; border-bottom: 2px solid #eee; padding-bottom: 8px; }

        .meta-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 8px 24px;
        }
        .meta-item { display: flex; justify-content: space-between; padding: 4px 0; font-size: 13px; }
        .meta-item .label { color: #888; }
        .meta-item .value { font-weight: 600; color: #333; }

        .chart-row { display: grid; grid-template-columns: 1fr; gap: 20px; }
        .chart-stack { display: grid; gap: 16px; }
        .chart-wrapper { position: relative; height: 300px; }
        .chart-segment-title { font-size: 12px; color: #666; margin: 4px 0 6px; }
        canvas { width: 100% !important; }

        table {
            width: 100%; border-collapse: collapse; font-size: 12px;
        }
        thead th {
            background: #1a1a2e; color: #fff; padding: 8px 10px; text-align: left;
            font-weight: 600; position: sticky; top: 0; white-space: nowrap;
        }
        tbody td { padding: 6px 10px; border-bottom: 1px solid #eee; }
        tbody tr:hover { background: #f8f9ff; }

        .summary-stats {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px; margin-bottom: 20px;
        }
        .stat-card {
            background: #fff; border-radius: 10px; padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); text-align: center;
        }
        .stat-card .number { font-size: 32px; font-weight: 700; color: #1a1a2e; }
        .stat-card .label { font-size: 13px; color: #888; margin-top: 4px; }
        .stat-card.warning .number { color: #e67e22; }
        .stat-card.danger .number { color: #c0392b; }

        .cat-ial { background: #f8d7da; border-left: 4px solid #c0392b; }
        .cat-ial-block { background: #f5c6cb; border-left: 4px solid #721c24; }
        .cat-il { background: #fff3cd; border-left: 4px solid #e67e22; }
        .cat-al { background: #d4edda; border-left: 4px solid #28a745; }

        .badge {
            display: inline-block; padding: 2px 8px; border-radius: 4px;
            font-size: 11px; font-weight: 700; color: #fff; white-space: nowrap;
        }
        .badge-ial { background: #c0392b; }
        .badge-il { background: #e67e22; }
        .badge-al { background: #28a745; }

        .run-info-bar {
            display: flex; gap: 20px; align-items: center; margin-bottom: 20px;
            padding: 16px 20px; background: #fff; border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); flex-wrap: wrap;
        }
        .run-info-bar label { font-size: 13px; color: #888; font-weight: 600; }
        .run-info-bar input, .run-info-bar select {
            padding: 6px 12px; border: 1px solid #ccc; border-radius: 6px;
            font-size: 14px; font-family: inherit; min-width: 120px;
        }
        .run-info-bar input:focus, .run-info-bar select:focus { outline: none; border-color: #4a6cf7; box-shadow: 0 0 0 2px rgba(74,108,247,0.15); }
        .run-info-group { display: flex; flex-direction: column; gap: 4px; }

        .speed-warning {
            display: none; padding: 10px 16px; background: #fff3cd; border: 1px solid #ffc107;
            border-radius: 8px; margin-bottom: 16px; font-size: 13px; color: #856404;
        }
        .speed-warning.visible { display: block; }
        .caution-warning {
            padding: 12px 16px; background: #fff5f5; border: 1px solid #f5c2c7;
            border-radius: 8px; margin-bottom: 16px; font-size: 13px; color: #842029;
        }

        .override-card {
            background: #fff; border-radius: 10px; padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); margin-bottom: 20px;
        }
        .override-card summary { cursor: pointer; font-weight: 600; color: #1a1a2e; }
        .override-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px 20px; margin-top: 16px;
        }
        .override-field { display: flex; flex-direction: column; gap: 4px; }
        .override-field label { font-size: 12px; color: #666; font-weight: 600; }
        .override-field input { padding: 6px 10px; border: 1px solid #ccc; border-radius: 6px; }

        .radius-select {
            padding: 3px 6px; border: 1px solid #ccc; border-radius: 4px;
            font-size: 11px; background: #fff; cursor: pointer;
        }

        .sign-off-section {
            margin-top: 20px; padding: 20px; background: #fafafa; border: 2px solid #ddd;
            border-radius: 10px;
        }
        .sign-off-section h4 { font-size: 14px; color: #1a1a2e; margin-bottom: 16px; border-bottom: 2px solid #ccc; padding-bottom: 8px; }
        .sign-off-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 16px 32px;
        }
        .sign-off-field { display: flex; flex-direction: column; gap: 4px; }
        .sign-off-field label { font-size: 12px; color: #888; font-weight: 600; text-transform: uppercase; }
        .sign-off-field input {
            padding: 8px 12px; border: none; border-bottom: 2px solid #999;
            background: transparent; font-size: 14px; font-family: inherit;
        }
        .sign-off-field input:focus { outline: none; border-bottom-color: #4a6cf7; }

        .note-box {
            margin-top: 12px; padding: 10px 14px; background: #f8f9fa; border-left: 3px solid #6c757d;
            font-size: 12px; color: #555; line-height: 1.5;
        }

        .run-selector-bar {
            display: flex; gap: 10px; align-items: center; margin-bottom: 20px;
            padding: 14px 20px; background: #fff; border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); flex-wrap: wrap;
        }
        .run-selector-bar label { font-size: 13px; color: #888; font-weight: 600; }
        .run-selector-bar select {
            padding: 6px 12px; border: 1px solid #ccc; border-radius: 6px;
            font-size: 14px; font-family: inherit; min-width: 200px;
        }
        .run-selector-bar select:focus { outline: none; border-color: #4a6cf7; box-shadow: 0 0 0 2px rgba(74,108,247,0.15); }
        .run-selector-bar .run-count { font-size: 12px; color: #666; padding: 4px 10px; background: #eef; border-radius: 12px; }

        .btn-add-fault {
            padding: 8px 16px; border: 2px dashed #4a6cf7; border-radius: 6px;
            background: #f0f4ff; color: #4a6cf7; cursor: pointer; font-size: 13px;
            font-weight: 600; transition: all 0.2s; margin-bottom: 12px;
        }
        .btn-add-fault:hover { background: #4a6cf7; color: #fff; }

        .manual-fault-tag {
            display: inline-block; padding: 1px 6px; border-radius: 3px;
            font-size: 9px; font-weight: 700; color: #fff; background: #6c757d;
            margin-left: 4px; vertical-align: middle;
        }

        .btn-remove-fault {
            padding: 2px 6px; border: none; background: #dc3545; color: #fff;
            border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: 700;
        }
        .btn-remove-fault:hover { background: #c82333; }

        .btn-dismiss-fault {
            padding: 2px 8px; border: 1px solid #6c757d; background: #fff; color: #6c757d;
            border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: 600;
        }
        .btn-dismiss-fault:hover { background: #6c757d; color: #fff; }

        .btn-restore-fault {
            padding: 2px 8px; border: 1px solid #28a745; background: #fff; color: #28a745;
            border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: 600;
        }
        .btn-restore-fault:hover { background: #28a745; color: #fff; }

        tr.dismissed-fault td { text-decoration: line-through; color: #999; }
        tr.dismissed-fault { opacity: 0.65; }
        .dismissed-info {
            display: block; font-size: 10px; color: #888; font-style: italic;
            text-decoration: none; margin-top: 2px;
        }

        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;
        }
        .modal-overlay.active { display: flex; }
        .modal {
            background: #fff; border-radius: 12px; padding: 28px; width: 500px; max-width: 90vw;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }
        .modal h3 { font-size: 18px; color: #1a1a2e; margin-bottom: 20px; }
        .modal-field { margin-bottom: 14px; }
        .modal-field label { display: block; font-size: 12px; color: #888; font-weight: 600; text-transform: uppercase; margin-bottom: 4px; }
        .modal-field input, .modal-field select {
            width: 100%; padding: 8px 12px; border: 1px solid #ccc; border-radius: 6px;
            font-size: 14px; font-family: inherit;
        }
        .modal-field input:focus, .modal-field select:focus { outline: none; border-color: #4a6cf7; }
        .modal-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .modal-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; }
        .modal-actions button {
            padding: 8px 20px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 14px; font-weight: 600;
        }
        .btn-modal-cancel { background: #eee; color: #666; }
        .btn-modal-cancel:hover { background: #ddd; }
        .btn-modal-save { background: #4a6cf7; color: #fff; }
        .btn-modal-save:hover { background: #3a5ce5; }

        .comparison-table { width: 100%; border-collapse: collapse; font-size: 12px; margin-top: 12px; }
        .comparison-table th { background: #1a1a2e; color: #fff; padding: 6px 10px; text-align: left; font-size: 11px; }
        .comparison-table td { padding: 5px 10px; border-bottom: 1px solid #eee; font-size: 11px; }
        .comp-new { background: #f8d7da; }
        .comp-resolved { background: #d4edda; }
        .comp-persists { background: #fff3cd; }
        .comp-legend { display: flex; gap: 16px; margin-bottom: 12px; font-size: 12px; }
        .comp-legend span { padding: 2px 10px; border-radius: 4px; }
        .btn-clear-comparison {
            padding: 4px 12px; border: 1px solid #999; background: #fff; color: #666;
            border-radius: 4px; cursor: pointer; font-size: 11px; margin-left: 8px;
        }
        .btn-clear-comparison:hover { background: #eee; }
        .prev-run-info { padding: 8px 12px; background: #eef; border-radius: 6px; font-size: 12px; color: #336; margin-bottom: 12px; }

        @media print {
            .toolbar, .tabs, .run-selector-bar { display: none; }
            .page { display: block !important; page-break-after: always; }
            .card { box-shadow: none; border: 1px solid #ddd; }
        }
    </style>
</head>
<body>

<div class="upload-screen" id="uploadScreen">
    <h1>Amber Trolley Report Generator</h1>
    <p>Upload a raw data HTML file from the Amber trolley to generate an inspection report</p>
    <div class="drop-zone" id="dropZone">
        <div class="icon">&#128196;</div>
        <span>Drop file(s) here or click to browse â€” select multiple for bulk upload</span>
        <input type="file" id="fileInput" accept=".html,.htm,.txt,.csv" multiple>
    </div>
    <div style="margin-top: 30px; max-width: 560px;">
        <p style="font-size: 13px; color: #999; text-align: center;">
            Classifies twist and gauge faults against Table 3 &amp; Table 5 limits
            (IAL / IL / AL) with speed-dependent thresholds and remedial actions.
            Upload multiple files at once to process several runs. Export as Excel or PDF.
        </p>
    </div>
</div>

<div class="report-container" id="reportContainer">
    <div class="toolbar">
        <h2 id="reportTitle">Track Inspection Report</h2>
        <button class="btn-back" onclick="goBack()">Load New File</button>
        <button class="btn-excel" onclick="exportExcel()">Export Excel</button>
        <button class="btn-pdf" onclick="exportPDF()">Export PDF</button>
    </div>

    <div class="run-selector-bar" id="runSelectorBar" style="display:none;">
        <label>Active Run</label>
        <select id="runSelector" onchange="switchRun(this.value)"></select>
        <span class="run-count" id="runCount"></span>
    </div>

    <div class="run-info-bar">
        <div class="run-info-group">
            <label>Run Name</label>
            <input type="text" id="runNameInput" placeholder="Enter run name...">
        </div>
        <div class="run-info-group">
            <label>Inspector</label>
            <input type="text" id="inspectorInput" placeholder="Enter inspector name...">
        </div>
        <div class="run-info-group">
            <label>Line Speed (mph)</label>
            <input type="number" id="lineSpeedInput" placeholder="e.g. 75" min="5" max="125" style="width:100px;">
        </div>
        <div class="run-info-group">
            <label>Track Category</label>
            <select id="trackCatInput" style="width:120px;">
                <option value="">-- Select --</option>
                <option value="1A">Cat 1A</option>
                <option value="1">Cat 1</option>
                <option value="2">Cat 2</option>
                <option value="3">Cat 3</option>
                <option value="4">Cat 4</option>
                <option value="5">Cat 5</option>
                <option value="6">Cat 6</option>
            </select>
        </div>
    </div>

    <div class="speed-warning" id="speedWarning">
        Please enter a Line Speed (5-125 mph) above to classify faults against the correct thresholds.
    </div>
    <div class="caution-warning">
        Caution: This tool should reflect the correct tolerances, but always verify against the latest standard.
    </div>

    <details class="override-card" id="overrideCard">
        <summary>Inspector Override Values</summary>
        <div class="override-grid">
            <div class="override-field">
                <label>
                    <input type="checkbox" id="overrideToggle">
                    Enable manual overrides for thresholds
                </label>
            </div>
            <div class="override-field">
                <label for="overrideGaugeTight">Gauge tight threshold (mm)</label>
                <input type="number" id="overrideGaugeTight" step="0.1" placeholder="e.g. 1426">
            </div>
            <div class="override-field">
                <label for="overrideGaugeWide">Gauge wide threshold (mm)</label>
                <input type="number" id="overrideGaugeWide" step="0.1" placeholder="e.g. 1445">
            </div>
            <div class="override-field">
                <label for="overrideTwist">Twist detection threshold (mm)</label>
                <input type="number" id="overrideTwist" step="0.1" placeholder="e.g. 12">
            </div>
        </div>
        <p style="margin-top:12px;font-size:12px;color:#666;">
            Overrides affect fault detection thresholds only and should be used sparingly with engineering sign-off.
        </p>
    </details>

    <div class="tabs">
        <button class="tab active" data-page="overview">Overview &amp; Graphs</button>
        <button class="tab" data-page="gaugeFaults">Gauge Faults</button>
        <button class="tab" data-page="twistFaults">Twist Faults</button>
    </div>

    <!-- Page 1: Overview & Graphs -->
    <div class="page active" id="page-overview">
        <div class="card">
            <h3>Survey Information</h3>
            <div class="meta-grid" id="metaGrid"></div>
        </div>

        <div class="summary-stats" id="summaryStats"></div>

        <div class="card">
            <h3>Fault Location Schematic</h3>
            <p style="margin-bottom:8px;color:#666;font-size:12px;">Linear diagram showing fault positions along the track. Colour indicates severity.</p>
            <div id="schematicContainer" style="overflow-x:auto;">
                <canvas id="schematicCanvas" height="120"></canvas>
            </div>
        </div>

        <div class="card">
            <h3>Gauge Profile (mm)</h3>
            <div id="gaugeCharts" class="chart-stack"></div>
        </div>
        <div class="card">
            <h3>Twist over 3m (mm)</h3>
            <div id="twistCharts" class="chart-stack"></div>
        </div>

        <!-- Previous Run Comparison -->
        <div class="card" id="comparisonCard">
            <h3>Run-on-Run Comparison</h3>
            <div id="comparisonEmpty">
                <p style="color:#666;font-size:13px;margin-bottom:12px;">
                    Load a previous report PDF to compare faults between runs.
                </p>
                <label class="btn-add-fault" style="cursor:pointer;">
                    Load Previous Run PDF
                    <input type="file" id="prevRunInput" accept=".pdf" style="display:none;" onchange="loadPreviousRunPDF(this)">
                </label>
            </div>
            <div id="comparisonResults" style="display:none;"></div>
        </div>
    </div>

    <!-- Page 2: Gauge Faults -->
    <div class="page" id="page-gaugeFaults">
        <div class="card">
            <h3>Gauge Faults (Table 5 Limits)</h3>
            <p style="margin-bottom: 12px; color: #666; font-size: 13px;">
                Wide gauge and tight gauge faults classified per Table 5 thresholds for the configured line speed.
            </p>
            <button class="btn-add-fault" onclick="openManualGaugeFaultModal()">+ Add Manual Gauge Fault</button>
            <div style="overflow-x: auto;">
                <table id="gaugeFaultTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Fault No.</th>
                            <th>Start Location</th>
                            <th>End Location</th>
                            <th>Length (yds)</th>
                            <th>Worst Gauge (mm)</th>
                            <th>Deviation (mm)</th>
                            <th>Fault Type</th>
                            <th>Category</th>
                            <th>Required Action</th>
                            <th>Repeat</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="note-box">
                <strong>Note 1:</strong> These actions assume no significant associated faults at the same location. If other faults exist, complete the action to a shorter timescale.<br>
                <strong>Note 2:</strong> These are based upon nominal gauge for that type of track. Any design gauge widening is to be added to the lower limit for the action threshold.
            </div>
            <div class="sign-off-section">
                <h4>Section Manager Sign-Off</h4>
                <div class="sign-off-grid">
                    <div class="sign-off-field">
                        <label>Name</label>
                        <input type="text" id="gaugeSignOffName" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Date</label>
                        <input type="date" id="gaugeSignOffDate">
                    </div>
                    <div class="sign-off-field">
                        <label>Signature</label>
                        <input type="text" id="gaugeSignOffSig" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Comments</label>
                        <input type="text" id="gaugeSignOffComments" placeholder="">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Page 3: Twist Faults -->
    <div class="page" id="page-twistFaults">
        <div class="card">
            <h3>Twist Faults - 3m Base (Table 3 Limits)</h3>
            <p style="margin-bottom: 12px; color: #666; font-size: 13px;">
                Twist faults classified per Table 3 thresholds. Set the curve radius toggle per fault to adjust IL timescales.
            </p>
            <button class="btn-add-fault" onclick="openManualTwistFaultModal()">+ Add Manual Twist Fault</button>
            <div style="overflow-x: auto;">
                <table id="twistFaultTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Fault No.</th>
                            <th>Start Location</th>
                            <th>End Location</th>
                            <th>Length (yds)</th>
                            <th>Max |Twist| (mm)</th>
                            <th>Worst Value (mm)</th>
                            <th>Curve Radius</th>
                            <th>Category</th>
                            <th>Required Action</th>
                            <th>Repeat</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="note-box">
                <strong>Note 1:</strong> Where twist faults at Intervention Limit or above are adjacent to structures with tight clearances, complete the action to a shorter timescale.<br>
                <strong>Note 2:</strong> These actions assume no significant associated faults at the same location. If other faults exist, complete the action to a shorter timescale.
            </div>
            <div class="sign-off-section">
                <h4>Section Manager Sign-Off</h4>
                <div class="sign-off-grid">
                    <div class="sign-off-field">
                        <label>Name</label>
                        <input type="text" id="twistSignOffName" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Date</label>
                        <input type="date" id="twistSignOffDate">
                    </div>
                    <div class="sign-off-field">
                        <label>Signature</label>
                        <input type="text" id="twistSignOffSig" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Comments</label>
                        <input type="text" id="twistSignOffComments" placeholder="">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Manual Gauge Fault Modal -->
<div class="modal-overlay" id="gaugeModal">
    <div class="modal">
        <h3>Add Manual Gauge Fault</h3>
        <div class="modal-row">
            <div class="modal-field">
                <label>Start Miles</label>
                <input type="number" id="mgStartMiles" step="1" min="0" placeholder="e.g. 21">
            </div>
            <div class="modal-field">
                <label>Start Yards</label>
                <input type="number" id="mgStartYards" step="0.1" min="0" placeholder="e.g. 1160.0">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>End Miles</label>
                <input type="number" id="mgEndMiles" step="1" min="0" placeholder="e.g. 21">
            </div>
            <div class="modal-field">
                <label>End Yards</label>
                <input type="number" id="mgEndYards" step="0.1" min="0" placeholder="e.g. 1165.0">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>Worst Gauge (mm)</label>
                <input type="number" id="mgWorstGauge" step="0.1" placeholder="e.g. 1450.5">
            </div>
            <div class="modal-field">
                <label>Fault Type</label>
                <select id="mgFaultDirection">
                    <option value="wide">Wide Gauge</option>
                    <option value="tight">Tight Gauge</option>
                </select>
            </div>
        </div>
        <div class="modal-field">
            <label>Fault No. (optional)</label>
            <input type="text" id="mgFaultNo" placeholder="e.g. GF-001">
        </div>
        <div class="modal-actions">
            <button class="btn-modal-cancel" onclick="closeModal('gaugeModal')">Cancel</button>
            <button class="btn-modal-save" onclick="saveManualGaugeFault()">Add Fault</button>
        </div>
    </div>
</div>

<!-- Manual Twist Fault Modal -->
<div class="modal-overlay" id="twistModal">
    <div class="modal">
        <h3>Add Manual Twist Fault</h3>
        <div class="modal-row">
            <div class="modal-field">
                <label>Start Miles</label>
                <input type="number" id="mtStartMiles" step="1" min="0" placeholder="e.g. 21">
            </div>
            <div class="modal-field">
                <label>Start Yards</label>
                <input type="number" id="mtStartYards" step="0.1" min="0" placeholder="e.g. 1160.0">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>End Miles</label>
                <input type="number" id="mtEndMiles" step="1" min="0" placeholder="e.g. 21">
            </div>
            <div class="modal-field">
                <label>End Yards</label>
                <input type="number" id="mtEndYards" step="0.1" min="0" placeholder="e.g. 1165.0">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>Max |Twist| (mm)</label>
                <input type="number" id="mtMaxTwist" step="0.1" min="0" placeholder="e.g. 18.5">
            </div>
            <div class="modal-field">
                <label>Worst Value (mm, signed)</label>
                <input type="number" id="mtWorstValue" step="0.1" placeholder="e.g. -18.5">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>Curve Radius</label>
                <select id="mtCurveRadius">
                    <option value="gte400">&ge; 400m</option>
                    <option value="lt400">&lt; 400m</option>
                </select>
            </div>
            <div class="modal-field">
                <label>Fault No. (optional)</label>
                <input type="text" id="mtFaultNo" placeholder="e.g. TF-001">
            </div>
        </div>
        <div class="modal-actions">
            <button class="btn-modal-cancel" onclick="closeModal('twistModal')">Cancel</button>
            <button class="btn-modal-save" onclick="saveManualTwistFault()">Add Fault</button>
        </div>
    </div>
</div>

<!-- Dismiss Fault Modal -->
<div class="modal-overlay" id="dismissModal">
    <div class="modal">
        <h3>Dismiss Fault</h3>
        <p style="margin-bottom: 16px; color: #666; font-size: 13px;">
            This fault will be kept on the record with a line through it. Please provide a reason for dismissal.
        </p>
        <div class="modal-field">
            <label>Inspector Name</label>
            <input type="text" id="dismissInspector" placeholder="Enter your name...">
        </div>
        <div class="modal-field">
            <label>Reason for Dismissal</label>
            <input type="text" id="dismissReason" placeholder="e.g. False reading, track geometry confirmed OK on site">
        </div>
        <input type="hidden" id="dismissFaultType">
        <input type="hidden" id="dismissFaultIdx">
        <div class="modal-actions">
            <button class="btn-modal-cancel" onclick="closeModal('dismissModal')">Cancel</button>
            <button class="btn-modal-save" onclick="confirmDismissFault()">Dismiss Fault</button>
        </div>
    </div>
</div>

<script>
// ---- State ----
let parsedData = null;
let gaugeFaults = [];
let twistFaults = [];
let metadata = {};
let gaugeChartInstances = [];
let twistChartInstances = [];

// Dismissed faults: keyed by "gauge-{idx}" or "twist-{idx}", stores {timestamp, comment, inspector}
let dismissedFaults = {};

// Manual faults (kept separate so we can tag them)
let manualGaugeFaults = [];
let manualTwistFaults = [];

// Bulk upload: store all loaded runs
let allRuns = []; // [{parsedData, metadata, filename}, ...]
let activeRunIndex = -1;

// Per-fault curve radius settings (indexed by fault index)
let twistFaultRadiusSettings = []; // true = <400m, false = >=400m

// ---- Table 3: Twist Fault Limits (3m base) ----
function classifyTwistFault(absValue, lineSpeed, curveRadiusLessThan400) {
    if (!lineSpeed || lineSpeed < 5) return null;

    // IAL - Block the line: all speeds, >= 33mm
    if (absValue >= 33) {
        return { category: 'IAL', badge: 'badge-ial', rowClass: 'cat-ial-block',
            action: 'BLOCK THE LINE - Correct before opening to traffic' };
    }

    // IAL - Correct within 36 hours
    if (lineSpeed <= 75 && absValue >= 24 && absValue < 33) {
        return { category: 'IAL', badge: 'badge-ial', rowClass: 'cat-ial',
            action: 'Correct within 36 hours' };
    }
    if (lineSpeed >= 80 && absValue >= 21 && absValue < 33) {
        return { category: 'IAL', badge: 'badge-ial', rowClass: 'cat-ial',
            action: 'Correct within 36 hours' };
    }

    // IL - Curve radius < 400m (max 65mph)
    if (curveRadiusLessThan400 && lineSpeed <= 65) {
        if (absValue >= 18 && absValue < 24) {
            return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Correct within 7 days' };
        }
        if (absValue >= 15 && absValue < 18) {
            return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Correct within 10 days' };
        }
    }

    // IL - Curve radius >= 400m (or < 400m but speed > 65 falls through to these)
    if (!curveRadiusLessThan400 || lineSpeed > 65) {
        if (lineSpeed <= 75) {
            if (absValue >= 21 && absValue < 24) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 14 days' };
            }
            if (absValue >= 18 && absValue < 21) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 21 days' };
            }
            if (absValue >= 15 && absValue < 18) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 28 days' };
            }
        }
        if (lineSpeed >= 80) {
            if (absValue >= 18 && absValue < 21) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 14 days' };
            }
            if (absValue >= 15 && absValue < 18) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 21 days' };
            }
        }
    }

    // AL - All speeds: 12mm to < 15mm
    if (absValue >= 12 && absValue < 15) {
        return { category: 'AL', badge: 'badge-al', rowClass: 'cat-al',
            action: 'Monitor (Alert Limit)' };
    }

    return null;
}

// ---- Table 5: Gauge Fault Limits ----
function classifyGaugeFault(gaugeValue, lineSpeed, trackCat) {
    if (!lineSpeed || lineSpeed < 5) return null;
    // Resolve track-category-dependent timescale for wide gauge IL
    const isHighCat = ['1A','1','2','3'].includes(trackCat);
    const isLowCat = ['4','5','6'].includes(trackCat);
    let wideILAction;
    if (isHighCat) wideILAction = 'Correct within 14 days (Cat ' + trackCat + ')';
    else if (isLowCat) wideILAction = 'Correct within 28 days (Cat ' + trackCat + ')';
    else wideILAction = 'Cat 1A-3: correct within 14 days; Cat 4-6: correct within 28 days';

    // --- WIDE GAUGE (gauge above nominal 1435mm) ---
    if (gaugeValue >= 1435) {

        // IAL - Block the line (Static plus dynamic movement)
        if (lineSpeed >= 105 && gaugeValue >= 1472) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial-block',
                action: 'BLOCK THE LINE - Correct before opening to traffic' };
        }
        if (lineSpeed <= 100 && gaugeValue >= 1478) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial-block',
                action: 'BLOCK THE LINE - Correct before opening to traffic' };
        }

        // IAL - Correct within 36 hours (Static plus dynamic movement)
        if (lineSpeed >= 105 && gaugeValue >= 1463 && gaugeValue < 1472) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }
        if (lineSpeed <= 100 && gaugeValue >= 1470 && gaugeValue < 1478) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }

        // IAL - Correct within 36 hours (Static Wide Gauge)
        if (lineSpeed > 25 && gaugeValue >= 1458 && gaugeValue <= 1471) {
            return { category: 'IAL', type: 'Static Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }
        if (lineSpeed <= 25 && gaugeValue >= 1460 && gaugeValue <= 1477) {
            return { category: 'IAL', type: 'Static Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }

        // IL - Wide Gauge (Static plus dynamic movement)
        if (lineSpeed >= 105 && gaugeValue >= 1458 && gaugeValue < 1463) {
            return { category: 'IL', type: 'Wide Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: wideILAction };
        }
        if (lineSpeed <= 100 && gaugeValue >= 1460 && gaugeValue < 1470) {
            return { category: 'IL', type: 'Wide Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: wideILAction };
        }

        // IL - Static Wide Gauge
        if (lineSpeed >= 30 && gaugeValue >= 1450 && gaugeValue < 1458) {
            return { category: 'IL', type: 'Static Wide Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Correct within 14 days' };
        }
        if (lineSpeed <= 25 && gaugeValue >= 1450 && gaugeValue < 1460) {
            return { category: 'IL', type: 'Static Wide Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Correct within 14 days' };
        }

        // AL - Wide Gauge (Static plus dynamic movement)
        if (lineSpeed >= 105 && gaugeValue >= 1450 && gaugeValue < 1458) {
            return { category: 'AL', type: 'Wide Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
        if (lineSpeed >= 30 && lineSpeed <= 100 && gaugeValue >= 1450 && gaugeValue < 1460) {
            return { category: 'AL', type: 'Wide Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
        if (lineSpeed <= 25 && gaugeValue >= 1455 && gaugeValue < 1460) {
            return { category: 'AL', type: 'Wide Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }

        // AL - Static Wide Gauge (all speeds)
        if (gaugeValue >= 1445 && gaugeValue < 1450) {
            return { category: 'AL', type: 'Static Wide Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
    }

    // --- TIGHT GAUGE (gauge below nominal) ---
    if (gaugeValue < 1435) {

        // IL - Tight Gauge (severe)
        if (lineSpeed >= 105 && gaugeValue <= 1426) {
            return { category: 'IL', type: 'Tight Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Inspect within 14 days, correct within 84 days' };
        }
        if (lineSpeed <= 100 && gaugeValue <= 1422) {
            return { category: 'IL', type: 'Tight Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Inspect within 14 days, correct within 84 days' };
        }

        // IL - Tight Gauge (review for hunting/rough rides)
        if (lineSpeed >= 105 && gaugeValue > 1426 && gaugeValue <= 1428) {
            return { category: 'IL', type: 'Tight Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Review for reports of Hunting or Rough Rides within 28 days' };
        }
        if (lineSpeed <= 100 && gaugeValue > 1422 && gaugeValue <= 1424) {
            return { category: 'IL', type: 'Tight Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Review for reports of Hunting or Rough Rides within 28 days' };
        }

        // AL - Tight Gauge
        if (lineSpeed >= 105 && gaugeValue > 1428 && gaugeValue <= 1430) {
            return { category: 'AL', type: 'Tight Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
        if (lineSpeed <= 100 && gaugeValue > 1424 && gaugeValue <= 1426) {
            return { category: 'AL', type: 'Tight Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
    }

    return null;
}

// Get the detection thresholds for gauge based on line speed
function getTrackCat() {
    return document.getElementById('trackCatInput').value || '';
}

function getGaugeDetectionThresholds(lineSpeed) {
    const overrides = getOverrideSettings();
    if (!lineSpeed || lineSpeed < 5) {
        // Default broadest thresholds
        const defaults = { tightBelow: 1430, wideAbove: 1445 };
        return overrides.enabled ? applyGaugeOverrides(defaults, overrides) : defaults;
    }
    if (lineSpeed >= 105) {
        const defaults = { tightBelow: 1430, wideAbove: 1445 };
        return overrides.enabled ? applyGaugeOverrides(defaults, overrides) : defaults;
    }
    // 5 to 100mph
    const defaults = { tightBelow: 1426, wideAbove: 1445 };
    return overrides.enabled ? applyGaugeOverrides(defaults, overrides) : defaults;
}

// Get the detection threshold for twist (lowest AL = 12mm)
function getTwistDetectionThreshold() {
    const overrides = getOverrideSettings();
    if (overrides.enabled && Number.isFinite(overrides.twist)) {
        return overrides.twist;
    }
    return 12;
}

// ---- Upload (supports bulk / multiple files) ----
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');

dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    if (e.dataTransfer.files.length) handleFiles(e.dataTransfer.files);
});
fileInput.addEventListener('change', e => { if (e.target.files.length) handleFiles(e.target.files); });

function handleFiles(files) {
    const fileArray = Array.from(files);
    let loaded = 0;
    const errors = [];

    fileArray.forEach(file => {
        const reader = new FileReader();
        reader.onload = e => {
            try {
                const content = e.target.result;
                const result = parseDataForRun(content);
                allRuns.push({
                    parsedData: result.data,
                    metadata: result.meta,
                    filename: file.name,
                    manualGaugeFaults: [],
                    manualTwistFaults: [],
                    dismissedFaults: {},
                    overrides: {
                        enabled: false,
                        gaugeTight: '',
                        gaugeWide: '',
                        twist: ''
                    }
                });
            } catch (err) {
                errors.push(file.name + ': ' + err.message);
            }
            loaded++;
            if (loaded === fileArray.length) {
                onAllFilesLoaded(errors);
            }
        };
        reader.readAsText(file);
    });
}

function normalizeHeaderLabel(label) {
    return (label || '').toLowerCase().replace(/\s+/g, ' ').trim();
}

function buildHeaderMap(cells) {
    const map = {};
    cells.forEach((cell, idx) => {
        const label = normalizeHeaderLabel(cell);
        if (label === 'miles' && map.miles === undefined) map.miles = idx;
        if (label === 'yards' && map.yards === undefined) map.yards = idx;
        if ((label.includes('gauge delta') || (label.startsWith('gauge') && label.includes('delta'))) && map.gaugeDelta === undefined) {
            map.gaugeDelta = idx;
        }
        if (label.startsWith('gauge') && !label.includes('delta') && !label.includes('x-level') && map.gauge === undefined) {
            map.gauge = idx;
        }
        if (label.startsWith('x-level') && map.xlevel === undefined) map.xlevel = idx;
        if (label.startsWith('twist 1') && map.twist1 === undefined) map.twist1 = idx;
        if (label.startsWith('twist 2') && map.twist2 === undefined) map.twist2 = idx;
        if (label.startsWith('gps') && map.gps === undefined) map.gps = idx;
        if ((label.includes('zone reference') || label.includes('default zones') || label === 'zone' || label.startsWith('zone ')) && map.zone === undefined) {
            map.zone = idx;
        }
    });
    return map;
}

function parseDataForRun(content) {
    let lines;
    if (content.includes('<table') || content.includes('<TABLE')) {
        lines = parseHTMLTable(content);
    } else {
        lines = content.split('\n').map(l => l.trim()).filter(l => l);
    }

    const meta = {};
    const dataRows = [];
    let headerFound = false;
    let headerMap = null;

    for (let i = 0; i < lines.length; i++) {
        const line = typeof lines[i] === 'string' ? lines[i] : lines[i].join('\t');
        const cells = typeof lines[i] === 'string'
            ? line.split('\t').map(c => c.trim())
            : lines[i].map(c => (c || '').trim());

        if (!headerFound && cells[0] === 'Miles' && cells[1] === 'Yards') {
            headerFound = true;
            headerMap = buildHeaderMap(cells);
            continue;
        }

        if (!headerFound) {
            if (cells.length >= 2 && cells[0] && cells[1]) {
                meta[cells[0]] = cells[1];
            } else if (cells.length === 1 && cells[0].includes('\t')) {
                const parts = cells[0].split('\t');
                if (parts.length >= 2) meta[parts[0].trim()] = parts[1].trim();
            }
            if (typeof lines[i] === 'string' && !cells[1] && line.includes('\t')) {
                const parts = line.split('\t');
                if (parts.length >= 2 && parts[0].trim()) {
                    meta[parts[0].trim()] = parts[1].trim();
                }
            }
            continue;
        }

        if (headerFound && cells[0] && !isNaN(parseFloat(cells[0]))) {
            const getCell = (key, fallbackIdx) => {
                if (headerMap && Number.isFinite(headerMap[key])) {
                    return cells[headerMap[key]];
                }
                return cells[fallbackIdx];
            };
            const milesCell = getCell('miles', 0);
            const yardsCell = getCell('yards', 1);
            const row = {
                miles: parseFloat(milesCell),
                yards: parseFloat(yardsCell),
                gauge: parseFloat(getCell('gauge', 2)),
                xlevel: parseFloat(getCell('xlevel', 3)),
                twist1: (() => {
                    const cell = getCell('twist1', 4);
                    return cell !== '' && cell !== undefined ? parseFloat(cell) : null;
                })(),
                twist2: (() => {
                    const cell = getCell('twist2', 5);
                    return cell !== '' && cell !== undefined ? parseFloat(cell) : null;
                })(),
                zone: getCell('zone', 7) || getCell('zone', 6) || ''
            };
            if (!isNaN(row.miles) && !isNaN(row.yards) && !isNaN(row.gauge)) {
                row.location = row.miles + 'mi ' + row.yards.toFixed(1) + 'yds';
                dataRows.push(row);
            }
        }
    }

    if (dataRows.length === 0) {
        throw new Error('No measurement data rows found. Check file format.');
    }

    return { data: dataRows, meta: meta };
}

function onAllFilesLoaded(errors) {
    if (errors.length > 0 && allRuns.length === 0) {
        alert('Failed to parse files:\n' + errors.join('\n'));
        return;
    }
    if (errors.length > 0) {
        alert('Some files had errors:\n' + errors.join('\n') + '\n\nSuccessfully loaded ' + allRuns.length + ' run(s).');
    }

    // Show run selector if multiple runs
    updateRunSelector();
    switchRun(0);

    document.getElementById('uploadScreen').style.display = 'none';
    document.getElementById('reportContainer').classList.add('active');
}

function updateRunSelector() {
    const bar = document.getElementById('runSelectorBar');
    const sel = document.getElementById('runSelector');
    const countEl = document.getElementById('runCount');

    if (allRuns.length > 1) {
        bar.style.display = 'flex';
        sel.innerHTML = allRuns.map((run, i) => {
            const label = run.metadata['Route ID']
                ? run.metadata['Route ID'] + ' / ' + (run.metadata['Track ID'] || '') + ' (' + run.filename + ')'
                : run.filename;
            return `<option value="${i}">${label}</option>`;
        }).join('');
        countEl.textContent = allRuns.length + ' runs loaded';
    } else {
        bar.style.display = 'none';
    }
}

function switchRun(index) {
    index = parseInt(index);
    activeRunIndex = index;
    const run = allRuns[index];
    parsedData = run.parsedData;
    metadata = run.metadata;
    manualGaugeFaults = run.manualGaugeFaults;
    manualTwistFaults = run.manualTwistFaults;
    dismissedFaults = run.dismissedFaults || {};
    applyOverrideSettings(run.overrides || {});

    const derivedSpeed = getLineSpeedFromZones(parsedData);
    if (Number.isFinite(derivedSpeed)) {
        document.getElementById('lineSpeedInput').value = derivedSpeed;
    }

    document.getElementById('runSelector').value = index;
    identifyFaults();
    buildReport();
}

function handleFile(file) {
    handleFiles([file]);
}

// ---- Parsing ----
function parseData(content) {
    const result = parseDataForRun(content);
    parsedData = result.data;
    metadata = result.meta;
    identifyFaults();
}

function parseHTMLTable(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const rows = doc.querySelectorAll('tr');
    const result = [];
    rows.forEach(row => {
        const cells = [];
        row.querySelectorAll('td, th').forEach(cell => cells.push(cell.textContent.trim()));
        if (cells.length > 0) result.push(cells);
    });
    return result;
}

function formatLocation(row) {
    return row.miles + 'mi ' + row.yards.toFixed(1) + 'yds';
}

function parseZoneSpeedValue(zoneText) {
    if (!zoneText) return null;
    const rangeMatch = zoneText.match(/(\d+)\s*-\s*(\d+)\s*mph/i);
    if (rangeMatch) return parseInt(rangeMatch[2], 10);
    const singleMatch = zoneText.match(/(\d+)\s*mph/i);
    if (singleMatch) return parseInt(singleMatch[1], 10);
    return null;
}

function getLineSpeedFromZones(data) {
    const counts = new Map();
    data.forEach(row => {
        const speed = parseZoneSpeedValue(row.zone);
        if (!Number.isFinite(speed)) return;
        counts.set(speed, (counts.get(speed) || 0) + 1);
    });
    if (counts.size === 0) return null;
    let bestSpeed = null;
    let bestCount = -1;
    counts.forEach((count, speed) => {
        if (count > bestCount) {
            bestCount = count;
            bestSpeed = speed;
        }
    });
    return bestSpeed;
}

// ---- Fault Identification ----
function identifyFaults() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    identifyGaugeFaults(lineSpeed);
    identifyTwistFaults();
}

function identifyGaugeFaults(lineSpeed) {
    gaugeFaults = [];
    const thresholds = getGaugeDetectionThresholds(lineSpeed);
    let inFault = false;
    let currentFault = null;

    for (let i = 0; i < parsedData.length; i++) {
        const row = parsedData[i];
        const isTight = row.gauge <= thresholds.tightBelow;
        const isWide = row.gauge >= thresholds.wideAbove;
        const isFault = isTight || isWide;

        if (isFault) {
            if (!inFault) {
                currentFault = {
                    startIdx: i,
                    startLocation: formatLocation(row),
                    startMiles: row.miles,
                    startYards: row.yards,
                    worstGauge: row.gauge,
                    direction: isWide ? 'wide' : 'tight',
                    rows: [row]
                };
                inFault = true;
            } else {
                currentFault.rows.push(row);
                if (currentFault.direction === 'wide') {
                    if (row.gauge > currentFault.worstGauge) currentFault.worstGauge = row.gauge;
                } else {
                    if (row.gauge < currentFault.worstGauge) currentFault.worstGauge = row.gauge;
                }
            }
        } else {
            if (inFault) {
                finishGaugeFault(currentFault);
                gaugeFaults.push(currentFault);
                inFault = false;
                currentFault = null;
            }
        }
    }
    if (inFault) {
        finishGaugeFault(currentFault);
        gaugeFaults.push(currentFault);
    }
}

function finishGaugeFault(fault) {
    const lastRow = fault.rows[fault.rows.length - 1];
    fault.endLocation = formatLocation(lastRow);
    fault.endMiles = lastRow.miles;
    fault.endYards = lastRow.yards;
    fault.length = (fault.endYards - fault.startYards).toFixed(1);
    if (fault.direction === 'wide') {
        fault.deviation = '+' + (fault.worstGauge - 1435).toFixed(1);
    } else {
        fault.deviation = '-' + (1435 - fault.worstGauge).toFixed(1);
    }
}

function identifyTwistFaults() {
    const threshold = getTwistDetectionThreshold();
    twistFaults = [];
    twistFaultRadiusSettings = [];
    let inFault = false;
    let currentFault = null;

    for (let i = 0; i < parsedData.length; i++) {
        const row = parsedData[i];
        const hasTwist = row.twist1 !== null && !isNaN(row.twist1) &&
            Math.abs(row.twist1) >= threshold;

        if (hasTwist) {
            if (!inFault) {
                currentFault = {
                    startIdx: i,
                    startLocation: formatLocation(row),
                    startMiles: row.miles,
                    startYards: row.yards,
                    maxAbsTwist: Math.abs(row.twist1),
                    worstValue: row.twist1,
                    rows: [row]
                };
                inFault = true;
            } else {
                currentFault.rows.push(row);
                if (Math.abs(row.twist1) > currentFault.maxAbsTwist) {
                    currentFault.maxAbsTwist = Math.abs(row.twist1);
                    currentFault.worstValue = row.twist1;
                }
            }
        } else {
            if (inFault) {
                const lastRow = currentFault.rows[currentFault.rows.length - 1];
                currentFault.endLocation = formatLocation(lastRow);
                currentFault.endMiles = lastRow.miles;
                currentFault.endYards = lastRow.yards;
                currentFault.length = (currentFault.endYards - currentFault.startYards).toFixed(1);
                twistFaults.push(currentFault);
                twistFaultRadiusSettings.push(false); // default: >= 400m
                inFault = false;
                currentFault = null;
            }
        }
    }
    if (inFault) {
        const lastRow = currentFault.rows[currentFault.rows.length - 1];
        currentFault.endLocation = formatLocation(lastRow);
        currentFault.endMiles = lastRow.miles;
        currentFault.endYards = lastRow.yards;
        currentFault.length = (currentFault.endYards - currentFault.startYards).toFixed(1);
        twistFaults.push(currentFault);
        twistFaultRadiusSettings.push(false);
    }
}

// ---- Build Report ----
function buildReport() {
    const route = metadata['Route ID'] || '';
    const track = metadata['Track ID'] || '';
    document.getElementById('reportTitle').textContent =
        'Track Inspection Report' + (route ? ' - ' + route : '') + (track ? ' / ' + track : '');

    // Metadata
    const metaGrid = document.getElementById('metaGrid');
    metaGrid.innerHTML = '';
    const displayKeys = [
        'Operator ID', 'Profile', 'Start Location', 'End Location',
        'Direction Of Travel', 'Job Reference', 'Route ID', 'Track ID',
        'Start Time', 'End Time', 'Serial Number', 'Reference Gauge',
        'Calibrated', 'Twist Base 1', 'Software Version', 'Acquisition Rate'
    ];
    displayKeys.forEach(key => {
        if (metadata[key]) {
            metaGrid.innerHTML += `<div class="meta-item"><span class="label">${key}</span><span class="value">${metadata[key]}</span></div>`;
        }
    });

    updateSummaryStats();
    buildCharts();
    buildSchematic();
    buildGaugeFaultTable();
    buildTwistFaultTable();
    updateSpeedWarning();
    updateComparison();

    // Tab handling
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById('page-' + tab.dataset.page).classList.add('active');
        });
    });

    // Line speed + track cat change handlers
    document.getElementById('lineSpeedInput').addEventListener('change', onLineSpeedChange);
    document.getElementById('lineSpeedInput').addEventListener('input', onLineSpeedChange);
    document.getElementById('trackCatInput').addEventListener('change', onLineSpeedChange);
    document.getElementById('overrideToggle').addEventListener('change', onOverrideChange);
    document.getElementById('overrideGaugeTight').addEventListener('input', onOverrideChange);
    document.getElementById('overrideGaugeWide').addEventListener('input', onOverrideChange);
    document.getElementById('overrideTwist').addEventListener('input', onOverrideChange);
}

function applyOverrideSettings(overrides) {
    document.getElementById('overrideToggle').checked = !!overrides.enabled;
    document.getElementById('overrideGaugeTight').value = overrides.gaugeTight ?? '';
    document.getElementById('overrideGaugeWide').value = overrides.gaugeWide ?? '';
    document.getElementById('overrideTwist').value = overrides.twist ?? '';
}

function getOverrideSettings() {
    return {
        enabled: document.getElementById('overrideToggle').checked,
        gaugeTight: parseFloat(document.getElementById('overrideGaugeTight').value),
        gaugeWide: parseFloat(document.getElementById('overrideGaugeWide').value),
        twist: parseFloat(document.getElementById('overrideTwist').value)
    };
}

function applyGaugeOverrides(defaults, overrides) {
    return {
        tightBelow: Number.isFinite(overrides.gaugeTight) ? overrides.gaugeTight : defaults.tightBelow,
        wideAbove: Number.isFinite(overrides.gaugeWide) ? overrides.gaugeWide : defaults.wideAbove
    };
}

function onOverrideChange() {
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        const overrides = getOverrideSettings();
        allRuns[activeRunIndex].overrides = {
            enabled: overrides.enabled,
            gaugeTight: Number.isFinite(overrides.gaugeTight) ? overrides.gaugeTight : '',
            gaugeWide: Number.isFinite(overrides.gaugeWide) ? overrides.gaugeWide : '',
            twist: Number.isFinite(overrides.twist) ? overrides.twist : ''
        };
    }
    onLineSpeedChange();
}

function onLineSpeedChange() {
    identifyFaults();
    updateSummaryStats();
    buildGaugeFaultTable();
    buildTwistFaultTable();
    buildCharts();
    buildSchematic();
    updateSpeedWarning();
}

function updateSpeedWarning() {
    const speed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const warning = document.getElementById('speedWarning');
    if (speed < 5) {
        warning.classList.add('visible');
    } else {
        warning.classList.remove('visible');
    }
}

function updateSummaryStats() {
    const statsDiv = document.getElementById('summaryStats');
    const totalPoints = parsedData.length;
    const minGauge = Math.min(...parsedData.map(r => r.gauge));
    const maxGauge = Math.max(...parsedData.map(r => r.gauge));
    const twistValues = parsedData.filter(r => r.twist1 !== null).map(r => r.twist1);
    const maxTwist = twistValues.length ? Math.max(...twistValues.map(v => Math.abs(v))) : 0;

    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const allGaugeFaults = gaugeFaults.concat(manualGaugeFaults);
    const allTwistFaults = twistFaults.concat(manualTwistFaults);
    const ialGauge = allGaugeFaults.filter(f => { const c = classifyGaugeFault(f.worstGauge, lineSpeed, getTrackCat()); return c && c.category === 'IAL'; }).length;
    const ialTwist = allTwistFaults.filter((f, i) => {
        const isManual = i >= twistFaults.length;
        const radius = isManual ? f.curveRadiusLessThan400 : twistFaultRadiusSettings[i];
        const c = classifyTwistFault(f.maxAbsTwist, lineSpeed, radius);
        return c && c.category === 'IAL';
    }).length;

    const totalGauge = allGaugeFaults.length;
    const totalTwist = allTwistFaults.length;
    const manualCount = manualGaugeFaults.length + manualTwistFaults.length;
    const manualNote = manualCount > 0 ? ` (${manualCount} manual)` : '';

    statsDiv.innerHTML = `
        <div class="stat-card"><div class="number">${totalPoints}</div><div class="label">Data Points</div></div>
        <div class="stat-card ${totalGauge > 0 ? 'danger' : ''}"><div class="number">${totalGauge}</div><div class="label">Gauge Faults${manualGaugeFaults.length > 0 ? ' (' + manualGaugeFaults.length + ' manual)' : ''}</div></div>
        <div class="stat-card ${totalTwist > 0 ? 'warning' : ''}"><div class="number">${totalTwist}</div><div class="label">Twist Faults${manualTwistFaults.length > 0 ? ' (' + manualTwistFaults.length + ' manual)' : ''}</div></div>
        <div class="stat-card ${ialGauge + ialTwist > 0 ? 'danger' : ''}"><div class="number">${ialGauge + ialTwist}</div><div class="label">IAL Faults</div></div>
        <div class="stat-card"><div class="number">${minGauge.toFixed(1)}</div><div class="label">Min Gauge (mm)</div></div>
        <div class="stat-card"><div class="number">${maxTwist.toFixed(1)}</div><div class="label">Max |Twist| (mm)</div></div>
    `;
}

// ---- Chart threshold helpers ----
function getGaugeChartThresholds(lineSpeed) {
    const lines = [];
    // Reference
    lines.push({ value: 1435, label: 'Reference (1435)', color: '#666', dash: [6, 4], width: 1 });

    // Wide gauge thresholds
    lines.push({ value: 1445, label: 'Wide AL (1445)', color: '#28a745', dash: [4, 4], width: 1 });

    if (lineSpeed >= 30) {
        lines.push({ value: 1450, label: 'Wide IL (1450)', color: '#e67e22', dash: [5, 3], width: 1 });
    } else if (lineSpeed >= 5) {
        lines.push({ value: 1450, label: 'Wide IL (1450)', color: '#e67e22', dash: [5, 3], width: 1 });
    }

    if (lineSpeed > 25) {
        lines.push({ value: 1458, label: 'Wide IAL (1458)', color: '#c0392b', dash: [6, 3], width: 1.5 });
    } else if (lineSpeed >= 5) {
        lines.push({ value: 1460, label: 'Wide IAL (1460)', color: '#c0392b', dash: [6, 3], width: 1.5 });
    }

    if (lineSpeed >= 105) {
        lines.push({ value: 1472, label: 'Block Line (1472)', color: '#721c24', dash: [8, 4], width: 2 });
    } else if (lineSpeed >= 5) {
        lines.push({ value: 1478, label: 'Block Line (1478)', color: '#721c24', dash: [8, 4], width: 2 });
    }

    // Tight gauge thresholds
    if (lineSpeed >= 105) {
        lines.push({ value: 1430, label: 'Tight AL (1430)', color: '#28a745', dash: [4, 4], width: 1 });
        lines.push({ value: 1428, label: 'Tight IL (1428)', color: '#e67e22', dash: [5, 3], width: 1 });
        lines.push({ value: 1426, label: 'Tight IL (1426)', color: '#c0392b', dash: [6, 3], width: 1.5 });
    } else if (lineSpeed >= 5) {
        lines.push({ value: 1426, label: 'Tight AL (1426)', color: '#28a745', dash: [4, 4], width: 1 });
        lines.push({ value: 1424, label: 'Tight IL (1424)', color: '#e67e22', dash: [5, 3], width: 1 });
        lines.push({ value: 1422, label: 'Tight IL (1422)', color: '#c0392b', dash: [6, 3], width: 1.5 });
    }

    return lines;
}

function getTwistChartThresholds(lineSpeed) {
    const lines = [];
    // AL: 12mm
    lines.push({ value: 12, label: 'AL (12mm)', color: '#28a745', dash: [4, 4], width: 1 });
    // IL: 15mm (lowest IL across all configurations)
    lines.push({ value: 15, label: 'IL (15mm)', color: '#e67e22', dash: [5, 3], width: 1 });
    // IAL: speed-dependent
    if (lineSpeed >= 80) {
        lines.push({ value: 21, label: 'IAL (21mm)', color: '#c0392b', dash: [6, 3], width: 1.5 });
    } else if (lineSpeed >= 5) {
        lines.push({ value: 24, label: 'IAL (24mm)', color: '#c0392b', dash: [6, 3], width: 1.5 });
    }
    // Block line: 33mm
    lines.push({ value: 33, label: 'Block (33mm)', color: '#721c24', dash: [8, 4], width: 2 });
    return lines;
}

function splitDataByYards(data, segmentLength) {
    if (!data.length) return [];
    const positions = data.map(r => r.miles * 1760 + r.yards);
    const minPos = Math.min(...positions);
    const segments = [];
    data.forEach((row, idx) => {
        const pos = positions[idx];
        const segmentIndex = Math.floor((pos - minPos) / segmentLength);
        if (!segments[segmentIndex]) {
            segments[segmentIndex] = { rows: [] };
        }
        segments[segmentIndex].rows.push(row);
    });
    return segments.map((segment, index) => {
        const rows = segment.rows;
        return {
            rows,
            index,
            startLabel: rows.length ? formatLocation(rows[0]) : '',
            endLabel: rows.length ? formatLocation(rows[rows.length - 1]) : ''
        };
    }).filter(segment => segment.rows.length);
}

function buildCharts() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const segments = splitDataByYards(parsedData, 440);
    const gaugeContainer = document.getElementById('gaugeCharts');
    const twistContainer = document.getElementById('twistCharts');

    gaugeChartInstances.forEach(chart => chart.destroy());
    twistChartInstances.forEach(chart => chart.destroy());
    gaugeChartInstances = [];
    twistChartInstances = [];
    gaugeContainer.innerHTML = '';
    twistContainer.innerHTML = '';

    segments.forEach(segment => {
        const rows = segment.rows;
        const labels = rows.map(r => r.miles + 'mi ' + r.yards.toFixed(0) + 'y');
        const step = Math.max(1, Math.floor(rows.length / 30));
        const displayLabels = labels.map((l, i) => i % step === 0 ? l : '');
        const n = rows.length;

        const segmentTitle = document.createElement('div');
        segmentTitle.className = 'chart-segment-title';
        segmentTitle.textContent = `${segment.startLabel} â†’ ${segment.endLabel} (max 440 yds)`;

        // ---- Gauge chart ----
        const gaugeWrapper = document.createElement('div');
        gaugeWrapper.className = 'chart-wrapper';
        const gaugeCanvas = document.createElement('canvas');
        gaugeWrapper.appendChild(gaugeCanvas);
        gaugeContainer.appendChild(segmentTitle.cloneNode(true));
        gaugeContainer.appendChild(gaugeWrapper);

        const gaugeDatasets = [
            {
                label: 'Gauge (mm)',
                data: rows.map(r => r.gauge),
                borderColor: '#4a6cf7',
                backgroundColor: 'rgba(74,108,247,0.1)',
                fill: true, borderWidth: 1.5, pointRadius: 0, tension: 0.3
            }
        ];

        const gaugeThresholds = getGaugeChartThresholds(lineSpeed);
        gaugeThresholds.forEach(t => {
            gaugeDatasets.push({
                label: t.label,
                data: Array(n).fill(t.value),
                borderColor: t.color, borderWidth: t.width, borderDash: t.dash,
                pointRadius: 0, fill: false
            });
        });

        const gaugeChart = new Chart(gaugeCanvas.getContext('2d'), {
            type: 'line',
            data: { labels: displayLabels, datasets: gaugeDatasets },
            options: {
                responsive: true, maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: { position: 'top', labels: { usePointStyle: true, padding: 12, font: { size: 10 } } },
                    tooltip: { callbacks: { title: (items) => labels[items[0].dataIndex] } }
                },
                scales: {
                    x: { ticks: { maxRotation: 45, font: { size: 10 } } },
                    y: { title: { display: true, text: 'Gauge (mm)' } }
                }
            }
        });
        gaugeChartInstances.push(gaugeChart);

        // ---- Twist chart ----
        const twistWrapper = document.createElement('div');
        twistWrapper.className = 'chart-wrapper';
        const twistCanvas = document.createElement('canvas');
        twistWrapper.appendChild(twistCanvas);
        twistContainer.appendChild(segmentTitle.cloneNode(true));
        twistContainer.appendChild(twistWrapper);

        const twistDatasets = [
            {
                label: 'Twist 1 - 3m (mm)',
                data: rows.map(r => r.twist1),
                borderColor: '#e67e22', backgroundColor: 'rgba(230,126,34,0.1)',
                fill: true, borderWidth: 1.5, pointRadius: 0, tension: 0.3, spanGaps: false
            },
            {
                label: 'Zero',
                data: Array(n).fill(0),
                borderColor: '#aaa', borderWidth: 1, borderDash: [3, 3], pointRadius: 0, fill: false
            }
        ];

        const twistThresholds = getTwistChartThresholds(lineSpeed);
        twistThresholds.forEach(t => {
            // Positive line (shown in legend)
            twistDatasets.push({
                label: '+' + t.label,
                data: Array(n).fill(t.value),
                borderColor: t.color, borderWidth: t.width, borderDash: t.dash,
                pointRadius: 0, fill: false
            });
            // Negative mirror (hidden from legend)
            twistDatasets.push({
                label: '-' + t.label,
                data: Array(n).fill(-t.value),
                borderColor: t.color, borderWidth: t.width, borderDash: t.dash,
                pointRadius: 0, fill: false
            });
        });

        const twistChart = new Chart(twistCanvas.getContext('2d'), {
            type: 'line',
            data: { labels: displayLabels, datasets: twistDatasets },
            options: {
                responsive: true, maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            usePointStyle: true, padding: 12, font: { size: 10 },
                            filter: (item) => !item.text.startsWith('-')
                        }
                    },
                    tooltip: { callbacks: { title: (items) => labels[items[0].dataIndex] } }
                },
                scales: {
                    x: { ticks: { maxRotation: 45, font: { size: 10 } } },
                    y: { title: { display: true, text: 'Twist (mm)' } }
                }
            }
        });
        twistChartInstances.push(twistChart);
    });
}

function buildGaugeFaultTable() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const tbody = document.querySelector('#gaugeFaultTable tbody');
    tbody.innerHTML = '';
    const allGaugeFaults = gaugeFaults.concat(manualGaugeFaults);
    if (allGaugeFaults.length === 0) {
        tbody.innerHTML = '<tr><td colspan="11" style="text-align:center;padding:30px;color:#888;">No gauge faults detected</td></tr>';
        return;
    }
    allGaugeFaults.forEach((f, idx) => {
        const dismissed = isDismissed('gauge', idx);
        const classification = classifyGaugeFault(f.worstGauge, lineSpeed, getTrackCat());
        const tr = document.createElement('tr');
        tr.className = (classification ? classification.rowClass : '') + (dismissed ? ' dismissed-fault' : '');
        const catBadge = classification
            ? `<span class="badge ${classification.badge}">${classification.category}</span>`
            : '<span style="color:#999;">--</span>';
        const faultType = classification ? classification.type : (f.direction === 'wide' ? 'Wide Gauge' : 'Tight Gauge');
        const actionText = classification ? classification.action : (lineSpeed < 5 ? 'Set line speed' : 'Below threshold');
        const manualTag = f.manual ? '<span class="manual-fault-tag">MANUAL</span>' : '';
        const removeBtn = f.manual && !dismissed ? `<button class="btn-remove-fault" onclick="removeManualGaugeFault(${idx - gaugeFaults.length})" title="Remove manual fault">X</button> ` : '';
        const defaultFaultNo = f.manual && f.faultNo ? f.faultNo : '';

        let dismissBtn;
        let dismissInfo = '';
        if (dismissed) {
            dismissBtn = `<button class="btn-restore-fault" onclick="restoreFault('gauge',${idx})">Restore</button>`;
            dismissInfo = `<span class="dismissed-info">Dismissed by ${dismissed.inspector} on ${dismissed.displayTime}: ${dismissed.comment}</span>`;
        } else {
            dismissBtn = `<button class="btn-dismiss-fault" onclick="openDismissModal('gauge',${idx})">Dismiss</button>`;
        }

        tr.innerHTML = `
            <td>${idx + 1} ${manualTag}</td>
            <td><input type="text" class="fault-no-input" data-type="gauge" data-idx="${idx}" placeholder="--" value="${defaultFaultNo}" style="width:55px;padding:3px 5px;border:1px solid #ccc;border-radius:4px;font-size:11px;text-align:center;"></td>
            <td>${f.startLocation}</td>
            <td>${f.endLocation}</td>
            <td>${f.length}</td>
            <td>${f.worstGauge.toFixed(1)}</td>
            <td>${f.deviation}</td>
            <td>${faultType}</td>
            <td>${catBadge}</td>
            <td style="font-size:11px;max-width:220px;">${actionText} ${removeBtn}${dismissBtn}${dismissInfo}</td>
            <td style="text-align:center;"><input type="checkbox" class="repeat-fault-cb" data-type="gauge" data-idx="${idx}"></td>
        `;
        tbody.appendChild(tr);
    });
}

function buildTwistFaultTable() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const tbody = document.querySelector('#twistFaultTable tbody');
    tbody.innerHTML = '';
    const allTwistFaults = twistFaults.concat(manualTwistFaults);
    if (allTwistFaults.length === 0) {
        tbody.innerHTML = '<tr><td colspan="11" style="text-align:center;padding:30px;color:#888;">No twist faults detected</td></tr>';
        return;
    }
    allTwistFaults.forEach((f, idx) => {
        const dismissed = isDismissed('twist', idx);
        const isLessThan400 = f.manual ? f.curveRadiusLessThan400 : twistFaultRadiusSettings[idx];
        const classification = classifyTwistFault(f.maxAbsTwist, lineSpeed, isLessThan400);
        const tr = document.createElement('tr');
        tr.className = (classification ? classification.rowClass : '') + (dismissed ? ' dismissed-fault' : '');
        const catBadge = classification
            ? `<span class="badge ${classification.badge}">${classification.category}</span>`
            : '<span style="color:#999;">--</span>';
        const actionText = classification ? classification.action : (lineSpeed < 5 ? 'Set line speed' : 'Below threshold');
        const manualTag = f.manual ? '<span class="manual-fault-tag">MANUAL</span>' : '';
        const removeBtn = f.manual && !dismissed ? `<button class="btn-remove-fault" onclick="removeManualTwistFault(${idx - twistFaults.length})" title="Remove manual fault">X</button> ` : '';
        const defaultFaultNo = f.manual && f.faultNo ? f.faultNo : '';

        let dismissBtn;
        let dismissInfo = '';
        if (dismissed) {
            dismissBtn = `<button class="btn-restore-fault" onclick="restoreFault('twist',${idx})">Restore</button>`;
            dismissInfo = `<span class="dismissed-info">Dismissed by ${dismissed.inspector} on ${dismissed.displayTime}: ${dismissed.comment}</span>`;
        } else {
            dismissBtn = `<button class="btn-dismiss-fault" onclick="openDismissModal('twist',${idx})">Dismiss</button>`;
        }

        tr.innerHTML = `
            <td>${idx + 1} ${manualTag}</td>
            <td><input type="text" class="fault-no-input" data-type="twist" data-idx="${idx}" placeholder="--" value="${defaultFaultNo}" style="width:55px;padding:3px 5px;border:1px solid #ccc;border-radius:4px;font-size:11px;text-align:center;"></td>
            <td>${f.startLocation}</td>
            <td>${f.endLocation}</td>
            <td>${f.length}</td>
            <td>${f.maxAbsTwist.toFixed(1)}</td>
            <td>${f.worstValue.toFixed(1)}</td>
            <td>
                <select class="radius-select" data-twist-idx="${idx}" onchange="onRadiusChange(this)">
                    <option value="gte400" ${!isLessThan400 ? 'selected' : ''}>&ge; 400m</option>
                    <option value="lt400" ${isLessThan400 ? 'selected' : ''}>&lt; 400m</option>
                </select>
            </td>
            <td>${catBadge}</td>
            <td style="font-size:11px;max-width:220px;">${actionText} ${removeBtn}${dismissBtn}${dismissInfo}</td>
            <td style="text-align:center;"><input type="checkbox" class="repeat-fault-cb" data-type="twist" data-idx="${idx}"></td>
        `;
        tbody.appendChild(tr);
    });
}

function onRadiusChange(selectEl) {
    const idx = parseInt(selectEl.dataset.twistIdx);
    const isManual = idx >= twistFaults.length;
    if (isManual) {
        const manualIdx = idx - twistFaults.length;
        manualTwistFaults[manualIdx].curveRadiusLessThan400 = (selectEl.value === 'lt400');
    } else {
        twistFaultRadiusSettings[idx] = (selectEl.value === 'lt400');
    }
    buildTwistFaultTable();
    updateSummaryStats();
}

// ---- Navigation ----
function goBack() {
    document.getElementById('uploadScreen').style.display = 'flex';
    document.getElementById('reportContainer').classList.remove('active');
    document.getElementById('runSelectorBar').style.display = 'none';
    fileInput.value = '';
    allRuns = [];
    activeRunIndex = -1;
    manualGaugeFaults = [];
    manualTwistFaults = [];
    dismissedFaults = {};
}

// ---- Manual Fault Modals ----
function openManualGaugeFaultModal() {
    document.getElementById('mgStartMiles').value = '';
    document.getElementById('mgStartYards').value = '';
    document.getElementById('mgEndMiles').value = '';
    document.getElementById('mgEndYards').value = '';
    document.getElementById('mgWorstGauge').value = '';
    document.getElementById('mgFaultDirection').value = 'wide';
    document.getElementById('mgFaultNo').value = '';
    document.getElementById('gaugeModal').classList.add('active');
}

function openManualTwistFaultModal() {
    document.getElementById('mtStartMiles').value = '';
    document.getElementById('mtStartYards').value = '';
    document.getElementById('mtEndMiles').value = '';
    document.getElementById('mtEndYards').value = '';
    document.getElementById('mtMaxTwist').value = '';
    document.getElementById('mtWorstValue').value = '';
    document.getElementById('mtCurveRadius').value = 'gte400';
    document.getElementById('mtFaultNo').value = '';
    document.getElementById('twistModal').classList.add('active');
}

function closeModal(id) {
    document.getElementById(id).classList.remove('active');
}

function saveManualGaugeFault() {
    const startMiles = parseFloat(document.getElementById('mgStartMiles').value);
    const startYards = parseFloat(document.getElementById('mgStartYards').value);
    const endMiles = parseFloat(document.getElementById('mgEndMiles').value);
    const endYards = parseFloat(document.getElementById('mgEndYards').value);
    const worstGauge = parseFloat(document.getElementById('mgWorstGauge').value);
    const direction = document.getElementById('mgFaultDirection').value;
    const faultNo = document.getElementById('mgFaultNo').value;

    if (isNaN(startMiles) || isNaN(startYards) || isNaN(endMiles) || isNaN(endYards) || isNaN(worstGauge)) {
        alert('Please fill in all required fields (miles, yards, worst gauge).');
        return;
    }

    const fault = {
        startLocation: startMiles + 'mi ' + startYards.toFixed(1) + 'yds',
        endLocation: endMiles + 'mi ' + endYards.toFixed(1) + 'yds',
        startMiles, startYards, endMiles, endYards,
        worstGauge: worstGauge,
        direction: direction,
        length: (endYards - startYards).toFixed(1),
        deviation: direction === 'wide'
            ? '+' + (worstGauge - 1435).toFixed(1)
            : '-' + (1435 - worstGauge).toFixed(1),
        manual: true,
        faultNo: faultNo,
        rows: []
    };

    manualGaugeFaults.push(fault);
    // Persist to current run
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].manualGaugeFaults = manualGaugeFaults;
    }

    closeModal('gaugeModal');
    buildGaugeFaultTable();
    updateSummaryStats();
}

function saveManualTwistFault() {
    const startMiles = parseFloat(document.getElementById('mtStartMiles').value);
    const startYards = parseFloat(document.getElementById('mtStartYards').value);
    const endMiles = parseFloat(document.getElementById('mtEndMiles').value);
    const endYards = parseFloat(document.getElementById('mtEndYards').value);
    const maxTwist = parseFloat(document.getElementById('mtMaxTwist').value);
    const worstValue = parseFloat(document.getElementById('mtWorstValue').value);
    const curveRadius = document.getElementById('mtCurveRadius').value;
    const faultNo = document.getElementById('mtFaultNo').value;

    if (isNaN(startMiles) || isNaN(startYards) || isNaN(endMiles) || isNaN(endYards) || isNaN(maxTwist) || isNaN(worstValue)) {
        alert('Please fill in all required fields.');
        return;
    }

    const fault = {
        startLocation: startMiles + 'mi ' + startYards.toFixed(1) + 'yds',
        endLocation: endMiles + 'mi ' + endYards.toFixed(1) + 'yds',
        startMiles, startYards, endMiles, endYards,
        maxAbsTwist: maxTwist,
        worstValue: worstValue,
        length: (endYards - startYards).toFixed(1),
        manual: true,
        faultNo: faultNo,
        curveRadiusLessThan400: curveRadius === 'lt400',
        rows: []
    };

    manualTwistFaults.push(fault);
    twistFaultRadiusSettings.push(fault.curveRadiusLessThan400);
    // Persist to current run
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].manualTwistFaults = manualTwistFaults;
    }

    closeModal('twistModal');
    buildTwistFaultTable();
    updateSummaryStats();
}

function removeManualGaugeFault(manualIdx) {
    manualGaugeFaults.splice(manualIdx, 1);
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].manualGaugeFaults = manualGaugeFaults;
    }
    buildGaugeFaultTable();
    updateSummaryStats();
}

function removeManualTwistFault(manualIdx) {
    // Find the position in the combined array to remove the radius setting
    const combinedIdx = twistFaults.length + manualIdx;
    twistFaultRadiusSettings.splice(combinedIdx, 1);
    manualTwistFaults.splice(manualIdx, 1);
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].manualTwistFaults = manualTwistFaults;
    }
    buildTwistFaultTable();
    updateSummaryStats();
}

// ---- Dismiss / Restore Faults ----
function openDismissModal(faultType, idx) {
    document.getElementById('dismissFaultType').value = faultType;
    document.getElementById('dismissFaultIdx').value = idx;
    document.getElementById('dismissInspector').value = '';
    document.getElementById('dismissReason').value = '';
    document.getElementById('dismissModal').classList.add('active');
}

function confirmDismissFault() {
    const faultType = document.getElementById('dismissFaultType').value;
    const idx = parseInt(document.getElementById('dismissFaultIdx').value);
    const inspector = document.getElementById('dismissInspector').value.trim();
    const reason = document.getElementById('dismissReason').value.trim();

    if (!reason) {
        alert('Please provide a reason for dismissal.');
        return;
    }

    const key = faultType + '-' + idx;
    const now = new Date();
    dismissedFaults[key] = {
        timestamp: now.toISOString(),
        displayTime: now.toLocaleDateString('en-GB') + ' ' + now.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }),
        comment: reason,
        inspector: inspector || 'Unknown'
    };

    // Persist to current run
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].dismissedFaults = Object.assign({}, dismissedFaults);
    }

    closeModal('dismissModal');
    if (faultType === 'gauge') {
        buildGaugeFaultTable();
    } else {
        buildTwistFaultTable();
    }
    updateSummaryStats();
}

function restoreFault(faultType, idx) {
    const key = faultType + '-' + idx;
    delete dismissedFaults[key];

    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].dismissedFaults = Object.assign({}, dismissedFaults);
    }

    if (faultType === 'gauge') {
        buildGaugeFaultTable();
    } else {
        buildTwistFaultTable();
    }
    updateSummaryStats();
}

function isDismissed(faultType, idx) {
    return dismissedFaults[faultType + '-' + idx] || null;
}

// ---- Linear Schematic ----
function buildSchematic() {
    const canvas = document.getElementById('schematicCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('schematicContainer');
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const trackCat = getTrackCat();

    // Calculate track extent
    if (!parsedData || parsedData.length === 0) return;
    const allPoints = parsedData.map(r => r.miles * 1760 + r.yards);
    const minPos = Math.min(...allPoints);
    const maxPos = Math.max(...allPoints);
    const range = maxPos - minPos || 1;

    // Canvas sizing
    const w = Math.max(container.clientWidth - 20, 600);
    const h = 160;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    const padL = 60, padR = 20, trackY = 60, trackH = 10;
    const drawW = w - padL - padR;

    function posToX(miles, yards) {
        return padL + ((miles * 1760 + yards - minPos) / range) * drawW;
    }

    // Clear
    ctx.clearRect(0, 0, w, h);

    // Draw track baseline
    ctx.fillStyle = '#ddd';
    ctx.fillRect(padL, trackY - 1, drawW, trackH);
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 1;
    ctx.strokeRect(padL, trackY - 1, drawW, trackH);

    // Tick marks
    const startMiles = parsedData[0].miles;
    const endMiles = parsedData[parsedData.length - 1].miles;
    ctx.fillStyle = '#666';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    for (let m = startMiles; m <= endMiles; m++) {
        const x = posToX(m, 0);
        if (x >= padL && x <= padL + drawW) {
            ctx.beginPath();
            ctx.moveTo(x, trackY + trackH);
            ctx.lineTo(x, trackY + trackH + 6);
            ctx.strokeStyle = '#999';
            ctx.stroke();
            ctx.fillText(m + 'mi', x, trackY + trackH + 16);
        }
    }

    // Colour map for categories
    const catColours = { 'IAL': '#c0392b', 'IL': '#e67e22', 'AL': '#28a745' };

    // Draw gauge faults (above track)
    const allGF = gaugeFaults.concat(manualGaugeFaults);
    allGF.forEach((f, i) => {
        if (isDismissed('gauge', i)) return;
        const c = classifyGaugeFault(f.worstGauge, lineSpeed, trackCat);
        if (!c) return;
        const x1 = posToX(f.startMiles, f.startYards);
        const x2 = posToX(f.endMiles || f.startMiles, f.endYards || f.startYards);
        const faultW = Math.max(x2 - x1, 3);
        ctx.fillStyle = catColours[c.category] || '#999';
        ctx.fillRect(x1, trackY - 14, faultW, 12);
    });

    // Draw twist faults (below track)
    const allTF = twistFaults.concat(manualTwistFaults);
    allTF.forEach((f, i) => {
        if (isDismissed('twist', i)) return;
        const isLt400 = f.manual ? f.curveRadiusLessThan400 : twistFaultRadiusSettings[i];
        const c = classifyTwistFault(f.maxAbsTwist, lineSpeed, isLt400);
        if (!c) return;
        const x1 = posToX(f.startMiles, f.startYards);
        const x2 = posToX(f.endMiles || f.startMiles, f.endYards || f.startYards);
        const faultW = Math.max(x2 - x1, 3);
        ctx.fillStyle = catColours[c.category] || '#999';
        ctx.fillRect(x1, trackY + trackH + 2, faultW, 12);
    });

    // Labels
    ctx.fillStyle = '#333';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Gauge', padL - 6, trackY - 5);
    ctx.fillText('Twist', padL - 6, trackY + trackH + 12);

    // Legend
    ctx.textAlign = 'left';
    let lx = padL;
    const ly = h - 12;
    [['IAL', '#c0392b'], ['IL', '#e67e22'], ['AL', '#28a745']].forEach(([label, col]) => {
        ctx.fillStyle = col;
        ctx.fillRect(lx, ly - 8, 12, 10);
        ctx.fillStyle = '#333';
        ctx.font = '10px sans-serif';
        ctx.fillText(label, lx + 15, ly);
        lx += 50;
    });
    // Previous run faults if loaded
    if (previousRunData) {
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(lx, ly - 8, 12, 10);
        ctx.strokeStyle = '#333';
        ctx.setLineDash([2,2]);
        ctx.strokeRect(lx, ly - 8, 12, 10);
        ctx.setLineDash([]);
        ctx.fillStyle = '#333';
        ctx.fillText('Previous', lx + 15, ly);
        lx += 65;

        // Draw previous run faults as dashed outlines
        (previousRunData.gaugeFaults || []).forEach(f => {
            if (f.startMiles === undefined) return;
            const x1 = posToX(f.startMiles, f.startYards);
            const x2 = posToX(f.endMiles || f.startMiles, f.endYards || f.startYards);
            const faultW = Math.max(x2 - x1, 3);
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([3, 2]);
            ctx.strokeRect(x1, trackY - 14, faultW, 12);
            ctx.setLineDash([]);
        });
        (previousRunData.twistFaults || []).forEach(f => {
            if (f.startMiles === undefined) return;
            const x1 = posToX(f.startMiles, f.startYards);
            const x2 = posToX(f.endMiles || f.startMiles, f.endYards || f.startYards);
            const faultW = Math.max(x2 - x1, 3);
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([3, 2]);
            ctx.strokeRect(x1, trackY + trackH + 2, faultW, 12);
            ctx.setLineDash([]);
        });
    }
}

// ---- Previous Run PDF Comparison ----
let previousRunData = null; // {gaugeFaults:[], twistFaults:[], metadata:{}, lineSpeed, trackCat}

function loadPreviousRunPDF(inputEl) {
    const file = inputEl.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async function(e) {
        try {
            const typedArray = new Uint8Array(e.target.result);
            const pdf = await pdfjsLib.getDocument(typedArray).promise;

            // Try to read embedded JSON from PDF metadata first
            const pdfMeta = await pdf.getMetadata();
            let embedded = null;
            // Check keywords field for embedded data
            if (pdfMeta && pdfMeta.info && pdfMeta.info.Keywords) {
                const kw = pdfMeta.info.Keywords;
                const prefix = 'AmberTrolleyData:';
                if (kw.startsWith(prefix)) {
                    try {
                        embedded = JSON.parse(kw.substring(prefix.length));
                    } catch(ex) { /* fall through to text parsing */ }
                }
            }

            if (embedded) {
                previousRunData = embedded;
            } else {
                // Fallback: parse text from PDF pages
                previousRunData = await parsePreviousRunFromText(pdf);
            }

            previousRunData.filename = file.name;
            updateComparison();
            buildSchematic();
        } catch(err) {
            alert('Error reading previous PDF: ' + err.message);
            console.error(err);
        }
    };
    reader.readAsArrayBuffer(file);
}

async function parsePreviousRunFromText(pdf) {
    const result = { gaugeFaults: [], twistFaults: [], metadata: {}, lineSpeed: 0, trackCat: '' };
    let allText = '';

    for (let p = 1; p <= pdf.numPages; p++) {
        const page = await pdf.getPage(p);
        const content = await page.getTextContent();
        const pageText = content.items.map(item => item.str).join(' ');
        allText += pageText + '\n';
    }

    // Extract line speed
    const speedMatch = allText.match(/Line Speed:\s*(\d+)/);
    if (speedMatch) result.lineSpeed = parseInt(speedMatch[1]);

    // Extract track category
    const catMatch = allText.match(/Track Cat:\s*(\w+)/);
    if (catMatch) result.trackCat = catMatch[1];

    // Extract route/track
    const routeMatch = allText.match(/Route:\s*(\S+)/);
    if (routeMatch) result.metadata['Route ID'] = routeMatch[1];

    // Parse gauge fault rows (look for patterns like "21mi 1160.0yds")
    const locationPattern = /(\d+)mi\s+([\d.]+)yds/g;
    const gaugeFaultPattern = /(\d+)\s+(?:\*\s*)?(\d+mi\s+[\d.]+yds)\s+([\d]+mi\s+[\d.]+yds)\s+([\d.]+)\s+([\d.]+)\s+([+-][\d.]+)/g;

    // Simplified: extract fault summary from the table data
    // We look for patterns in the gauge faults page
    const gaugeSection = allText.split(/Twist Faults/)[0] || allText;
    const twistSection = allText.split(/Twist Faults/)[1] || '';

    // Parse location pairs from gauge section
    const gaugeLocs = [];
    let locMatch;
    const gLocRe = /(\d+)mi\s+([\d.]+)yds/g;
    const gaugePart = gaugeSection.split(/Gauge Faults/)[1] || gaugeSection;
    while ((locMatch = gLocRe.exec(gaugePart)) !== null) {
        gaugeLocs.push({ miles: parseInt(locMatch[1]), yards: parseFloat(locMatch[2]) });
    }
    // Pair up as start/end (every 2 locations)
    for (let i = 0; i + 1 < gaugeLocs.length; i += 2) {
        result.gaugeFaults.push({
            startMiles: gaugeLocs[i].miles, startYards: gaugeLocs[i].yards,
            startLocation: gaugeLocs[i].miles + 'mi ' + gaugeLocs[i].yards.toFixed(1) + 'yds',
            endMiles: gaugeLocs[i+1].miles, endYards: gaugeLocs[i+1].yards,
            endLocation: gaugeLocs[i+1].miles + 'mi ' + gaugeLocs[i+1].yards.toFixed(1) + 'yds'
        });
    }

    // Parse twist section
    const twistLocs = [];
    const tLocRe = /(\d+)mi\s+([\d.]+)yds/g;
    while ((locMatch = tLocRe.exec(twistSection)) !== null) {
        twistLocs.push({ miles: parseInt(locMatch[1]), yards: parseFloat(locMatch[2]) });
    }
    for (let i = 0; i + 1 < twistLocs.length; i += 2) {
        result.twistFaults.push({
            startMiles: twistLocs[i].miles, startYards: twistLocs[i].yards,
            startLocation: twistLocs[i].miles + 'mi ' + twistLocs[i].yards.toFixed(1) + 'yds',
            endMiles: twistLocs[i+1].miles, endYards: twistLocs[i+1].yards,
            endLocation: twistLocs[i+1].miles + 'mi ' + twistLocs[i+1].yards.toFixed(1) + 'yds'
        });
    }

    return result;
}

function clearPreviousRun() {
    previousRunData = null;
    document.getElementById('prevRunInput').value = '';
    document.getElementById('comparisonResults').style.display = 'none';
    document.getElementById('comparisonEmpty').style.display = 'block';
    buildSchematic();
}

function updateComparison() {
    if (!previousRunData) return;

    const resultsDiv = document.getElementById('comparisonResults');
    const emptyDiv = document.getElementById('comparisonEmpty');
    emptyDiv.style.display = 'none';
    resultsDiv.style.display = 'block';

    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const trackCat = getTrackCat();
    const allGF = gaugeFaults.concat(manualGaugeFaults);
    const allTF = twistFaults.concat(manualTwistFaults);
    const prevGF = previousRunData.gaugeFaults || [];
    const prevTF = previousRunData.twistFaults || [];

    // Compare faults by location overlap
    function locOverlaps(a, b) {
        const aStart = a.startMiles * 1760 + a.startYards;
        const aEnd = (a.endMiles || a.startMiles) * 1760 + (a.endYards || a.startYards);
        const bStart = b.startMiles * 1760 + b.startYards;
        const bEnd = (b.endMiles || b.startMiles) * 1760 + (b.endYards || b.startYards);
        return aStart <= bEnd + 5 && bStart <= aEnd + 5; // 5yd tolerance
    }

    // Categorise gauge faults
    const gaugePersists = [], gaugeNew = [], gaugeResolved = [];
    const prevGMatched = new Set();
    allGF.forEach((f, i) => {
        if (isDismissed('gauge', i)) return;
        const match = prevGF.findIndex((pf, pi) => !prevGMatched.has(pi) && locOverlaps(f, pf));
        if (match >= 0) {
            prevGMatched.add(match);
            gaugePersists.push({ current: f, previous: prevGF[match] });
        } else {
            gaugeNew.push(f);
        }
    });
    prevGF.forEach((pf, i) => {
        if (!prevGMatched.has(i)) gaugeResolved.push(pf);
    });

    // Categorise twist faults
    const twistPersists = [], twistNew = [], twistResolved = [];
    const prevTMatched = new Set();
    allTF.forEach((f, i) => {
        if (isDismissed('twist', i)) return;
        const match = prevTF.findIndex((pf, pi) => !prevTMatched.has(pi) && locOverlaps(f, pf));
        if (match >= 0) {
            prevTMatched.add(match);
            twistPersists.push({ current: f, previous: prevTF[match] });
        } else {
            twistNew.push(f);
        }
    });
    prevTF.forEach((pf, i) => {
        if (!prevTMatched.has(i)) twistResolved.push(pf);
    });

    let html = `
        <div class="prev-run-info">
            Previous run: <strong>${previousRunData.filename || 'Loaded PDF'}</strong>
            ${previousRunData.metadata['Route ID'] ? ' | Route: ' + previousRunData.metadata['Route ID'] : ''}
            ${previousRunData.lineSpeed ? ' | Speed: ' + previousRunData.lineSpeed + ' mph' : ''}
            <button class="btn-clear-comparison" onclick="clearPreviousRun()">Remove</button>
        </div>
        <div class="comp-legend">
            <span class="comp-new">New fault</span>
            <span class="comp-resolved">Resolved</span>
            <span class="comp-persists">Persisting</span>
        </div>
        <h4 style="font-size:13px;color:#1a1a2e;margin:12px 0 6px;">Gauge Faults Comparison</h4>
    `;

    if (gaugeNew.length + gaugeResolved.length + gaugePersists.length === 0) {
        html += '<p style="color:#888;font-size:12px;">No gauge faults in either run.</p>';
    } else {
        html += '<table class="comparison-table"><thead><tr><th>Status</th><th>Location</th><th>Details</th></tr></thead><tbody>';
        gaugeNew.forEach(f => {
            const c = classifyGaugeFault(f.worstGauge, lineSpeed, trackCat);
            html += `<tr class="comp-new"><td>NEW</td><td>${f.startLocation} - ${f.endLocation}</td><td>${f.worstGauge.toFixed(1)}mm ${c ? '(' + c.category + ')' : ''}</td></tr>`;
        });
        gaugePersists.forEach(p => {
            const c = classifyGaugeFault(p.current.worstGauge, lineSpeed, trackCat);
            html += `<tr class="comp-persists"><td>PERSISTS</td><td>${p.current.startLocation} - ${p.current.endLocation}</td><td>${p.current.worstGauge.toFixed(1)}mm ${c ? '(' + c.category + ')' : ''}</td></tr>`;
        });
        gaugeResolved.forEach(f => {
            html += `<tr class="comp-resolved"><td>RESOLVED</td><td>${f.startLocation} - ${f.endLocation}</td><td>Not present in current run</td></tr>`;
        });
        html += '</tbody></table>';
    }

    html += '<h4 style="font-size:13px;color:#1a1a2e;margin:16px 0 6px;">Twist Faults Comparison</h4>';

    if (twistNew.length + twistResolved.length + twistPersists.length === 0) {
        html += '<p style="color:#888;font-size:12px;">No twist faults in either run.</p>';
    } else {
        html += '<table class="comparison-table"><thead><tr><th>Status</th><th>Location</th><th>Details</th></tr></thead><tbody>';
        twistNew.forEach(f => {
            const isLt = f.manual ? f.curveRadiusLessThan400 : false;
            const c = classifyTwistFault(f.maxAbsTwist, lineSpeed, isLt);
            html += `<tr class="comp-new"><td>NEW</td><td>${f.startLocation} - ${f.endLocation}</td><td>${f.maxAbsTwist.toFixed(1)}mm ${c ? '(' + c.category + ')' : ''}</td></tr>`;
        });
        twistPersists.forEach(p => {
            const isLt = p.current.manual ? p.current.curveRadiusLessThan400 : false;
            const c = classifyTwistFault(p.current.maxAbsTwist, lineSpeed, isLt);
            html += `<tr class="comp-persists"><td>PERSISTS</td><td>${p.current.startLocation} - ${p.current.endLocation}</td><td>${p.current.maxAbsTwist.toFixed(1)}mm ${c ? '(' + c.category + ')' : ''}</td></tr>`;
        });
        twistResolved.forEach(f => {
            html += `<tr class="comp-resolved"><td>RESOLVED</td><td>${f.startLocation} - ${f.endLocation}</td><td>Not present in current run</td></tr>`;
        });
        html += '</tbody></table>';
    }

    html += `<p style="margin-top:10px;font-size:11px;color:#888;">
        Summary: ${gaugeNew.length + twistNew.length} new, ${gaugePersists.length + twistPersists.length} persisting, ${gaugeResolved.length + twistResolved.length} resolved
    </p>`;

    resultsDiv.innerHTML = html;
}

// ---- Export Excel ----
function exportExcel() {
    const wb = XLSX.utils.book_new();
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;

    // Sheet 1: Survey Info
    const runName = document.getElementById('runNameInput').value;
    const inspector = document.getElementById('inspectorInput').value;
    const metaArr = [
        { Field: 'Run Name', Value: runName },
        { Field: 'Inspector', Value: inspector },
        { Field: 'Line Speed (mph)', Value: lineSpeed || 'Not set' },
        { Field: 'Track Category', Value: getTrackCat() || 'Not set' },
        ...Object.entries(metadata).map(([k, v]) => ({ Field: k, Value: v }))
    ];
    const ws1 = XLSX.utils.json_to_sheet(metaArr);
    XLSX.utils.book_append_sheet(wb, ws1, 'Survey Info');

    // Sheet 2: All Data
    const allData = parsedData.map(r => ({
        Miles: r.miles,
        Yards: r.yards,
        'Gauge (mm)': r.gauge,
        'X-Level (mm)': r.xlevel,
        'Twist 1 (mm)': r.twist1,
        Zone: r.zone
    }));
    const ws2 = XLSX.utils.json_to_sheet(allData);
    XLSX.utils.book_append_sheet(wb, ws2, 'All Data');

    // Sheet 3: Gauge Faults (auto + manual)
    const allGaugeFaultsExport = gaugeFaults.concat(manualGaugeFaults);
    const gaugeFaultNos = document.querySelectorAll('.fault-no-input[data-type="gauge"]');
    const gaugeRepeatCbs = document.querySelectorAll('.repeat-fault-cb[data-type="gauge"]');
    const gfData = allGaugeFaultsExport.map((f, i) => {
        const c = classifyGaugeFault(f.worstGauge, lineSpeed, getTrackCat());
        const dismissed = isDismissed('gauge', i);
        const row = {
            '#': i + 1,
            'Fault No.': gaugeFaultNos[i] ? gaugeFaultNos[i].value : '',
            'Start Location': f.startLocation,
            'End Location': f.endLocation,
            'Length (yds)': f.length,
            'Worst Gauge (mm)': f.worstGauge.toFixed(1),
            'Deviation (mm)': f.deviation,
            'Fault Type': c ? c.type : (f.direction === 'wide' ? 'Wide Gauge' : 'Tight Gauge'),
            'Category': c ? c.category : '',
            'Required Action': c ? c.action : '',
            'Repeat Fault': gaugeRepeatCbs[i] && gaugeRepeatCbs[i].checked ? 'Yes' : 'No',
            'Dismissed': dismissed ? 'Yes' : 'No',
            'Dismissed By': dismissed ? dismissed.inspector : '',
            'Dismissed Date': dismissed ? dismissed.displayTime : '',
            'Dismissal Reason': dismissed ? dismissed.comment : ''
        };
        return row;
    });
    const ws3 = XLSX.utils.json_to_sheet(gfData.length ? gfData : [{ Info: 'No gauge faults' }]);
    XLSX.utils.book_append_sheet(wb, ws3, 'Gauge Faults');

    // Sheet 4: Twist Faults (auto + manual)
    const allTwistFaultsExport = twistFaults.concat(manualTwistFaults);
    const twistFaultNos = document.querySelectorAll('.fault-no-input[data-type="twist"]');
    const twistRepeatCbs = document.querySelectorAll('.repeat-fault-cb[data-type="twist"]');
    const tfData = allTwistFaultsExport.map((f, i) => {
        const isManual = f.manual;
        const radius = isManual ? f.curveRadiusLessThan400 : twistFaultRadiusSettings[i];
        const c = classifyTwistFault(f.maxAbsTwist, lineSpeed, radius);
        const dismissed = isDismissed('twist', i);
        return {
            '#': i + 1,
            'Fault No.': twistFaultNos[i] ? twistFaultNos[i].value : '',
            'Start Location': f.startLocation,
            'End Location': f.endLocation,
            'Length (yds)': f.length,
            'Max |Twist| (mm)': f.maxAbsTwist.toFixed(1),
            'Worst Value (mm)': f.worstValue.toFixed(1),
            'Curve Radius': radius ? '< 400m' : '>= 400m',
            'Category': c ? c.category : '',
            'Required Action': c ? c.action : '',
            'Repeat Fault': twistRepeatCbs[i] && twistRepeatCbs[i].checked ? 'Yes' : 'No',
            'Dismissed': dismissed ? 'Yes' : 'No',
            'Dismissed By': dismissed ? dismissed.inspector : '',
            'Dismissed Date': dismissed ? dismissed.displayTime : '',
            'Dismissal Reason': dismissed ? dismissed.comment : ''
        };
    });
    const ws4 = XLSX.utils.json_to_sheet(tfData.length ? tfData : [{ Info: 'No twist faults' }]);
    XLSX.utils.book_append_sheet(wb, ws4, 'Twist Faults');

    const filename = 'TrackInspection_' + (metadata['Route ID'] || 'Report') + '_' +
        (metadata['Track ID'] || '') + '.xlsx';
    XLSX.writeFile(wb, filename);
}

// ---- Export PDF ----
function exportPDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('landscape', 'mm', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;

    // Page 1: Survey info + summary
    const pdfRunName = document.getElementById('runNameInput').value;
    const pdfInspector = document.getElementById('inspectorInput').value;

    doc.setFontSize(18);
    doc.setTextColor(26, 26, 46);
    doc.text('Track Inspection Report', 14, 20);
    doc.setFontSize(10);
    doc.setTextColor(100);
    const route = metadata['Route ID'] || '';
    const track = metadata['Track ID'] || '';
    const pdfTrackCat = getTrackCat();
    doc.text(`Run Name: ${pdfRunName}  |  Inspector: ${pdfInspector}  |  Line Speed: ${lineSpeed || 'N/A'} mph  |  Track Cat: ${pdfTrackCat || 'N/A'}`, 14, 28);
    doc.text(`Route: ${route}  |  Track: ${track}  |  ${metadata['Job Reference'] || ''}`, 14, 34);
    doc.text(`${metadata['Start Location'] || ''} to ${metadata['End Location'] || ''}`, 14, 40);
    doc.text(`Date: ${metadata['Start Time'] || ''}`, 14, 46);

    // Summary table
    doc.autoTable({
        startY: 54,
        head: [['Total Points', 'Gauge Faults', 'Twist Faults', 'Min Gauge', 'Max Gauge', 'Max |Twist|']],
        body: [[
            parsedData.length,
            gaugeFaults.length + manualGaugeFaults.length,
            twistFaults.length + manualTwistFaults.length,
            Math.min(...parsedData.map(r => r.gauge)).toFixed(1) + ' mm',
            Math.max(...parsedData.map(r => r.gauge)).toFixed(1) + ' mm',
            (parsedData.filter(r => r.twist1 !== null).length > 0
                ? Math.max(...parsedData.filter(r => r.twist1 !== null).map(r => Math.abs(r.twist1))).toFixed(1) + ' mm'
                : 'N/A')
        ]],
        theme: 'grid',
        headStyles: { fillColor: [26, 26, 46] },
        styles: { fontSize: 9 }
    });

    // Add chart images
    const gaugeCanvases = Array.from(document.querySelectorAll('#gaugeCharts canvas'));
    const twistCanvases = Array.from(document.querySelectorAll('#twistCharts canvas'));
    const chartW = pageWidth - 28;
    const chartH = 70;
    const pageHeight = doc.internal.pageSize.getHeight();
    let chartY = doc.lastAutoTable.finalY + 8;

    const maxSegments = Math.max(gaugeCanvases.length, twistCanvases.length);
    for (let i = 0; i < maxSegments; i++) {
        const gaugeCanvas = gaugeCanvases[i];
        const twistCanvas = twistCanvases[i];
        if (!gaugeCanvas || !twistCanvas) continue;
        const blockHeight = chartH * 2 + 10;
        if (chartY + blockHeight > pageHeight - 10) {
            doc.addPage();
            chartY = 20;
        }
        doc.addImage(gaugeCanvas.toDataURL('image/png'), 'PNG', 14, chartY, chartW, chartH);
        doc.addImage(twistCanvas.toDataURL('image/png'), 'PNG', 14, chartY + chartH + 6, chartW, chartH);
        chartY += blockHeight;
    }

    // Page 2: Gauge Faults
    doc.addPage();
    doc.setFontSize(14);
    doc.setTextColor(26, 26, 46);
    doc.text('Gauge Faults (Table 5 Limits) - Line Speed: ' + (lineSpeed || 'N/A') + ' mph - Track Cat: ' + (getTrackCat() || 'N/A'), 14, 20);

    const allGaugeFaultsPdf = gaugeFaults.concat(manualGaugeFaults);
    const pdfGaugeFaultNos = document.querySelectorAll('.fault-no-input[data-type="gauge"]');
    const pdfGaugeRepeatCbs = document.querySelectorAll('.repeat-fault-cb[data-type="gauge"]');
    if (allGaugeFaultsPdf.length === 0) {
        doc.setFontSize(11);
        doc.setTextColor(100);
        doc.text('No gauge faults detected.', 14, 32);
    } else {
        const gaugeTableBody = allGaugeFaultsPdf.map((f, i) => {
            const c = classifyGaugeFault(f.worstGauge, lineSpeed, getTrackCat());
            const dismissed = isDismissed('gauge', i);
            const actionCol = dismissed
                ? (c ? c.action : '') + '\n[DISMISSED ' + dismissed.displayTime + ' by ' + dismissed.inspector + ': ' + dismissed.comment + ']'
                : (c ? c.action : '');
            return [
                (f.manual ? '* ' : '') + (i + 1),
                pdfGaugeFaultNos[i] ? pdfGaugeFaultNos[i].value : '',
                f.startLocation, f.endLocation, f.length,
                f.worstGauge.toFixed(1), f.deviation,
                c ? c.type : (f.direction === 'wide' ? 'Wide' : 'Tight'),
                c ? c.category : '',
                actionCol,
                pdfGaugeRepeatCbs[i] && pdfGaugeRepeatCbs[i].checked ? 'Yes' : 'No'
            ];
        });
        // Build map of dismissed row indices for styling
        const gaugeDismissedRows = {};
        allGaugeFaultsPdf.forEach((f, i) => { if (isDismissed('gauge', i)) gaugeDismissedRows[i] = true; });

        doc.autoTable({
            startY: 28,
            head: [['#', 'Fault No.', 'Start', 'End', 'Length', 'Worst Gauge', 'Deviation', 'Type', 'Cat.', 'Required Action', 'Repeat']],
            body: gaugeTableBody,
            theme: 'striped',
            headStyles: { fillColor: [26, 26, 46] },
            styles: { fontSize: 7 },
            columnStyles: { 9: { cellWidth: 50 } },
            didParseCell: function(data) {
                if (data.section === 'body' && gaugeDismissedRows[data.row.index]) {
                    data.cell.styles.textColor = [160, 160, 160];
                    data.cell.styles.fontStyle = 'italic';
                }
            }
        });
    }

    // Gauge sign-off
    const gSignY = allGaugeFaultsPdf.length > 0 ? doc.lastAutoTable.finalY + 12 : 44;
    doc.setFontSize(12);
    doc.setTextColor(26, 26, 46);
    doc.text('Section Manager Sign-Off', 14, gSignY);
    doc.setFontSize(9);
    doc.setTextColor(80);
    doc.text(`Name: ${document.getElementById('gaugeSignOffName').value}`, 14, gSignY + 8);
    doc.text(`Date: ${document.getElementById('gaugeSignOffDate').value}`, 14, gSignY + 14);
    doc.text(`Signature: ${document.getElementById('gaugeSignOffSig').value}`, 120, gSignY + 8);
    doc.text(`Comments: ${document.getElementById('gaugeSignOffComments').value}`, 120, gSignY + 14);

    // Page 3: Twist Faults
    doc.addPage();
    doc.setFontSize(14);
    doc.setTextColor(26, 26, 46);
    doc.text('Twist Faults - 3m Base (Table 3 Limits) - Line Speed: ' + (lineSpeed || 'N/A') + ' mph', 14, 20);

    const allTwistFaultsPdf = twistFaults.concat(manualTwistFaults);
    const pdfTwistFaultNos = document.querySelectorAll('.fault-no-input[data-type="twist"]');
    const pdfTwistRepeatCbs = document.querySelectorAll('.repeat-fault-cb[data-type="twist"]');
    if (allTwistFaultsPdf.length === 0) {
        doc.setFontSize(11);
        doc.setTextColor(100);
        doc.text('No twist faults detected.', 14, 32);
    } else {
        const twistTableBody = allTwistFaultsPdf.map((f, i) => {
            const isManual = f.manual;
            const radius = isManual ? f.curveRadiusLessThan400 : twistFaultRadiusSettings[i];
            const c = classifyTwistFault(f.maxAbsTwist, lineSpeed, radius);
            const dismissed = isDismissed('twist', i);
            const actionCol = dismissed
                ? (c ? c.action : '') + '\n[DISMISSED ' + dismissed.displayTime + ' by ' + dismissed.inspector + ': ' + dismissed.comment + ']'
                : (c ? c.action : '');
            return [
                (f.manual ? '* ' : '') + (i + 1),
                pdfTwistFaultNos[i] ? pdfTwistFaultNos[i].value : '',
                f.startLocation, f.endLocation, f.length,
                f.maxAbsTwist.toFixed(1), f.worstValue.toFixed(1),
                radius ? '< 400m' : '>= 400m',
                c ? c.category : '',
                actionCol,
                pdfTwistRepeatCbs[i] && pdfTwistRepeatCbs[i].checked ? 'Yes' : 'No'
            ];
        });
        const twistDismissedRows = {};
        allTwistFaultsPdf.forEach((f, i) => { if (isDismissed('twist', i)) twistDismissedRows[i] = true; });

        doc.autoTable({
            startY: 28,
            head: [['#', 'Fault No.', 'Start', 'End', 'Length', 'Max |Twist|', 'Worst', 'Curve R', 'Cat.', 'Required Action', 'Repeat']],
            body: twistTableBody,
            theme: 'striped',
            headStyles: { fillColor: [26, 26, 46] },
            styles: { fontSize: 7 },
            columnStyles: { 9: { cellWidth: 50 } },
            didParseCell: function(data) {
                if (data.section === 'body' && twistDismissedRows[data.row.index]) {
                    data.cell.styles.textColor = [160, 160, 160];
                    data.cell.styles.fontStyle = 'italic';
                }
            }
        });
    }

    // Twist sign-off
    const tSignY = allTwistFaultsPdf.length > 0 ? doc.lastAutoTable.finalY + 12 : 44;
    doc.setFontSize(12);
    doc.setTextColor(26, 26, 46);
    doc.text('Section Manager Sign-Off', 14, tSignY);
    doc.setFontSize(9);
    doc.setTextColor(80);
    doc.text(`Name: ${document.getElementById('twistSignOffName').value}`, 14, tSignY + 8);
    doc.text(`Date: ${document.getElementById('twistSignOffDate').value}`, 14, tSignY + 14);
    doc.text(`Signature: ${document.getElementById('twistSignOffSig').value}`, 120, tSignY + 8);
    doc.text(`Comments: ${document.getElementById('twistSignOffComments').value}`, 120, tSignY + 14);

    // Embed fault data as JSON in PDF properties for run-on-run comparison
    const allGFExportPdf = gaugeFaults.concat(manualGaugeFaults);
    const allTFExportPdf = twistFaults.concat(manualTwistFaults);
    const embedData = {
        gaugeFaults: allGFExportPdf.map(f => ({
            startMiles: f.startMiles, startYards: f.startYards,
            endMiles: f.endMiles, endYards: f.endYards,
            startLocation: f.startLocation, endLocation: f.endLocation,
            worstGauge: f.worstGauge, deviation: f.deviation,
            direction: f.direction, length: f.length
        })),
        twistFaults: allTFExportPdf.map(f => ({
            startMiles: f.startMiles, startYards: f.startYards,
            endMiles: f.endMiles, endYards: f.endYards,
            startLocation: f.startLocation, endLocation: f.endLocation,
            maxAbsTwist: f.maxAbsTwist, worstValue: f.worstValue, length: f.length
        })),
        metadata: { 'Route ID': metadata['Route ID'] || '', 'Track ID': metadata['Track ID'] || '' },
        lineSpeed: lineSpeed,
        trackCat: getTrackCat()
    };
    doc.setProperties({
        title: 'Track Inspection Report - ' + (metadata['Route ID'] || ''),
        subject: 'Amber Trolley Track Inspection',
        creator: 'Amber Trolley Report Generator',
        keywords: 'AmberTrolleyData:' + JSON.stringify(embedData)
    });

    const filename = 'TrackInspection_' + (metadata['Route ID'] || 'Report') + '_' +
        (metadata['Track ID'] || '') + '.pdf';
    doc.save(filename);
}
</script>

</body>
</html>

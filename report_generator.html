<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amber Trolley - Track Inspection Report Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f2f5; color: #333; }

        .upload-screen {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; padding: 40px;
        }
        .upload-screen h1 { font-size: 28px; margin-bottom: 8px; color: #1a1a2e; }
        .upload-screen p { color: #666; margin-bottom: 30px; }
        .drop-zone {
            width: 500px; max-width: 90vw; height: 200px;
            border: 3px dashed #aab; border-radius: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s; background: #fff;
        }
        .drop-zone:hover, .drop-zone.dragover { border-color: #4a6cf7; background: #f0f4ff; }
        .drop-zone span { font-size: 16px; color: #666; }
        .drop-zone .icon { font-size: 48px; margin-bottom: 12px; }
        .drop-zone input { display: none; }

        .report-container { display: none; max-width: 1400px; margin: 0 auto; padding: 20px; }
        .report-container.active { display: block; }

        .toolbar {
            display: flex; gap: 10px; align-items: center; margin-bottom: 20px;
            padding: 16px 20px; background: #1a1a2e; border-radius: 10px; flex-wrap: wrap;
        }
        .toolbar h2 { color: #fff; font-size: 18px; flex: 1; }
        .toolbar button {
            padding: 8px 18px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 14px; font-weight: 600; transition: all 0.2s;
        }
        .btn-excel { background: #1d6f42; color: #fff; }
        .btn-excel:hover { background: #175c36; }
        .btn-pdf { background: #c0392b; color: #fff; }
        .btn-pdf:hover { background: #a93226; }
        .btn-back { background: #555; color: #fff; }
        .btn-back:hover { background: #444; }

        .tabs {
            display: flex; gap: 4px; margin-bottom: 20px; background: #ddd; padding: 4px;
            border-radius: 8px;
        }
        .tab {
            flex: 1; padding: 12px 16px; text-align: center; border: none; background: none;
            cursor: pointer; border-radius: 6px; font-size: 14px; font-weight: 600;
            color: #666; transition: all 0.2s;
        }
        .tab.active { background: #fff; color: #1a1a2e; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

        .page { display: none; }
        .page.active { display: block; }

        .card {
            background: #fff; border-radius: 10px; padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); margin-bottom: 20px;
        }
        .card h3 { font-size: 16px; color: #1a1a2e; margin-bottom: 16px; border-bottom: 2px solid #eee; padding-bottom: 8px; }

        .meta-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 8px 24px;
        }
        .meta-item { display: flex; justify-content: space-between; padding: 4px 0; font-size: 13px; }
        .meta-item .label { color: #888; }
        .meta-item .value { font-weight: 600; color: #333; }

        .chart-row { display: grid; grid-template-columns: 1fr; gap: 20px; }
        .chart-wrapper { position: relative; height: 300px; }
        canvas { width: 100% !important; }

        table {
            width: 100%; border-collapse: collapse; font-size: 12px;
        }
        thead th {
            background: #1a1a2e; color: #fff; padding: 8px 10px; text-align: left;
            font-weight: 600; position: sticky; top: 0; white-space: nowrap;
        }
        tbody td { padding: 6px 10px; border-bottom: 1px solid #eee; }
        tbody tr:hover { background: #f8f9ff; }

        .summary-stats {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px; margin-bottom: 20px;
        }
        .stat-card {
            background: #fff; border-radius: 10px; padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); text-align: center;
        }
        .stat-card .number { font-size: 32px; font-weight: 700; color: #1a1a2e; }
        .stat-card .label { font-size: 13px; color: #888; margin-top: 4px; }
        .stat-card.warning .number { color: #e67e22; }
        .stat-card.danger .number { color: #c0392b; }

        .cat-ial { background: #f8d7da; border-left: 4px solid #c0392b; }
        .cat-ial-block { background: #f5c6cb; border-left: 4px solid #721c24; }
        .cat-il { background: #fff3cd; border-left: 4px solid #e67e22; }
        .cat-al { background: #d4edda; border-left: 4px solid #28a745; }

        .badge {
            display: inline-block; padding: 2px 8px; border-radius: 4px;
            font-size: 11px; font-weight: 700; color: #fff; white-space: nowrap;
        }
        .badge-ial { background: #c0392b; }
        .badge-il { background: #e67e22; }
        .badge-al { background: #28a745; }

        .run-info-bar {
            display: flex; gap: 20px; align-items: center; margin-bottom: 20px;
            padding: 16px 20px; background: #fff; border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); flex-wrap: wrap;
        }
        .run-info-bar label { font-size: 13px; color: #888; font-weight: 600; }
        .run-info-bar input, .run-info-bar select {
            padding: 6px 12px; border: 1px solid #ccc; border-radius: 6px;
            font-size: 14px; font-family: inherit; min-width: 120px;
        }
        .run-info-bar input:focus, .run-info-bar select:focus { outline: none; border-color: #4a6cf7; box-shadow: 0 0 0 2px rgba(74,108,247,0.15); }
        .run-info-group { display: flex; flex-direction: column; gap: 4px; }

        .speed-warning {
            display: none; padding: 10px 16px; background: #fff3cd; border: 1px solid #ffc107;
            border-radius: 8px; margin-bottom: 16px; font-size: 13px; color: #856404;
        }
        .speed-warning.visible { display: block; }

        .radius-select {
            padding: 3px 6px; border: 1px solid #ccc; border-radius: 4px;
            font-size: 11px; background: #fff; cursor: pointer;
        }

        .sign-off-section {
            margin-top: 20px; padding: 20px; background: #fafafa; border: 2px solid #ddd;
            border-radius: 10px;
        }
        .sign-off-section h4 { font-size: 14px; color: #1a1a2e; margin-bottom: 16px; border-bottom: 2px solid #ccc; padding-bottom: 8px; }
        .sign-off-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 16px 32px;
        }
        .sign-off-field { display: flex; flex-direction: column; gap: 4px; }
        .sign-off-field label { font-size: 12px; color: #888; font-weight: 600; text-transform: uppercase; }
        .sign-off-field input {
            padding: 8px 12px; border: none; border-bottom: 2px solid #999;
            background: transparent; font-size: 14px; font-family: inherit;
        }
        .sign-off-field input:focus { outline: none; border-bottom-color: #4a6cf7; }

        .note-box {
            margin-top: 12px; padding: 10px 14px; background: #f8f9fa; border-left: 3px solid #6c757d;
            font-size: 12px; color: #555; line-height: 1.5;
        }

        @media print {
            .toolbar, .tabs { display: none; }
            .page { display: block !important; page-break-after: always; }
            .card { box-shadow: none; border: 1px solid #ddd; }
        }
    </style>
</head>
<body>

<div class="upload-screen" id="uploadScreen">
    <h1>Amber Trolley Report Generator</h1>
    <p>Upload a raw data HTML file from the Amber trolley to generate an inspection report</p>
    <div class="drop-zone" id="dropZone">
        <div class="icon">&#128196;</div>
        <span>Drop HTML file here or click to browse</span>
        <input type="file" id="fileInput" accept=".html,.htm,.txt,.csv">
    </div>
    <div style="margin-top: 30px; max-width: 560px;">
        <p style="font-size: 13px; color: #999; text-align: center;">
            Classifies twist and gauge faults against Table 3 &amp; Table 5 limits
            (IAL / IL / AL) with speed-dependent thresholds and remedial actions.
            Export as Excel or PDF.
        </p>
    </div>
</div>

<div class="report-container" id="reportContainer">
    <div class="toolbar">
        <h2 id="reportTitle">Track Inspection Report</h2>
        <button class="btn-back" onclick="goBack()">Load New File</button>
        <button class="btn-excel" onclick="exportExcel()">Export Excel</button>
        <button class="btn-pdf" onclick="exportPDF()">Export PDF</button>
    </div>

    <div class="run-info-bar">
        <div class="run-info-group">
            <label>Run Name</label>
            <input type="text" id="runNameInput" placeholder="Enter run name...">
        </div>
        <div class="run-info-group">
            <label>Inspector</label>
            <input type="text" id="inspectorInput" placeholder="Enter inspector name...">
        </div>
        <div class="run-info-group">
            <label>Line Speed (mph)</label>
            <input type="number" id="lineSpeedInput" placeholder="e.g. 75" min="5" max="125" style="width:100px;">
        </div>
    </div>

    <div class="speed-warning" id="speedWarning">
        Please enter a Line Speed (5-125 mph) above to classify faults against the correct thresholds.
    </div>

    <div class="tabs">
        <button class="tab active" data-page="overview">Overview &amp; Graphs</button>
        <button class="tab" data-page="gaugeFaults">Gauge Faults</button>
        <button class="tab" data-page="twistFaults">Twist Faults</button>
    </div>

    <!-- Page 1: Overview & Graphs -->
    <div class="page active" id="page-overview">
        <div class="card">
            <h3>Survey Information</h3>
            <div class="meta-grid" id="metaGrid"></div>
        </div>

        <div class="summary-stats" id="summaryStats"></div>

        <div class="card">
            <h3>Gauge Profile (mm)</h3>
            <div class="chart-wrapper"><canvas id="gaugeChart"></canvas></div>
        </div>
        <div class="card">
            <h3>Twist over 3m (mm)</h3>
            <div class="chart-wrapper"><canvas id="twistChart"></canvas></div>
        </div>
    </div>

    <!-- Page 2: Gauge Faults -->
    <div class="page" id="page-gaugeFaults">
        <div class="card">
            <h3>Gauge Faults (Table 5 Limits)</h3>
            <p style="margin-bottom: 12px; color: #666; font-size: 13px;">
                Wide gauge and tight gauge faults classified per Table 5 thresholds for the configured line speed.
            </p>
            <div style="overflow-x: auto;">
                <table id="gaugeFaultTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Fault No.</th>
                            <th>Start Location</th>
                            <th>End Location</th>
                            <th>Length (yds)</th>
                            <th>Worst Gauge (mm)</th>
                            <th>Deviation (mm)</th>
                            <th>Fault Type</th>
                            <th>Category</th>
                            <th>Required Action</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="note-box">
                <strong>Note 1:</strong> These actions assume no significant associated faults at the same location. If other faults exist, complete the action to a shorter timescale.<br>
                <strong>Note 2:</strong> These are based upon nominal gauge for that type of track. Any design gauge widening is to be added to the lower limit for the action threshold.
            </div>
            <div class="sign-off-section">
                <h4>Section Manager Sign-Off</h4>
                <div class="sign-off-grid">
                    <div class="sign-off-field">
                        <label>Name</label>
                        <input type="text" id="gaugeSignOffName" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Date</label>
                        <input type="date" id="gaugeSignOffDate">
                    </div>
                    <div class="sign-off-field">
                        <label>Signature</label>
                        <input type="text" id="gaugeSignOffSig" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Comments</label>
                        <input type="text" id="gaugeSignOffComments" placeholder="">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Page 3: Twist Faults -->
    <div class="page" id="page-twistFaults">
        <div class="card">
            <h3>Twist Faults - 3m Base (Table 3 Limits)</h3>
            <p style="margin-bottom: 12px; color: #666; font-size: 13px;">
                Twist faults classified per Table 3 thresholds. Set the curve radius toggle per fault to adjust IL timescales.
            </p>
            <div style="overflow-x: auto;">
                <table id="twistFaultTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Fault No.</th>
                            <th>Start Location</th>
                            <th>End Location</th>
                            <th>Length (yds)</th>
                            <th>Max |Twist| (mm)</th>
                            <th>Worst Value (mm)</th>
                            <th>Curve Radius</th>
                            <th>Category</th>
                            <th>Required Action</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="note-box">
                <strong>Note 1:</strong> Where twist faults at Intervention Limit or above are adjacent to structures with tight clearances, complete the action to a shorter timescale.<br>
                <strong>Note 2:</strong> These actions assume no significant associated faults at the same location. If other faults exist, complete the action to a shorter timescale.
            </div>
            <div class="sign-off-section">
                <h4>Section Manager Sign-Off</h4>
                <div class="sign-off-grid">
                    <div class="sign-off-field">
                        <label>Name</label>
                        <input type="text" id="twistSignOffName" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Date</label>
                        <input type="date" id="twistSignOffDate">
                    </div>
                    <div class="sign-off-field">
                        <label>Signature</label>
                        <input type="text" id="twistSignOffSig" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Comments</label>
                        <input type="text" id="twistSignOffComments" placeholder="">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// ---- State ----
let parsedData = null;
let gaugeFaults = [];
let twistFaults = [];
let metadata = {};
let gaugeChartInstance = null;
let twistChartInstance = null;

// Per-fault curve radius settings (indexed by fault index)
let twistFaultRadiusSettings = []; // true = <400m, false = >=400m

// ---- Table 3: Twist Fault Limits (3m base) ----
function classifyTwistFault(absValue, lineSpeed, curveRadiusLessThan400) {
    if (!lineSpeed || lineSpeed < 5) return null;

    // IAL - Block the line: all speeds, >= 33mm
    if (absValue >= 33) {
        return { category: 'IAL', badge: 'badge-ial', rowClass: 'cat-ial-block',
            action: 'BLOCK THE LINE - Correct before opening to traffic' };
    }

    // IAL - Correct within 36 hours
    if (lineSpeed <= 75 && absValue >= 24 && absValue < 33) {
        return { category: 'IAL', badge: 'badge-ial', rowClass: 'cat-ial',
            action: 'Correct within 36 hours' };
    }
    if (lineSpeed >= 80 && absValue >= 21 && absValue < 33) {
        return { category: 'IAL', badge: 'badge-ial', rowClass: 'cat-ial',
            action: 'Correct within 36 hours' };
    }

    // IL - Curve radius < 400m (max 65mph)
    if (curveRadiusLessThan400 && lineSpeed <= 65) {
        if (absValue >= 18 && absValue < 24) {
            return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Correct within 7 days' };
        }
        if (absValue >= 15 && absValue < 18) {
            return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Correct within 10 days' };
        }
    }

    // IL - Curve radius >= 400m (or < 400m but speed > 65 falls through to these)
    if (!curveRadiusLessThan400 || lineSpeed > 65) {
        if (lineSpeed <= 75) {
            if (absValue >= 21 && absValue < 24) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 14 days' };
            }
            if (absValue >= 18 && absValue < 21) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 21 days' };
            }
            if (absValue >= 15 && absValue < 18) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 28 days' };
            }
        }
        if (lineSpeed >= 80) {
            if (absValue >= 18 && absValue < 21) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 14 days' };
            }
            if (absValue >= 15 && absValue < 18) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 21 days' };
            }
        }
    }

    // AL - All speeds: 12mm to < 15mm
    if (absValue >= 12 && absValue < 15) {
        return { category: 'AL', badge: 'badge-al', rowClass: 'cat-al',
            action: 'Monitor (Alert Limit)' };
    }

    return null;
}

// ---- Table 5: Gauge Fault Limits ----
function classifyGaugeFault(gaugeValue, lineSpeed) {
    if (!lineSpeed || lineSpeed < 5) return null;

    // --- WIDE GAUGE (gauge above nominal 1435mm) ---
    if (gaugeValue >= 1435) {

        // IAL - Block the line (Static plus dynamic movement)
        if (lineSpeed >= 105 && gaugeValue >= 1472) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial-block',
                action: 'BLOCK THE LINE - Correct before opening to traffic' };
        }
        if (lineSpeed <= 100 && gaugeValue >= 1478) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial-block',
                action: 'BLOCK THE LINE - Correct before opening to traffic' };
        }

        // IAL - Correct within 36 hours (Static plus dynamic movement)
        if (lineSpeed >= 105 && gaugeValue >= 1463 && gaugeValue < 1472) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }
        if (lineSpeed <= 100 && gaugeValue >= 1470 && gaugeValue < 1478) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }

        // IAL - Correct within 36 hours (Static Wide Gauge)
        if (lineSpeed > 25 && gaugeValue >= 1458 && gaugeValue <= 1471) {
            return { category: 'IAL', type: 'Static Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }
        if (lineSpeed <= 25 && gaugeValue >= 1460 && gaugeValue <= 1477) {
            return { category: 'IAL', type: 'Static Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }

        // IL - Wide Gauge (Static plus dynamic movement)
        if (lineSpeed >= 105 && gaugeValue >= 1458 && gaugeValue < 1463) {
            return { category: 'IL', type: 'Wide Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Track Cat 1A-3: correct within 14 days; Cat 4-6: correct within 28 days' };
        }
        if (lineSpeed <= 100 && gaugeValue >= 1460 && gaugeValue < 1470) {
            return { category: 'IL', type: 'Wide Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Track Cat 1A-3: correct within 14 days; Cat 4-6: correct within 28 days' };
        }

        // IL - Static Wide Gauge
        if (lineSpeed >= 30 && gaugeValue >= 1450 && gaugeValue < 1458) {
            return { category: 'IL', type: 'Static Wide Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Correct within 14 days' };
        }
        if (lineSpeed <= 25 && gaugeValue >= 1450 && gaugeValue < 1460) {
            return { category: 'IL', type: 'Static Wide Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Correct within 14 days' };
        }

        // AL - Wide Gauge (Static plus dynamic movement)
        if (lineSpeed >= 105 && gaugeValue >= 1450 && gaugeValue < 1458) {
            return { category: 'AL', type: 'Wide Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
        if (lineSpeed >= 30 && lineSpeed <= 100 && gaugeValue >= 1450 && gaugeValue < 1460) {
            return { category: 'AL', type: 'Wide Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
        if (lineSpeed <= 25 && gaugeValue >= 1455 && gaugeValue < 1460) {
            return { category: 'AL', type: 'Wide Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }

        // AL - Static Wide Gauge (all speeds)
        if (gaugeValue >= 1445 && gaugeValue < 1450) {
            return { category: 'AL', type: 'Static Wide Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
    }

    // --- TIGHT GAUGE (gauge below nominal) ---
    if (gaugeValue < 1435) {

        // IL - Tight Gauge (severe)
        if (lineSpeed >= 105 && gaugeValue <= 1426) {
            return { category: 'IL', type: 'Tight Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Inspect within 14 days, correct within 84 days' };
        }
        if (lineSpeed <= 100 && gaugeValue <= 1422) {
            return { category: 'IL', type: 'Tight Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Inspect within 14 days, correct within 84 days' };
        }

        // IL - Tight Gauge (review for hunting/rough rides)
        if (lineSpeed >= 105 && gaugeValue > 1426 && gaugeValue <= 1428) {
            return { category: 'IL', type: 'Tight Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Review for reports of Hunting or Rough Rides within 28 days' };
        }
        if (lineSpeed <= 100 && gaugeValue > 1422 && gaugeValue <= 1424) {
            return { category: 'IL', type: 'Tight Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Review for reports of Hunting or Rough Rides within 28 days' };
        }

        // AL - Tight Gauge
        if (lineSpeed >= 105 && gaugeValue > 1428 && gaugeValue <= 1430) {
            return { category: 'AL', type: 'Tight Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
        if (lineSpeed <= 100 && gaugeValue > 1424 && gaugeValue <= 1426) {
            return { category: 'AL', type: 'Tight Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
    }

    return null;
}

// Get the detection thresholds for gauge based on line speed
function getGaugeDetectionThresholds(lineSpeed) {
    if (!lineSpeed || lineSpeed < 5) {
        // Default broadest thresholds
        return { tightBelow: 1430, wideAbove: 1445 };
    }
    if (lineSpeed >= 105) {
        return { tightBelow: 1430, wideAbove: 1445 };
    }
    // 5 to 100mph
    return { tightBelow: 1426, wideAbove: 1445 };
}

// Get the detection threshold for twist (lowest AL = 12mm)
function getTwistDetectionThreshold() {
    return 12;
}

// ---- Upload ----
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');

dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', e => { if (e.target.files.length) handleFile(e.target.files[0]); });

function handleFile(file) {
    const reader = new FileReader();
    reader.onload = e => {
        try {
            const content = e.target.result;
            parseData(content);
            buildReport();
            document.getElementById('uploadScreen').style.display = 'none';
            document.getElementById('reportContainer').classList.add('active');
        } catch (err) {
            alert('Error parsing file: ' + err.message);
            console.error(err);
        }
    };
    reader.readAsText(file);
}

// ---- Parsing ----
function parseData(content) {
    let lines;
    if (content.includes('<table') || content.includes('<TABLE')) {
        lines = parseHTMLTable(content);
    } else {
        lines = content.split('\n').map(l => l.trim()).filter(l => l);
    }

    metadata = {};
    const dataRows = [];
    let headerFound = false;
    let columnHeaders = [];

    for (let i = 0; i < lines.length; i++) {
        const line = typeof lines[i] === 'string' ? lines[i] : lines[i].join('\t');
        const cells = typeof lines[i] === 'string'
            ? line.split('\t').map(c => c.trim())
            : lines[i].map(c => (c || '').trim());

        if (!headerFound && cells[0] === 'Miles' && cells[1] === 'Yards') {
            headerFound = true;
            columnHeaders = cells;
            continue;
        }

        if (!headerFound) {
            if (cells.length >= 2 && cells[0] && cells[1]) {
                metadata[cells[0]] = cells[1];
            } else if (cells.length === 1 && cells[0].includes('\t')) {
                const parts = cells[0].split('\t');
                if (parts.length >= 2) metadata[parts[0].trim()] = parts[1].trim();
            }
            if (typeof lines[i] === 'string' && !cells[1] && line.includes('\t')) {
                const parts = line.split('\t');
                if (parts.length >= 2 && parts[0].trim()) {
                    metadata[parts[0].trim()] = parts[1].trim();
                }
            }
            continue;
        }

        if (headerFound && cells[0] && !isNaN(parseFloat(cells[0]))) {
            const row = {
                miles: parseFloat(cells[0]),
                yards: parseFloat(cells[1]),
                gauge: parseFloat(cells[2]),
                xlevel: parseFloat(cells[3]),
                twist1: cells[4] !== '' && cells[4] !== undefined ? parseFloat(cells[4]) : null,
                twist2: cells[5] !== '' && cells[5] !== undefined ? parseFloat(cells[5]) : null,
                zone: cells[7] || cells[6] || ''
            };
            if (!isNaN(row.miles) && !isNaN(row.yards) && !isNaN(row.gauge)) {
                row.location = row.miles + 'mi ' + row.yards.toFixed(1) + 'yds';
                dataRows.push(row);
            }
        }
    }

    parsedData = dataRows;

    if (parsedData.length === 0) {
        throw new Error('No measurement data rows found. Check file format.');
    }

    identifyFaults();
}

function parseHTMLTable(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const rows = doc.querySelectorAll('tr');
    const result = [];
    rows.forEach(row => {
        const cells = [];
        row.querySelectorAll('td, th').forEach(cell => cells.push(cell.textContent.trim()));
        if (cells.length > 0) result.push(cells);
    });
    return result;
}

function formatLocation(row) {
    return row.miles + 'mi ' + row.yards.toFixed(1) + 'yds';
}

// ---- Fault Identification ----
function identifyFaults() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    identifyGaugeFaults(lineSpeed);
    identifyTwistFaults();
}

function identifyGaugeFaults(lineSpeed) {
    gaugeFaults = [];
    const thresholds = getGaugeDetectionThresholds(lineSpeed);
    let inFault = false;
    let currentFault = null;

    for (let i = 0; i < parsedData.length; i++) {
        const row = parsedData[i];
        const isTight = row.gauge <= thresholds.tightBelow;
        const isWide = row.gauge >= thresholds.wideAbove;
        const isFault = isTight || isWide;

        if (isFault) {
            if (!inFault) {
                currentFault = {
                    startIdx: i,
                    startLocation: formatLocation(row),
                    startMiles: row.miles,
                    startYards: row.yards,
                    worstGauge: row.gauge,
                    direction: isWide ? 'wide' : 'tight',
                    rows: [row]
                };
                inFault = true;
            } else {
                currentFault.rows.push(row);
                if (currentFault.direction === 'wide') {
                    if (row.gauge > currentFault.worstGauge) currentFault.worstGauge = row.gauge;
                } else {
                    if (row.gauge < currentFault.worstGauge) currentFault.worstGauge = row.gauge;
                }
            }
        } else {
            if (inFault) {
                finishGaugeFault(currentFault);
                gaugeFaults.push(currentFault);
                inFault = false;
                currentFault = null;
            }
        }
    }
    if (inFault) {
        finishGaugeFault(currentFault);
        gaugeFaults.push(currentFault);
    }
}

function finishGaugeFault(fault) {
    const lastRow = fault.rows[fault.rows.length - 1];
    fault.endLocation = formatLocation(lastRow);
    fault.endMiles = lastRow.miles;
    fault.endYards = lastRow.yards;
    fault.length = (fault.endYards - fault.startYards).toFixed(1);
    if (fault.direction === 'wide') {
        fault.deviation = '+' + (fault.worstGauge - 1435).toFixed(1);
    } else {
        fault.deviation = '-' + (1435 - fault.worstGauge).toFixed(1);
    }
}

function identifyTwistFaults() {
    const threshold = getTwistDetectionThreshold();
    twistFaults = [];
    twistFaultRadiusSettings = [];
    let inFault = false;
    let currentFault = null;

    for (let i = 0; i < parsedData.length; i++) {
        const row = parsedData[i];
        const hasTwist = row.twist1 !== null && !isNaN(row.twist1) &&
            Math.abs(row.twist1) >= threshold;

        if (hasTwist) {
            if (!inFault) {
                currentFault = {
                    startIdx: i,
                    startLocation: formatLocation(row),
                    startMiles: row.miles,
                    startYards: row.yards,
                    maxAbsTwist: Math.abs(row.twist1),
                    worstValue: row.twist1,
                    rows: [row]
                };
                inFault = true;
            } else {
                currentFault.rows.push(row);
                if (Math.abs(row.twist1) > currentFault.maxAbsTwist) {
                    currentFault.maxAbsTwist = Math.abs(row.twist1);
                    currentFault.worstValue = row.twist1;
                }
            }
        } else {
            if (inFault) {
                const lastRow = currentFault.rows[currentFault.rows.length - 1];
                currentFault.endLocation = formatLocation(lastRow);
                currentFault.endMiles = lastRow.miles;
                currentFault.endYards = lastRow.yards;
                currentFault.length = (currentFault.endYards - currentFault.startYards).toFixed(1);
                twistFaults.push(currentFault);
                twistFaultRadiusSettings.push(false); // default: >= 400m
                inFault = false;
                currentFault = null;
            }
        }
    }
    if (inFault) {
        const lastRow = currentFault.rows[currentFault.rows.length - 1];
        currentFault.endLocation = formatLocation(lastRow);
        currentFault.endMiles = lastRow.miles;
        currentFault.endYards = lastRow.yards;
        currentFault.length = (currentFault.endYards - currentFault.startYards).toFixed(1);
        twistFaults.push(currentFault);
        twistFaultRadiusSettings.push(false);
    }
}

// ---- Build Report ----
function buildReport() {
    const route = metadata['Route ID'] || '';
    const track = metadata['Track ID'] || '';
    document.getElementById('reportTitle').textContent =
        'Track Inspection Report' + (route ? ' - ' + route : '') + (track ? ' / ' + track : '');

    // Metadata
    const metaGrid = document.getElementById('metaGrid');
    metaGrid.innerHTML = '';
    const displayKeys = [
        'Operator ID', 'Profile', 'Start Location', 'End Location',
        'Direction Of Travel', 'Job Reference', 'Route ID', 'Track ID',
        'Start Time', 'End Time', 'Serial Number', 'Reference Gauge',
        'Calibrated', 'Twist Base 1', 'Software Version', 'Acquisition Rate'
    ];
    displayKeys.forEach(key => {
        if (metadata[key]) {
            metaGrid.innerHTML += `<div class="meta-item"><span class="label">${key}</span><span class="value">${metadata[key]}</span></div>`;
        }
    });

    updateSummaryStats();
    buildCharts();
    buildGaugeFaultTable();
    buildTwistFaultTable();
    updateSpeedWarning();

    // Tab handling
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById('page-' + tab.dataset.page).classList.add('active');
        });
    });

    // Line speed change handler
    document.getElementById('lineSpeedInput').addEventListener('change', onLineSpeedChange);
    document.getElementById('lineSpeedInput').addEventListener('input', onLineSpeedChange);
}

function onLineSpeedChange() {
    identifyFaults();
    updateSummaryStats();
    buildGaugeFaultTable();
    buildTwistFaultTable();
    buildCharts();
    updateSpeedWarning();
}

function updateSpeedWarning() {
    const speed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const warning = document.getElementById('speedWarning');
    if (speed < 5) {
        warning.classList.add('visible');
    } else {
        warning.classList.remove('visible');
    }
}

function updateSummaryStats() {
    const statsDiv = document.getElementById('summaryStats');
    const totalPoints = parsedData.length;
    const minGauge = Math.min(...parsedData.map(r => r.gauge));
    const maxGauge = Math.max(...parsedData.map(r => r.gauge));
    const twistValues = parsedData.filter(r => r.twist1 !== null).map(r => r.twist1);
    const maxTwist = twistValues.length ? Math.max(...twistValues.map(v => Math.abs(v))) : 0;

    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const ialGauge = gaugeFaults.filter(f => { const c = classifyGaugeFault(f.worstGauge, lineSpeed); return c && c.category === 'IAL'; }).length;
    const ialTwist = twistFaults.filter((f, i) => { const c = classifyTwistFault(f.maxAbsTwist, lineSpeed, twistFaultRadiusSettings[i]); return c && c.category === 'IAL'; }).length;

    statsDiv.innerHTML = `
        <div class="stat-card"><div class="number">${totalPoints}</div><div class="label">Data Points</div></div>
        <div class="stat-card ${gaugeFaults.length > 0 ? 'danger' : ''}"><div class="number">${gaugeFaults.length}</div><div class="label">Gauge Faults</div></div>
        <div class="stat-card ${twistFaults.length > 0 ? 'warning' : ''}"><div class="number">${twistFaults.length}</div><div class="label">Twist Faults</div></div>
        <div class="stat-card ${ialGauge + ialTwist > 0 ? 'danger' : ''}"><div class="number">${ialGauge + ialTwist}</div><div class="label">IAL Faults</div></div>
        <div class="stat-card"><div class="number">${minGauge.toFixed(1)}</div><div class="label">Min Gauge (mm)</div></div>
        <div class="stat-card"><div class="number">${maxTwist.toFixed(1)}</div><div class="label">Max |Twist| (mm)</div></div>
    `;
}

function buildCharts() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const labels = parsedData.map(r => r.miles + 'mi ' + r.yards.toFixed(0) + 'y');
    const step = Math.max(1, Math.floor(parsedData.length / 30));
    const displayLabels = labels.map((l, i) => i % step === 0 ? l : '');

    const gaugeThresholds = getGaugeDetectionThresholds(lineSpeed);
    const twistThreshold = getTwistDetectionThreshold();

    // Gauge chart
    const gaugeCtx = document.getElementById('gaugeChart').getContext('2d');
    if (gaugeChartInstance) gaugeChartInstance.destroy();

    const gaugeDatasets = [
        {
            label: 'Gauge (mm)',
            data: parsedData.map(r => r.gauge),
            borderColor: '#4a6cf7',
            backgroundColor: 'rgba(74,108,247,0.1)',
            fill: true, borderWidth: 1.5, pointRadius: 0, tension: 0.3
        },
        {
            label: 'Reference (1435mm)',
            data: parsedData.map(() => 1435),
            borderColor: '#28a745', borderWidth: 1, borderDash: [6, 4], pointRadius: 0, fill: false
        },
        {
            label: 'Wide Gauge AL (' + gaugeThresholds.wideAbove + 'mm)',
            data: parsedData.map(() => gaugeThresholds.wideAbove),
            borderColor: '#f39c12', borderWidth: 1, borderDash: [4, 4], pointRadius: 0, fill: false
        },
        {
            label: 'Tight Gauge AL (' + gaugeThresholds.tightBelow + 'mm)',
            data: parsedData.map(() => gaugeThresholds.tightBelow),
            borderColor: '#c0392b', borderWidth: 1.5, borderDash: [4, 4], pointRadius: 0, fill: false
        }
    ];

    gaugeChartInstance = new Chart(gaugeCtx, {
        type: 'line',
        data: { labels: displayLabels, datasets: gaugeDatasets },
        options: {
            responsive: true, maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            plugins: {
                legend: { position: 'top', labels: { usePointStyle: true, padding: 16 } },
                tooltip: { callbacks: { title: (items) => labels[items[0].dataIndex] } }
            },
            scales: {
                x: { ticks: { maxRotation: 45, font: { size: 10 } } },
                y: { title: { display: true, text: 'Gauge (mm)' } }
            }
        }
    });

    // Twist chart
    const twist1Data = parsedData.map(r => r.twist1);
    const twistCtx = document.getElementById('twistChart').getContext('2d');
    if (twistChartInstance) twistChartInstance.destroy();

    twistChartInstance = new Chart(twistCtx, {
        type: 'line',
        data: {
            labels: displayLabels,
            datasets: [
                {
                    label: 'Twist 1 - 3m (mm)',
                    data: twist1Data,
                    borderColor: '#e67e22', backgroundColor: 'rgba(230,126,34,0.1)',
                    fill: true, borderWidth: 1.5, pointRadius: 0, tension: 0.3, spanGaps: false
                },
                {
                    label: 'Zero line',
                    data: parsedData.map(() => 0),
                    borderColor: '#aaa', borderWidth: 1, borderDash: [3, 3], pointRadius: 0, fill: false
                },
                {
                    label: '+AL (' + twistThreshold + 'mm)',
                    data: parsedData.map(() => twistThreshold),
                    borderColor: '#28a745', borderWidth: 1, borderDash: [4, 4], pointRadius: 0, fill: false
                },
                {
                    label: '-AL (-' + twistThreshold + 'mm)',
                    data: parsedData.map(() => -twistThreshold),
                    borderColor: '#28a745', borderWidth: 1, borderDash: [4, 4], pointRadius: 0, fill: false
                }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            plugins: {
                legend: { position: 'top', labels: { usePointStyle: true, padding: 16 } },
                tooltip: { callbacks: { title: (items) => labels[items[0].dataIndex] } }
            },
            scales: {
                x: { ticks: { maxRotation: 45, font: { size: 10 } } },
                y: { title: { display: true, text: 'Twist (mm)' } }
            }
        }
    });
}

function buildGaugeFaultTable() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const tbody = document.querySelector('#gaugeFaultTable tbody');
    tbody.innerHTML = '';
    if (gaugeFaults.length === 0) {
        tbody.innerHTML = '<tr><td colspan="10" style="text-align:center;padding:30px;color:#888;">No gauge faults detected</td></tr>';
        return;
    }
    gaugeFaults.forEach((f, idx) => {
        const classification = classifyGaugeFault(f.worstGauge, lineSpeed);
        const tr = document.createElement('tr');
        tr.className = classification ? classification.rowClass : '';
        const catBadge = classification
            ? `<span class="badge ${classification.badge}">${classification.category}</span>`
            : '<span style="color:#999;">--</span>';
        const faultType = classification ? classification.type : (f.direction === 'wide' ? 'Wide Gauge' : 'Tight Gauge');
        const actionText = classification ? classification.action : (lineSpeed < 5 ? 'Set line speed' : 'Below threshold');

        tr.innerHTML = `
            <td>${idx + 1}</td>
            <td><input type="text" class="fault-no-input" data-type="gauge" data-idx="${idx}" placeholder="--" style="width:55px;padding:3px 5px;border:1px solid #ccc;border-radius:4px;font-size:11px;text-align:center;"></td>
            <td>${f.startLocation}</td>
            <td>${f.endLocation}</td>
            <td>${f.length}</td>
            <td>${f.worstGauge.toFixed(1)}</td>
            <td>${f.deviation}</td>
            <td>${faultType}</td>
            <td>${catBadge}</td>
            <td style="font-size:11px;max-width:220px;">${actionText}</td>
        `;
        tbody.appendChild(tr);
    });
}

function buildTwistFaultTable() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const tbody = document.querySelector('#twistFaultTable tbody');
    tbody.innerHTML = '';
    if (twistFaults.length === 0) {
        tbody.innerHTML = '<tr><td colspan="10" style="text-align:center;padding:30px;color:#888;">No twist faults detected</td></tr>';
        return;
    }
    twistFaults.forEach((f, idx) => {
        const isLessThan400 = twistFaultRadiusSettings[idx];
        const classification = classifyTwistFault(f.maxAbsTwist, lineSpeed, isLessThan400);
        const tr = document.createElement('tr');
        tr.className = classification ? classification.rowClass : '';
        const catBadge = classification
            ? `<span class="badge ${classification.badge}">${classification.category}</span>`
            : '<span style="color:#999;">--</span>';
        const actionText = classification ? classification.action : (lineSpeed < 5 ? 'Set line speed' : 'Below threshold');

        tr.innerHTML = `
            <td>${idx + 1}</td>
            <td><input type="text" class="fault-no-input" data-type="twist" data-idx="${idx}" placeholder="--" style="width:55px;padding:3px 5px;border:1px solid #ccc;border-radius:4px;font-size:11px;text-align:center;"></td>
            <td>${f.startLocation}</td>
            <td>${f.endLocation}</td>
            <td>${f.length}</td>
            <td>${f.maxAbsTwist.toFixed(1)}</td>
            <td>${f.worstValue.toFixed(1)}</td>
            <td>
                <select class="radius-select" data-twist-idx="${idx}" onchange="onRadiusChange(this)">
                    <option value="gte400" ${!isLessThan400 ? 'selected' : ''}>&ge; 400m</option>
                    <option value="lt400" ${isLessThan400 ? 'selected' : ''}>&lt; 400m</option>
                </select>
            </td>
            <td>${catBadge}</td>
            <td style="font-size:11px;max-width:220px;">${actionText}</td>
        `;
        tbody.appendChild(tr);
    });
}

function onRadiusChange(selectEl) {
    const idx = parseInt(selectEl.dataset.twistIdx);
    twistFaultRadiusSettings[idx] = (selectEl.value === 'lt400');
    // Rebuild just the twist table and summary
    buildTwistFaultTable();
    updateSummaryStats();
}

// ---- Navigation ----
function goBack() {
    document.getElementById('uploadScreen').style.display = 'flex';
    document.getElementById('reportContainer').classList.remove('active');
    fileInput.value = '';
}

// ---- Export Excel ----
function exportExcel() {
    const wb = XLSX.utils.book_new();
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;

    // Sheet 1: Survey Info
    const runName = document.getElementById('runNameInput').value;
    const inspector = document.getElementById('inspectorInput').value;
    const metaArr = [
        { Field: 'Run Name', Value: runName },
        { Field: 'Inspector', Value: inspector },
        { Field: 'Line Speed (mph)', Value: lineSpeed || 'Not set' },
        ...Object.entries(metadata).map(([k, v]) => ({ Field: k, Value: v }))
    ];
    const ws1 = XLSX.utils.json_to_sheet(metaArr);
    XLSX.utils.book_append_sheet(wb, ws1, 'Survey Info');

    // Sheet 2: All Data
    const allData = parsedData.map(r => ({
        Miles: r.miles,
        Yards: r.yards,
        'Gauge (mm)': r.gauge,
        'X-Level (mm)': r.xlevel,
        'Twist 1 (mm)': r.twist1,
        Zone: r.zone
    }));
    const ws2 = XLSX.utils.json_to_sheet(allData);
    XLSX.utils.book_append_sheet(wb, ws2, 'All Data');

    // Sheet 3: Gauge Faults
    const gaugeFaultNos = document.querySelectorAll('.fault-no-input[data-type="gauge"]');
    const gfData = gaugeFaults.map((f, i) => {
        const c = classifyGaugeFault(f.worstGauge, lineSpeed);
        return {
            '#': i + 1,
            'Fault No.': gaugeFaultNos[i] ? gaugeFaultNos[i].value : '',
            'Start Location': f.startLocation,
            'End Location': f.endLocation,
            'Length (yds)': f.length,
            'Worst Gauge (mm)': f.worstGauge.toFixed(1),
            'Deviation (mm)': f.deviation,
            'Fault Type': c ? c.type : (f.direction === 'wide' ? 'Wide Gauge' : 'Tight Gauge'),
            'Category': c ? c.category : '',
            'Required Action': c ? c.action : ''
        };
    });
    const ws3 = XLSX.utils.json_to_sheet(gfData.length ? gfData : [{ Info: 'No gauge faults' }]);
    XLSX.utils.book_append_sheet(wb, ws3, 'Gauge Faults');

    // Sheet 4: Twist Faults
    const twistFaultNos = document.querySelectorAll('.fault-no-input[data-type="twist"]');
    const tfData = twistFaults.map((f, i) => {
        const c = classifyTwistFault(f.maxAbsTwist, lineSpeed, twistFaultRadiusSettings[i]);
        return {
            '#': i + 1,
            'Fault No.': twistFaultNos[i] ? twistFaultNos[i].value : '',
            'Start Location': f.startLocation,
            'End Location': f.endLocation,
            'Length (yds)': f.length,
            'Max |Twist| (mm)': f.maxAbsTwist.toFixed(1),
            'Worst Value (mm)': f.worstValue.toFixed(1),
            'Curve Radius': twistFaultRadiusSettings[i] ? '< 400m' : '>= 400m',
            'Category': c ? c.category : '',
            'Required Action': c ? c.action : ''
        };
    });
    const ws4 = XLSX.utils.json_to_sheet(tfData.length ? tfData : [{ Info: 'No twist faults' }]);
    XLSX.utils.book_append_sheet(wb, ws4, 'Twist Faults');

    const filename = 'TrackInspection_' + (metadata['Route ID'] || 'Report') + '_' +
        (metadata['Track ID'] || '') + '.xlsx';
    XLSX.writeFile(wb, filename);
}

// ---- Export PDF ----
function exportPDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('landscape', 'mm', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;

    // Page 1: Survey info + summary
    const pdfRunName = document.getElementById('runNameInput').value;
    const pdfInspector = document.getElementById('inspectorInput').value;

    doc.setFontSize(18);
    doc.setTextColor(26, 26, 46);
    doc.text('Track Inspection Report', 14, 20);
    doc.setFontSize(10);
    doc.setTextColor(100);
    const route = metadata['Route ID'] || '';
    const track = metadata['Track ID'] || '';
    doc.text(`Run Name: ${pdfRunName}  |  Inspector: ${pdfInspector}  |  Line Speed: ${lineSpeed || 'N/A'} mph`, 14, 28);
    doc.text(`Route: ${route}  |  Track: ${track}  |  ${metadata['Job Reference'] || ''}`, 14, 34);
    doc.text(`${metadata['Start Location'] || ''} to ${metadata['End Location'] || ''}`, 14, 40);
    doc.text(`Date: ${metadata['Start Time'] || ''}`, 14, 46);

    // Summary table
    doc.autoTable({
        startY: 54,
        head: [['Total Points', 'Gauge Faults', 'Twist Faults', 'Min Gauge', 'Max Gauge', 'Max |Twist|']],
        body: [[
            parsedData.length,
            gaugeFaults.length,
            twistFaults.length,
            Math.min(...parsedData.map(r => r.gauge)).toFixed(1) + ' mm',
            Math.max(...parsedData.map(r => r.gauge)).toFixed(1) + ' mm',
            (parsedData.filter(r => r.twist1 !== null).length > 0
                ? Math.max(...parsedData.filter(r => r.twist1 !== null).map(r => Math.abs(r.twist1))).toFixed(1) + ' mm'
                : 'N/A')
        ]],
        theme: 'grid',
        headStyles: { fillColor: [26, 26, 46] },
        styles: { fontSize: 9 }
    });

    // Add chart images
    const gaugeCanvas = document.getElementById('gaugeChart');
    const twistCanvas = document.getElementById('twistChart');
    const gaugeImg = gaugeCanvas.toDataURL('image/png');
    const twistImg = twistCanvas.toDataURL('image/png');

    const chartY = doc.lastAutoTable.finalY + 8;
    const chartW = pageWidth - 28;
    const chartH = 70;
    doc.addImage(gaugeImg, 'PNG', 14, chartY, chartW, chartH);
    doc.addImage(twistImg, 'PNG', 14, chartY + chartH + 6, chartW, chartH);

    // Page 2: Gauge Faults
    doc.addPage();
    doc.setFontSize(14);
    doc.setTextColor(26, 26, 46);
    doc.text('Gauge Faults (Table 5 Limits) - Line Speed: ' + (lineSpeed || 'N/A') + ' mph', 14, 20);

    const pdfGaugeFaultNos = document.querySelectorAll('.fault-no-input[data-type="gauge"]');
    if (gaugeFaults.length === 0) {
        doc.setFontSize(11);
        doc.setTextColor(100);
        doc.text('No gauge faults detected.', 14, 32);
    } else {
        doc.autoTable({
            startY: 28,
            head: [['#', 'Fault No.', 'Start', 'End', 'Length', 'Worst Gauge', 'Deviation', 'Type', 'Cat.', 'Required Action']],
            body: gaugeFaults.map((f, i) => {
                const c = classifyGaugeFault(f.worstGauge, lineSpeed);
                return [
                    i + 1,
                    pdfGaugeFaultNos[i] ? pdfGaugeFaultNos[i].value : '',
                    f.startLocation, f.endLocation, f.length,
                    f.worstGauge.toFixed(1), f.deviation,
                    c ? c.type : (f.direction === 'wide' ? 'Wide' : 'Tight'),
                    c ? c.category : '',
                    c ? c.action : ''
                ];
            }),
            theme: 'striped',
            headStyles: { fillColor: [26, 26, 46] },
            styles: { fontSize: 7 },
            columnStyles: { 9: { cellWidth: 55 } }
        });
    }

    // Gauge sign-off
    const gSignY = gaugeFaults.length > 0 ? doc.lastAutoTable.finalY + 12 : 44;
    doc.setFontSize(12);
    doc.setTextColor(26, 26, 46);
    doc.text('Section Manager Sign-Off', 14, gSignY);
    doc.setFontSize(9);
    doc.setTextColor(80);
    doc.text(`Name: ${document.getElementById('gaugeSignOffName').value}`, 14, gSignY + 8);
    doc.text(`Date: ${document.getElementById('gaugeSignOffDate').value}`, 14, gSignY + 14);
    doc.text(`Signature: ${document.getElementById('gaugeSignOffSig').value}`, 120, gSignY + 8);
    doc.text(`Comments: ${document.getElementById('gaugeSignOffComments').value}`, 120, gSignY + 14);

    // Page 3: Twist Faults
    doc.addPage();
    doc.setFontSize(14);
    doc.setTextColor(26, 26, 46);
    doc.text('Twist Faults - 3m Base (Table 3 Limits) - Line Speed: ' + (lineSpeed || 'N/A') + ' mph', 14, 20);

    const pdfTwistFaultNos = document.querySelectorAll('.fault-no-input[data-type="twist"]');
    if (twistFaults.length === 0) {
        doc.setFontSize(11);
        doc.setTextColor(100);
        doc.text('No twist faults detected.', 14, 32);
    } else {
        doc.autoTable({
            startY: 28,
            head: [['#', 'Fault No.', 'Start', 'End', 'Length', 'Max |Twist|', 'Worst', 'Curve R', 'Cat.', 'Required Action']],
            body: twistFaults.map((f, i) => {
                const c = classifyTwistFault(f.maxAbsTwist, lineSpeed, twistFaultRadiusSettings[i]);
                return [
                    i + 1,
                    pdfTwistFaultNos[i] ? pdfTwistFaultNos[i].value : '',
                    f.startLocation, f.endLocation, f.length,
                    f.maxAbsTwist.toFixed(1), f.worstValue.toFixed(1),
                    twistFaultRadiusSettings[i] ? '< 400m' : '>= 400m',
                    c ? c.category : '',
                    c ? c.action : ''
                ];
            }),
            theme: 'striped',
            headStyles: { fillColor: [26, 26, 46] },
            styles: { fontSize: 7 },
            columnStyles: { 9: { cellWidth: 55 } }
        });
    }

    // Twist sign-off
    const tSignY = twistFaults.length > 0 ? doc.lastAutoTable.finalY + 12 : 44;
    doc.setFontSize(12);
    doc.setTextColor(26, 26, 46);
    doc.text('Section Manager Sign-Off', 14, tSignY);
    doc.setFontSize(9);
    doc.setTextColor(80);
    doc.text(`Name: ${document.getElementById('twistSignOffName').value}`, 14, tSignY + 8);
    doc.text(`Date: ${document.getElementById('twistSignOffDate').value}`, 14, tSignY + 14);
    doc.text(`Signature: ${document.getElementById('twistSignOffSig').value}`, 120, tSignY + 8);
    doc.text(`Comments: ${document.getElementById('twistSignOffComments').value}`, 120, tSignY + 14);

    const filename = 'TrackInspection_' + (metadata['Route ID'] || 'Report') + '_' +
        (metadata['Track ID'] || '') + '.pdf';
    doc.save(filename);
}
</script>

</body>
</html>

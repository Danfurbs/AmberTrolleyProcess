<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amber Trolley - Track Inspection Report Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>if (window.pdfjsLib) pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f2f5; color: #333; }

        .upload-screen {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; padding: 40px;
        }
        .upload-screen h1 { font-size: 28px; margin-bottom: 8px; color: #1a1a2e; }
        .upload-screen p { color: #666; margin-bottom: 30px; }
        .drop-zone {
            width: 500px; max-width: 90vw; height: 200px;
            border: 3px dashed #aab; border-radius: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s; background: #fff;
        }
        .drop-zone:hover, .drop-zone.dragover { border-color: #4a6cf7; background: #f0f4ff; }
        .drop-zone span { font-size: 16px; color: #666; }
        .drop-zone .icon { font-size: 48px; margin-bottom: 12px; }
        .drop-zone input { display: none; }

        .report-container { display: none; max-width: 1400px; margin: 0 auto; padding: 20px; }
        .report-container.active { display: block; }

        .toolbar {
            display: flex; gap: 10px; align-items: center; margin-bottom: 20px;
            padding: 16px 20px; background: #1a1a2e; border-radius: 10px; flex-wrap: wrap;
        }
        .toolbar h2 { color: #fff; font-size: 18px; flex: 1; }
        .toolbar button {
            padding: 8px 18px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 14px; font-weight: 600; transition: all 0.2s;
        }
        .btn-excel { background: #1d6f42; color: #fff; }
        .btn-excel:hover { background: #175c36; }
        .btn-pdf { background: #c0392b; color: #fff; }
        .btn-pdf:hover { background: #a93226; }
        .btn-back { background: #555; color: #fff; }
        .btn-back:hover { background: #444; }

        .tabs {
            display: flex; gap: 4px; margin-bottom: 20px; background: #ddd; padding: 4px;
            border-radius: 8px;
        }
        .tab {
            flex: 1; padding: 12px 16px; text-align: center; border: none; background: none;
            cursor: pointer; border-radius: 6px; font-size: 14px; font-weight: 600;
            color: #666; transition: all 0.2s;
        }
        .tab.active { background: #fff; color: #1a1a2e; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

        .page { display: none; }
        .page.active { display: block; }

        .card {
            background: #fff; border-radius: 10px; padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); margin-bottom: 20px;
        }
        .card h3 { font-size: 16px; color: #1a1a2e; margin-bottom: 16px; border-bottom: 2px solid #eee; padding-bottom: 8px; }

        .meta-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 8px 24px;
        }
        .meta-item { display: flex; justify-content: space-between; padding: 4px 0; font-size: 13px; }
        .meta-item .label { color: #888; }
        .meta-item .value { font-weight: 600; color: #333; }

        .chart-row { display: grid; grid-template-columns: 1fr; gap: 20px; }
        .chart-stack { display: grid; gap: 16px; }
        .chart-wrapper { position: relative; height: 300px; }
        .chart-segment-title { font-size: 12px; color: #666; margin: 4px 0 6px; }
        canvas { width: 100% !important; }

        table {
            width: 100%; border-collapse: collapse; font-size: 12px;
        }
        thead th {
            background: #1a1a2e; color: #fff; padding: 8px 10px; text-align: left;
            font-weight: 600; position: sticky; top: 0; white-space: nowrap;
        }
        tbody td { padding: 6px 10px; border-bottom: 1px solid #eee; }
        tbody tr:hover { background: #f8f9ff; }

        .summary-stats {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px; margin-bottom: 20px;
        }
        .stat-card {
            background: #fff; border-radius: 10px; padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); text-align: center;
        }
        .stat-card .number { font-size: 32px; font-weight: 700; color: #1a1a2e; }
        .stat-card .label { font-size: 13px; color: #888; margin-top: 4px; }
        .stat-card.warning .number { color: #e67e22; }
        .stat-card.danger .number { color: #c0392b; }

        .cat-ial { background: #f8d7da; border-left: 4px solid #c0392b; }
        .cat-ial-block { background: #f5c6cb; border-left: 4px solid #721c24; }
        .cat-il { background: #fff3cd; border-left: 4px solid #e67e22; }
        .cat-al { background: #d4edda; border-left: 4px solid #28a745; }

        .badge {
            display: inline-block; padding: 2px 8px; border-radius: 4px;
            font-size: 11px; font-weight: 700; color: #fff; white-space: nowrap;
        }
        .badge-ial { background: #c0392b; }
        .badge-il { background: #e67e22; }
        .badge-al { background: #28a745; }

        .run-info-bar {
            display: flex; gap: 20px; align-items: center; margin-bottom: 20px;
            padding: 16px 20px; background: #fff; border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); flex-wrap: wrap;
        }
        .run-info-bar label { font-size: 13px; color: #888; font-weight: 600; }
        .run-info-bar input, .run-info-bar select {
            padding: 6px 12px; border: 1px solid #ccc; border-radius: 6px;
            font-size: 14px; font-family: inherit; min-width: 120px;
        }
        .run-info-bar input:focus, .run-info-bar select:focus { outline: none; border-color: #4a6cf7; box-shadow: 0 0 0 2px rgba(74,108,247,0.15); }
        .run-info-group { display: flex; flex-direction: column; gap: 4px; }

        .speed-warning {
            display: none; padding: 10px 16px; background: #fff3cd; border: 1px solid #ffc107;
            border-radius: 8px; margin-bottom: 16px; font-size: 13px; color: #856404;
        }
        .speed-warning.visible { display: block; }
        .caution-warning {
            padding: 12px 16px; background: #fff5f5; border: 1px solid #f5c2c7;
            border-radius: 8px; margin-bottom: 16px; font-size: 13px; color: #842029;
        }

        .override-card {
            background: #fff; border-radius: 10px; padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); margin-bottom: 20px;
        }
        .override-card summary { cursor: pointer; font-weight: 600; color: #1a1a2e; }
        .override-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px 20px; margin-top: 16px;
        }
        .override-field { display: flex; flex-direction: column; gap: 4px; }
        .override-field label { font-size: 12px; color: #666; font-weight: 600; }
        .override-field input { padding: 6px 10px; border: 1px solid #ccc; border-radius: 6px; }

        .radius-select {
            padding: 3px 6px; border: 1px solid #ccc; border-radius: 4px;
            font-size: 11px; background: #fff; cursor: pointer;
        }

        .sign-off-section {
            margin-top: 20px; padding: 20px; background: #fafafa; border: 2px solid #ddd;
            border-radius: 10px;
        }
        .sign-off-section h4 { font-size: 14px; color: #1a1a2e; margin-bottom: 16px; border-bottom: 2px solid #ccc; padding-bottom: 8px; }
        .sign-off-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 16px 32px;
        }
        .sign-off-field { display: flex; flex-direction: column; gap: 4px; }
        .sign-off-field label { font-size: 12px; color: #888; font-weight: 600; text-transform: uppercase; }
        .sign-off-field input {
            padding: 8px 12px; border: none; border-bottom: 2px solid #999;
            background: transparent; font-size: 14px; font-family: inherit;
        }
        .sign-off-field input:focus { outline: none; border-bottom-color: #4a6cf7; }

        .note-box {
            margin-top: 12px; padding: 10px 14px; background: #f8f9fa; border-left: 3px solid #6c757d;
            font-size: 12px; color: #555; line-height: 1.5;
        }

        .run-selector-bar {
            display: flex; gap: 10px; align-items: center; margin-bottom: 20px;
            padding: 14px 20px; background: #fff; border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); flex-wrap: wrap;
        }
        .run-selector-bar label { font-size: 13px; color: #888; font-weight: 600; }
        .run-selector-bar select {
            padding: 6px 12px; border: 1px solid #ccc; border-radius: 6px;
            font-size: 14px; font-family: inherit; min-width: 200px;
        }
        .run-selector-bar select:focus { outline: none; border-color: #4a6cf7; box-shadow: 0 0 0 2px rgba(74,108,247,0.15); }
        .run-selector-bar .run-count { font-size: 12px; color: #666; padding: 4px 10px; background: #eef; border-radius: 12px; }

        .trace-controls {
            display: flex; gap: 12px; align-items: center; flex-wrap: wrap;
            margin: 12px 0 14px; padding: 10px 12px;
            background: #f8f9ff; border: 1px solid #dde3ff; border-radius: 8px;
            font-size: 12px; color: #555;
        }
        .trace-controls label { display: flex; gap: 6px; align-items: center; font-weight: 600; color: #444; }
        .trace-controls input[type="number"] {
            width: 120px; padding: 4px 6px; border: 1px solid #ccc; border-radius: 6px;
            font-size: 12px; font-family: inherit;
        }
        .trace-controls input[type="checkbox"] { transform: translateY(1px); }

        .btn-add-fault {
            padding: 8px 16px; border: 2px dashed #4a6cf7; border-radius: 6px;
            background: #f0f4ff; color: #4a6cf7; cursor: pointer; font-size: 13px;
            font-weight: 600; transition: all 0.2s; margin-bottom: 12px;
        }
        .btn-add-fault:hover { background: #4a6cf7; color: #fff; }

        .manual-fault-tag {
            display: inline-block; padding: 1px 6px; border-radius: 3px;
            font-size: 9px; font-weight: 700; color: #fff; background: #6c757d;
            margin-left: 4px; vertical-align: middle;
        }

        .btn-remove-fault {
            padding: 2px 6px; border: none; background: #dc3545; color: #fff;
            border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: 700;
        }
        .btn-remove-fault:hover { background: #c82333; }

        .btn-dismiss-fault {
            padding: 2px 8px; border: 1px solid #6c757d; background: #fff; color: #6c757d;
            border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: 600;
        }
        .btn-dismiss-fault:hover { background: #6c757d; color: #fff; }

        .btn-restore-fault {
            padding: 2px 8px; border: 1px solid #28a745; background: #fff; color: #28a745;
            border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: 600;
        }
        .btn-restore-fault:hover { background: #28a745; color: #fff; }

        .btn-edit-fault {
            padding: 2px 8px; border: 1px solid #4a6cf7; background: #fff; color: #4a6cf7;
            border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: 600;
        }
        .btn-edit-fault:hover { background: #4a6cf7; color: #fff; }

        .dismissed-info {
            display: block; font-size: 10px; color: #888; font-style: italic;
            text-decoration: none; margin-top: 2px;
        }

        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;
        }
        .modal-overlay.active { display: flex; }
        .modal {
            background: #fff; border-radius: 12px; padding: 28px; width: 500px; max-width: 90vw;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }
        .modal h3 { font-size: 18px; color: #1a1a2e; margin-bottom: 20px; }
        .modal-field { margin-bottom: 14px; }
        .modal-field label { display: block; font-size: 12px; color: #888; font-weight: 600; text-transform: uppercase; margin-bottom: 4px; }
        .modal-field input, .modal-field select, .modal-field textarea {
            width: 100%; padding: 8px 12px; border: 1px solid #ccc; border-radius: 6px;
            font-size: 14px; font-family: inherit;
        }
        .modal-field input:focus, .modal-field select:focus, .modal-field textarea:focus { outline: none; border-color: #4a6cf7; }
        .modal-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .modal-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; }
        .modal-actions button {
            padding: 8px 20px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 14px; font-weight: 600;
        }
        .btn-modal-cancel { background: #eee; color: #666; }
        .btn-modal-cancel:hover { background: #ddd; }
        .btn-modal-save { background: #4a6cf7; color: #fff; }
        .btn-modal-save:hover { background: #3a5ce5; }

        .comparison-table { width: 100%; border-collapse: collapse; font-size: 12px; margin-top: 12px; }
        .comparison-table th { background: #1a1a2e; color: #fff; padding: 6px 10px; text-align: left; font-size: 11px; }
        .comparison-table td { padding: 5px 10px; border-bottom: 1px solid #eee; font-size: 11px; }
        .comp-new { background: #f8d7da; }
        .comp-resolved { background: #d4edda; }
        .comp-persists { background: #fff3cd; }
        .comp-legend { display: flex; gap: 16px; margin-bottom: 12px; font-size: 12px; }
        .comp-legend span { padding: 2px 10px; border-radius: 4px; }
        .btn-clear-comparison {
            padding: 4px 12px; border: 1px solid #999; background: #fff; color: #666;
            border-radius: 4px; cursor: pointer; font-size: 11px; margin-left: 8px;
        }
        .btn-clear-comparison:hover { background: #eee; }
        .prev-run-info { padding: 8px 12px; background: #eef; border-radius: 6px; font-size: 12px; color: #336; margin-bottom: 12px; }

        @media print {
            .toolbar, .tabs, .run-selector-bar { display: none; }
            .page { display: block !important; page-break-after: always; }
            .card { box-shadow: none; border: 1px solid #ddd; }
        }
    </style>
</head>
<body>

<div class="upload-screen" id="uploadScreen">
    <h1>Amber Trolley Report Generator</h1>
    <p>Upload a raw data HTML file from the Amber trolley to generate an inspection report</p>
    <div class="drop-zone" id="dropZone">
        <div class="icon">&#128196;</div>
        <span>Drop file(s) here or click to browse — select multiple for bulk upload</span>
        <input type="file" id="fileInput" accept=".html,.htm,.txt,.csv" multiple>
    </div>
    <div style="margin-top: 30px; max-width: 560px;">
        <p style="font-size: 13px; color: #999; text-align: center;">
            Classifies twist and gauge faults against Table 3 &amp; Table 5 limits
            (IAL / IL / AL) with speed-dependent thresholds and remedial actions.
            Upload multiple files at once to process several runs. Export as Excel or PDF.
        </p>
    </div>
</div>

<div class="report-container" id="reportContainer">
    <div class="toolbar">
        <h2 id="reportTitle">Track Inspection Report</h2>
        <button class="btn-back" onclick="goBack()">Load New File</button>
        <button class="btn-excel" onclick="exportExcel()">Export Excel</button>
        <button class="btn-pdf" onclick="exportPDF()">Export PDF</button>
    </div>

    <div class="run-selector-bar" id="runSelectorBar" style="display:none;">
        <label>Active Run</label>
        <select id="runSelector" onchange="switchRun(this.value)"></select>
        <span class="run-count" id="runCount"></span>
    </div>

    <div class="run-info-bar">
        <div class="run-info-group">
            <label>Run Name</label>
            <input type="text" id="runNameInput" placeholder="Enter run name...">
        </div>
        <div class="run-info-group">
            <label>Inspector</label>
            <input type="text" id="inspectorInput" placeholder="Enter inspector name...">
        </div>
        <div class="run-info-group">
            <label>Line Speed (mph)</label>
            <input type="number" id="lineSpeedInput" placeholder="e.g. 75" min="5" max="125" style="width:100px;">
        </div>
        <div class="run-info-group">
            <label>Track Category</label>
            <select id="trackCatInput" style="width:120px;">
                <option value="">-- Select --</option>
                <option value="1A">Cat 1A</option>
                <option value="1">Cat 1</option>
                <option value="2">Cat 2</option>
                <option value="3">Cat 3</option>
                <option value="4">Cat 4</option>
                <option value="5">Cat 5</option>
                <option value="6">Cat 6</option>
            </select>
        </div>
    </div>

    <div class="speed-warning" id="speedWarning">
        Please enter a Line Speed (5-125 mph) above to classify faults against the correct thresholds.
    </div>
    <div class="caution-warning">
        Caution: This tool should reflect the correct tolerances, but always verify against the latest standard.
    </div>

    <details class="override-card" id="overrideCard">
        <summary>Inspector Override Values</summary>
        <div class="override-grid">
            <div class="override-field">
                <label>
                    <input type="checkbox" id="overrideToggle">
                    Enable manual overrides for thresholds
                </label>
            </div>
            <div class="override-field">
                <label for="overrideGaugeWideAL">Gauge wide AL threshold (mm)</label>
                <input type="number" id="overrideGaugeWideAL" step="0.1" placeholder="e.g. 1445">
            </div>
            <div class="override-field">
                <label for="overrideGaugeWideIL">Gauge wide IL threshold (mm)</label>
                <input type="number" id="overrideGaugeWideIL" step="0.1" placeholder="e.g. 1450">
            </div>
            <div class="override-field">
                <label for="overrideGaugeWideIAL">Gauge wide IAL threshold (mm)</label>
                <input type="number" id="overrideGaugeWideIAL" step="0.1" placeholder="e.g. 1458">
            </div>
            <div class="override-field">
                <label for="overrideGaugeTightAL">Gauge tight AL threshold (mm)</label>
                <input type="number" id="overrideGaugeTightAL" step="0.1" placeholder="e.g. 1426">
            </div>
            <div class="override-field">
                <label for="overrideGaugeTightIL">Gauge tight IL threshold (mm)</label>
                <input type="number" id="overrideGaugeTightIL" step="0.1" placeholder="e.g. 1424">
            </div>
            <div class="override-field">
                <label for="overrideGaugeTightIAL">Gauge tight IAL threshold (mm)</label>
                <input type="number" id="overrideGaugeTightIAL" step="0.1" placeholder="e.g. 1422">
            </div>
            <div class="override-field">
                <label for="overrideTwistAL">Twist AL threshold (mm)</label>
                <input type="number" id="overrideTwistAL" step="0.1" placeholder="e.g. 12">
            </div>
            <div class="override-field">
                <label for="overrideTwistIL">Twist IL threshold (mm)</label>
                <input type="number" id="overrideTwistIL" step="0.1" placeholder="e.g. 15">
            </div>
            <div class="override-field">
                <label for="overrideTwistIAL">Twist IAL threshold (mm)</label>
                <input type="number" id="overrideTwistIAL" step="0.1" placeholder="e.g. 21/24">
            </div>
        </div>
        <p style="margin-top:12px;font-size:12px;color:#666;">
            Overrides affect fault detection thresholds only and should be used sparingly with engineering sign-off.
        </p>
    </details>

    <div class="tabs">
        <button class="tab active" data-page="overview">Overview &amp; Graphs</button>
        <button class="tab" data-page="gaugeFaults">Gauge Faults</button>
        <button class="tab" data-page="twistFaults">Twist Faults</button>
        <button class="tab" data-page="invalidatedFaults">Invalidated Faults</button>
        <button class="tab" data-page="gaugeVariationFaults">Gauge Variation Faults</button>
    </div>

    <!-- Page 1: Overview & Graphs -->
    <div class="page active" id="page-overview">
        <div class="card">
            <h3>Survey Information</h3>
            <div class="meta-grid" id="metaGrid"></div>
            <div class="note-box" id="flipNotice" style="display:none;"></div>
        </div>

        <div class="summary-stats" id="summaryStats"></div>

        <div class="card">
            <h3>Fault Location Schematic</h3>
            <p style="margin-bottom:8px;color:#666;font-size:12px;">Linear diagram showing fault positions along the track. Colour indicates severity.</p>
            <div id="schematicContainer" style="overflow-x:auto;padding:8px 4px 0;background:#fafafa;border-radius:8px;border:1px solid #eee;">
                <canvas id="schematicCanvas" height="200"></canvas>
            </div>
        </div>

        <div class="card">
            <h3>Gauge Profile (mm)</h3>
            <div id="gaugeCharts" class="chart-stack"></div>
        </div>
        <div class="card">
            <h3>Twist over 3m (mm)</h3>
            <div id="twistCharts" class="chart-stack"></div>
        </div>
        <div class="card">
            <h3>X-Level (Cant) (mm)</h3>
            <div id="xlevelCharts" class="chart-stack"></div>
        </div>
        <div class="card">
            <h3>Gauge Variation (Gauge Delta over 3m) (mm)</h3>
            <div id="gaugeVariationCharts" class="chart-stack"></div>
        </div>

        <!-- Previous Run Comparison -->
        <div class="card" id="comparisonCard">
            <h3>Run-on-Run Comparison</h3>
            <div id="comparisonEmpty">
                <p style="color:#666;font-size:13px;margin-bottom:12px;">
                    Load a previous report PDF to compare faults between runs.
                </p>
                <label class="btn-add-fault" style="cursor:pointer;">
                    Load Previous Run PDF
                    <input type="file" id="prevRunInput" accept=".pdf" style="display:none;" onchange="loadPreviousRunPDF(this)">
                </label>
            </div>
            <div id="comparisonResults" style="display:none;"></div>
        </div>
    </div>

    <!-- Page 2: Gauge Faults -->
    <div class="page" id="page-gaugeFaults">
        <div class="card">
            <h3>Gauge Faults (Table 5 Limits)</h3>
            <p style="margin-bottom: 12px; color: #666; font-size: 13px;">
                Wide gauge and tight gauge faults classified per Table 5 thresholds for the configured line speed.
            </p>
            <button class="btn-add-fault" onclick="openManualGaugeFaultModal()">+ Add Manual Gauge Fault</button>
            <div style="overflow-x: auto;">
                <table id="gaugeFaultTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Fault No.</th>
                            <th>Start Location</th>
                            <th>End Location</th>
                            <th>Length (yds)</th>
                            <th>Worst Gauge (mm)</th>
                            <th>Deviation (mm)</th>
                            <th>Fault Type</th>
                            <th>Category</th>
                            <th>Required Action</th>
                            <th>Repeat</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="note-box">
                <strong>Note 1:</strong> These actions assume no significant associated faults at the same location. If other faults exist, complete the action to a shorter timescale.<br>
                <strong>Note 2:</strong> These are based upon nominal gauge for that type of track. Any design gauge widening is to be added to the lower limit for the action threshold.
            </div>
            <div class="sign-off-section">
                <h4>Section Manager Sign-Off</h4>
                <div class="sign-off-grid">
                    <div class="sign-off-field">
                        <label>Name</label>
                        <input type="text" id="gaugeSignOffName" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Date</label>
                        <input type="date" id="gaugeSignOffDate">
                    </div>
                    <div class="sign-off-field">
                        <label>Signature</label>
                        <input type="text" id="gaugeSignOffSig" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Comments</label>
                        <input type="text" id="gaugeSignOffComments" placeholder="">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Page 3: Twist Faults -->
    <div class="page" id="page-twistFaults">
        <div class="card">
            <h3>Twist Faults - 3m Base (Table 3 Limits)</h3>
            <p style="margin-bottom: 12px; color: #666; font-size: 13px;">
                Twist faults classified per Table 3 thresholds. Set the curve radius toggle per fault to adjust IL timescales.
            </p>
            <button class="btn-add-fault" onclick="openManualTwistFaultModal()">+ Add Manual Twist Fault</button>
            <div style="overflow-x: auto;">
                <table id="twistFaultTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Fault No.</th>
                            <th>Start Location</th>
                            <th>End Location</th>
                            <th>Length (yds)</th>
                            <th>Max |Twist| (mm)</th>
                            <th>Worst Value (mm)</th>
                            <th>Curve Radius</th>
                            <th>Category</th>
                            <th>Required Action</th>
                            <th>Repeat</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="note-box">
                <strong>Note 1:</strong> Where twist faults at Intervention Limit or above are adjacent to structures with tight clearances, complete the action to a shorter timescale.<br>
                <strong>Note 2:</strong> These actions assume no significant associated faults at the same location. If other faults exist, complete the action to a shorter timescale.
            </div>
            <div class="sign-off-section">
                <h4>Section Manager Sign-Off</h4>
                <div class="sign-off-grid">
                    <div class="sign-off-field">
                        <label>Name</label>
                        <input type="text" id="twistSignOffName" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Date</label>
                        <input type="date" id="twistSignOffDate">
                    </div>
                    <div class="sign-off-field">
                        <label>Signature</label>
                        <input type="text" id="twistSignOffSig" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Comments</label>
                        <input type="text" id="twistSignOffComments" placeholder="">
                    </div>
                </div>
            </div>
        </div>
    </div>


    <!-- Page 4: Invalidated Faults -->
    <div class="page" id="page-invalidatedFaults">
        <div class="card">
            <h3>Invalidated Faults</h3>
            <p style="margin-bottom: 12px; color: #666; font-size: 13px;">
                Faults removed from active reporting. Use restore if a fault was invalidated by mistake.
            </p>
            <div style="overflow-x: auto;">
                <table id="invalidatedFaultTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Type</th>
                            <th>Location</th>
                            <th>Value</th>
                            <th>Removed By</th>
                            <th>Removed At</th>
                            <th>Reason</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Page 5: Gauge Variation Faults -->
    <div class="page" id="page-gaugeVariationFaults">
        <div class="card">
            <h3>Gauge Variation Faults - 3m Base</h3>
            <p style="margin-bottom: 12px; color: #666; font-size: 13px;">
                Classified from the Gauge Delta column using static track gauge variation intervention limits.
                Where Gauge Delta is not present in the source file, this table remains empty.
            </p>
            <div style="overflow-x: auto;">
                <table id="gaugeVariationFaultTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Start Location</th>
                            <th>End Location</th>
                            <th>Length (yds)</th>
                            <th>Max |Gauge Delta| (mm)</th>
                            <th>Worst Value (mm)</th>
                            <th>Category</th>
                            <th>Required Action</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="note-box">
                <strong>Limits used:</strong> 100-125 mph: ±6 (correct within 13 weeks), 65-95 mph: ±7 (within 26 weeks), 5-60 mph: ±8 (within 52 weeks).
            </div>
        </div>
    </div>
</div>

<!-- Manual Gauge Fault Modal -->
<div class="modal-overlay" id="gaugeModal">
    <div class="modal">
        <h3>Add Manual Gauge Fault</h3>
        <div class="modal-row">
            <div class="modal-field">
                <label>Start Miles</label>
                <input type="number" id="mgStartMiles" step="1" min="0" placeholder="e.g. 21">
            </div>
            <div class="modal-field">
                <label>Start Yards</label>
                <input type="number" id="mgStartYards" step="0.1" min="0" placeholder="e.g. 1160.0">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>End Miles</label>
                <input type="number" id="mgEndMiles" step="1" min="0" placeholder="e.g. 21">
            </div>
            <div class="modal-field">
                <label>End Yards</label>
                <input type="number" id="mgEndYards" step="0.1" min="0" placeholder="e.g. 1165.0">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>Worst Gauge (mm)</label>
                <input type="number" id="mgWorstGauge" step="0.1" placeholder="e.g. 1450.5">
            </div>
            <div class="modal-field">
                <label>Fault Type</label>
                <select id="mgFaultDirection">
                    <option value="wide">Wide Gauge</option>
                    <option value="tight">Tight Gauge</option>
                </select>
            </div>
        </div>
        <div class="modal-field">
            <label>Fault No. (optional)</label>
            <input type="text" id="mgFaultNo" placeholder="e.g. GF-001">
        </div>
        <div class="modal-actions">
            <button class="btn-modal-cancel" onclick="closeModal('gaugeModal')">Cancel</button>
            <button class="btn-modal-save" onclick="saveManualGaugeFault()">Add Fault</button>
        </div>
    </div>
</div>

<!-- Manual Twist Fault Modal -->
<div class="modal-overlay" id="twistModal">
    <div class="modal">
        <h3>Add Manual Twist Fault</h3>
        <div class="modal-row">
            <div class="modal-field">
                <label>Start Miles</label>
                <input type="number" id="mtStartMiles" step="1" min="0" placeholder="e.g. 21">
            </div>
            <div class="modal-field">
                <label>Start Yards</label>
                <input type="number" id="mtStartYards" step="0.1" min="0" placeholder="e.g. 1160.0">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>End Miles</label>
                <input type="number" id="mtEndMiles" step="1" min="0" placeholder="e.g. 21">
            </div>
            <div class="modal-field">
                <label>End Yards</label>
                <input type="number" id="mtEndYards" step="0.1" min="0" placeholder="e.g. 1165.0">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>Max |Twist| (mm)</label>
                <input type="number" id="mtMaxTwist" step="0.1" min="0" placeholder="e.g. 18.5">
            </div>
            <div class="modal-field">
                <label>Worst Value (mm, signed)</label>
                <input type="number" id="mtWorstValue" step="0.1" placeholder="e.g. -18.5">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>Curve Radius</label>
                <select id="mtCurveRadius">
                    <option value="gte400">&ge; 400m</option>
                    <option value="lt400">&lt; 400m</option>
                </select>
            </div>
            <div class="modal-field">
                <label>Fault No. (optional)</label>
                <input type="text" id="mtFaultNo" placeholder="e.g. TF-001">
            </div>
        </div>
        <div class="modal-actions">
            <button class="btn-modal-cancel" onclick="closeModal('twistModal')">Cancel</button>
            <button class="btn-modal-save" onclick="saveManualTwistFault()">Add Fault</button>
        </div>
    </div>
</div>


<!-- Edit Fault Modal -->
<div class="modal-overlay" id="editFaultModal">
    <div class="modal">
        <h3>Edit Fault Override</h3>
        <p style="margin-bottom: 16px; color: #666; font-size: 13px;">Override fault mileage and key values for reporting with inspector commentary.</p>
        <div class="modal-row">
            <div class="modal-field">
                <label>Start Miles</label>
                <input type="number" id="editStartMiles" step="1" min="0">
            </div>
            <div class="modal-field">
                <label>Start Yards</label>
                <input type="number" id="editStartYards" step="0.1" min="0">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>End Miles</label>
                <input type="number" id="editEndMiles" step="1" min="0">
            </div>
            <div class="modal-field">
                <label>End Yards</label>
                <input type="number" id="editEndYards" step="0.1" min="0">
            </div>
        </div>
        <div class="modal-field">
            <label id="editPrimaryLabel">Override Value (mm)</label>
            <input type="number" id="editPrimaryValue" step="0.1">
        </div>
        <div class="modal-field">
            <label>Inspector Name (optional)</label>
            <input type="text" id="editInspector" placeholder="Enter inspector name...">
        </div>
        <div class="modal-field">
            <label>Commentary (required)</label>
            <textarea id="editCommentary" rows="3" placeholder="Reason / site observation for override..."></textarea>
        </div>
        <input type="hidden" id="editFaultType">
        <input type="hidden" id="editFaultIdx">
        <div class="modal-actions">
            <button class="btn-modal-cancel" onclick="closeModal('editFaultModal')">Cancel</button>
            <button class="btn-modal-save" onclick="confirmEditFault()">Save Override</button>
        </div>
    </div>
</div>

<!-- Delete Fault Modal -->
<div class="modal-overlay" id="dismissModal">
    <div class="modal">
        <h3>Delete Fault</h3>
        <p style="margin-bottom: 16px; color: #666; font-size: 13px;">
            This fault will be removed from this run. Please provide a reason for deletion.
        </p>
        <div class="modal-field">
            <label>Inspector Name</label>
            <input type="text" id="dismissInspector" placeholder="Enter your name...">
        </div>
        <div class="modal-field">
            <label>Reason for Deletion</label>
            <input type="text" id="dismissReason" placeholder="e.g. False reading, track geometry confirmed OK on site">
        </div>
        <input type="hidden" id="dismissFaultType">
        <input type="hidden" id="dismissFaultIdx">
        <div class="modal-actions">
            <button class="btn-modal-cancel" onclick="closeModal('dismissModal')">Cancel</button>
            <button class="btn-modal-save" onclick="confirmDismissFault()">Delete Fault</button>
        </div>
    </div>
</div>

<script>
// ---- State ----
let parsedData = null;
let gaugeFaults = [];
let twistFaults = [];
let gaugeVariationFaults = [];
let metadata = {};
let gaugeChartInstances = [];
let twistChartInstances = [];
let xLevelChartInstances = [];
let gaugeVariationChartInstances = [];
let runTraceFlipped = false;
let runFlipReason = '';

// Deleted faults: keyed by "gauge-{idx}" or "twist-{idx}", stores {timestamp, comment, inspector}
let dismissedFaults = {};
let faultEdits = {};

// Manual faults (kept separate so we can tag them)
let manualGaugeFaults = [];
let manualTwistFaults = [];

// Bulk upload: store all loaded runs
let allRuns = []; // [{parsedData, metadata, filename}, ...]
let activeRunIndex = -1;

// Per-fault curve radius settings (indexed by fault index)
let twistFaultRadiusSettings = []; // true = <400m, false = >=400m

// ---- Table 3: Twist Fault Limits (3m base) ----
function classifyTwistFault(absValue, lineSpeed, curveRadiusLessThan400) {
    if (!lineSpeed || lineSpeed < 5) return null;
    const thresholds = getTwistThresholds(lineSpeed);

    // IAL - Block the line: all speeds, >= 33mm
    if (absValue >= 33) {
        return { category: 'IAL', badge: 'badge-ial', rowClass: 'cat-ial-block',
            action: 'BLOCK THE LINE - Correct before opening to traffic' };
    }

    // IAL - Correct within 36 hours
    if (absValue >= thresholds.ial && absValue < 33) {
        return { category: 'IAL', badge: 'badge-ial', rowClass: 'cat-ial',
            action: 'Correct within 36 hours' };
    }

    // IL - Curve radius < 400m (max 65mph)
    if (curveRadiusLessThan400 && lineSpeed <= 65) {
        if (absValue >= 18 && absValue < thresholds.ial) {
            return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Correct within 7 days' };
        }
        if (absValue >= thresholds.il && absValue < 18) {
            return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Correct within 10 days' };
        }
    }

    // IL - Curve radius >= 400m (or < 400m but speed > 65 falls through to these)
    if (!curveRadiusLessThan400 || lineSpeed > 65) {
        if (lineSpeed <= 75) {
            if (absValue >= 21 && absValue < thresholds.ial) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 14 days' };
            }
            if (absValue >= 18 && absValue < 21) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 21 days' };
            }
            if (absValue >= thresholds.il && absValue < 18) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 28 days' };
            }
        }
        if (lineSpeed >= 80) {
            if (absValue >= 18 && absValue < 21) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 14 days' };
            }
            if (absValue >= thresholds.il && absValue < 18) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 21 days' };
            }
        }
    }

    // AL - All speeds: 12mm to < 15mm
    if (absValue >= thresholds.al && absValue < thresholds.il) {
        return { category: 'AL', badge: 'badge-al', rowClass: 'cat-al',
            action: 'Monitor (Alert Limit)' };
    }

    return null;
}

// ---- Table 5: Gauge Fault Limits ----
function classifyGaugeFault(gaugeValue, lineSpeed, trackCat) {
    if (!lineSpeed || lineSpeed < 5) return null;
    const thresholds = getGaugeThresholds(lineSpeed);
    // Resolve track-category-dependent timescale for wide gauge IL
    const isHighCat = ['1A','1','2','3'].includes(trackCat);
    const isLowCat = ['4','5','6'].includes(trackCat);
    let wideILAction;
    if (isHighCat) wideILAction = 'Correct within 14 days (Cat ' + trackCat + ')';
    else if (isLowCat) wideILAction = 'Correct within 28 days (Cat ' + trackCat + ')';
    else wideILAction = 'Cat 1A-3: correct within 14 days; Cat 4-6: correct within 28 days';

    // --- WIDE GAUGE (gauge above nominal 1435mm) ---
    if (gaugeValue >= 1435) {

        // IAL - Block the line (Static plus dynamic movement)
        if (lineSpeed >= 105 && gaugeValue >= 1472) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial-block',
                action: 'BLOCK THE LINE - Correct before opening to traffic' };
        }
        if (lineSpeed <= 100 && gaugeValue >= 1478) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial-block',
                action: 'BLOCK THE LINE - Correct before opening to traffic' };
        }

        // IAL - Correct within 36 hours (Static plus dynamic movement)
        if (lineSpeed >= 105 && gaugeValue >= 1463 && gaugeValue < 1472) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }
        if (lineSpeed <= 100 && gaugeValue >= 1470 && gaugeValue < 1478) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }

        // IAL - Static Wide Gauge
        if (gaugeValue >= thresholds.wide.ial && gaugeValue <= 1477) {
            return { category: 'IAL', type: 'Static Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }

        // IL - Wide Gauge
        if (gaugeValue >= thresholds.wide.il && gaugeValue < thresholds.wide.ial) {
            return { category: 'IL', type: 'Wide Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: wideILAction };
        }

        // AL - Wide Gauge
        if (gaugeValue >= thresholds.wide.al && gaugeValue < thresholds.wide.il) {
            return { category: 'AL', type: 'Wide Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
    }

    // --- TIGHT GAUGE (gauge below nominal) ---
    if (gaugeValue < 1435) {

        // IAL - Tight Gauge
        if (gaugeValue <= thresholds.tight.ial) {
            return { category: 'IAL', type: 'Tight Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }

        // IL - Tight Gauge
        if (gaugeValue <= thresholds.tight.il) {
            return { category: 'IL', type: 'Tight Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Inspect within 14 days, correct within 84 days' };
        }

        // AL - Tight Gauge
        if (gaugeValue <= thresholds.tight.al) {
            return { category: 'AL', type: 'Tight Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
    }

    return null;
}

// Get the detection thresholds for gauge based on line speed
function getTrackCat() {
    return document.getElementById('trackCatInput').value || '';
}

function getGaugeThresholds(lineSpeed) {
    const overrides = getOverrideSettings();
    const defaults = {
        wide: {
            al: 1445,
            il: 1450,
            ial: lineSpeed > 25 ? 1458 : 1460
        },
        tight: {
            al: lineSpeed >= 105 ? 1430 : 1426,
            il: lineSpeed >= 105 ? 1428 : 1424,
            ial: lineSpeed >= 105 ? 1426 : 1422
        }
    };
    if (!overrides.enabled) return defaults;
    return {
        wide: {
            al: Number.isFinite(overrides.gaugeWideAL) ? overrides.gaugeWideAL : defaults.wide.al,
            il: Number.isFinite(overrides.gaugeWideIL) ? overrides.gaugeWideIL : defaults.wide.il,
            ial: Number.isFinite(overrides.gaugeWideIAL) ? overrides.gaugeWideIAL : defaults.wide.ial
        },
        tight: {
            al: Number.isFinite(overrides.gaugeTightAL) ? overrides.gaugeTightAL : defaults.tight.al,
            il: Number.isFinite(overrides.gaugeTightIL) ? overrides.gaugeTightIL : defaults.tight.il,
            ial: Number.isFinite(overrides.gaugeTightIAL) ? overrides.gaugeTightIAL : defaults.tight.ial
        }
    };
}

function getTwistThresholds(lineSpeed) {
    const overrides = getOverrideSettings();
    const defaults = {
        al: 12,
        il: 15,
        ial: lineSpeed >= 80 ? 21 : 24
    };
    if (!overrides.enabled) return defaults;
    return {
        al: Number.isFinite(overrides.twistAL) ? overrides.twistAL : defaults.al,
        il: Number.isFinite(overrides.twistIL) ? overrides.twistIL : defaults.il,
        ial: Number.isFinite(overrides.twistIAL) ? overrides.twistIAL : defaults.ial
    };
}

function getGaugeDetectionThresholds(lineSpeed) {
    const thresholds = getGaugeThresholds(lineSpeed);
    return { tightBelow: thresholds.tight.al, wideAbove: thresholds.wide.al };
}

// Get the detection threshold for twist (lowest AL = 12mm)
function getTwistDetectionThreshold() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    return getTwistThresholds(lineSpeed).al;
}

// ---- Upload (supports bulk / multiple files) ----
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');

dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    if (e.dataTransfer.files.length) handleFiles(e.dataTransfer.files);
});
fileInput.addEventListener('change', e => { if (e.target.files.length) handleFiles(e.target.files); });

function handleFiles(files) {
    const fileArray = Array.from(files);
    let loaded = 0;
    const errors = [];

    fileArray.forEach(file => {
        const reader = new FileReader();
        reader.onload = e => {
            try {
                const content = e.target.result;
                const result = parseDataForRun(content);
                allRuns.push({
                    parsedData: result.data,
                    metadata: result.meta,
                    filename: file.name,
                    traceFlipped: result.traceFlipped || false,
                    flipReason: result.flipReason || '',
                    manualGaugeFaults: [],
                    manualTwistFaults: [],
                    dismissedFaults: {},
                    faultEdits: {},
                    settings: {
                        runName: '',
                        inspector: '',
                        lineSpeed: '',
                        trackCat: ''
                    },
                    overrides: {
                        enabled: false,
                        gaugeWideAL: '',
                        gaugeWideIL: '',
                        gaugeWideIAL: '',
                        gaugeTightAL: '',
                        gaugeTightIL: '',
                        gaugeTightIAL: '',
                        twistAL: '',
                        twistIL: '',
                        twistIAL: ''
                    }
                });
            } catch (err) {
                errors.push(file.name + ': ' + err.message);
            }
            loaded++;
            if (loaded === fileArray.length) {
                onAllFilesLoaded(errors);
            }
        };
        reader.readAsText(file);
    });
}

function normalizeHeaderLabel(label) {
    return (label || '').toLowerCase().replace(/\s+/g, ' ').trim();
}

function buildHeaderMap(cells) {
    const map = {};
    cells.forEach((cell, idx) => {
        const label = normalizeHeaderLabel(cell);
        if (label === 'miles' && map.miles === undefined) map.miles = idx;
        if (label === 'yards' && map.yards === undefined) map.yards = idx;
        if ((label.includes('gauge delta') || (label.startsWith('gauge') && label.includes('delta'))) && map.gaugeDelta === undefined) {
            map.gaugeDelta = idx;
        }
        if (label.startsWith('gauge') && !label.includes('delta') && !label.includes('x-level') && map.gauge === undefined) {
            map.gauge = idx;
        }
        if (label.startsWith('x-level') && map.xlevel === undefined) map.xlevel = idx;
        if (label.startsWith('twist 1') && map.twist1 === undefined) map.twist1 = idx;
        if (label.startsWith('twist 2') && map.twist2 === undefined) map.twist2 = idx;
        if (label.startsWith('gps') && map.gps === undefined) map.gps = idx;
        if ((label.includes('zone reference') || label.includes('default zones') || label === 'zone' || label.startsWith('zone ')) && map.zone === undefined) {
            map.zone = idx;
        }
    });
    return map;
}

function parseDataForRun(content) {
    let lines;
    if (content.includes('<table') || content.includes('<TABLE')) {
        lines = parseHTMLTable(content);
    } else {
        lines = content.split('\n').map(l => l.trim()).filter(l => l);
    }

    const meta = {};
    const dataRows = [];
    let headerFound = false;
    let headerMap = null;

    for (let i = 0; i < lines.length; i++) {
        const line = typeof lines[i] === 'string' ? lines[i] : lines[i].join('\t');
        const cells = typeof lines[i] === 'string'
            ? line.split('\t').map(c => c.trim())
            : lines[i].map(c => (c || '').trim());

        if (!headerFound && cells[0] === 'Miles' && cells[1] === 'Yards') {
            headerFound = true;
            headerMap = buildHeaderMap(cells);
            continue;
        }

        if (!headerFound) {
            if (cells.length >= 2 && cells[0] && cells[1]) {
                meta[cells[0]] = cells[1];
            } else if (cells.length === 1 && cells[0].includes('\t')) {
                const parts = cells[0].split('\t');
                if (parts.length >= 2) meta[parts[0].trim()] = parts[1].trim();
            }
            if (typeof lines[i] === 'string' && !cells[1] && line.includes('\t')) {
                const parts = line.split('\t');
                if (parts.length >= 2 && parts[0].trim()) {
                    meta[parts[0].trim()] = parts[1].trim();
                }
            }
            continue;
        }

        if (headerFound && cells[0] && !isNaN(parseFloat(cells[0]))) {
            const getCell = (key, fallbackIdx) => {
                if (headerMap && Number.isFinite(headerMap[key])) {
                    return cells[headerMap[key]];
                }
                return cells[fallbackIdx];
            };
            const milesCell = getCell('miles', 0);
            const yardsCell = getCell('yards', 1);
            const row = {
                miles: parseFloat(milesCell),
                yards: parseFloat(yardsCell),
                gauge: parseFloat(getCell('gauge', 2)),
                xlevel: parseFloat(getCell('xlevel', 3)),
                twist1: (() => {
                    const cell = getCell('twist1', 4);
                    return cell !== '' && cell !== undefined ? parseFloat(cell) : null;
                })(),
                twist2: (() => {
                    const cell = getCell('twist2', 5);
                    return cell !== '' && cell !== undefined ? parseFloat(cell) : null;
                })(),
                gaugeDelta: (() => {
                    const cell = getCell('gaugeDelta', null);
                    return cell !== '' && cell !== undefined && cell !== null ? parseFloat(cell) : null;
                })(),
                zone: getCell('zone', 7) || getCell('zone', 6) || ''
            };
            if (!isNaN(row.miles) && !isNaN(row.yards) && !isNaN(row.gauge)) {
                row.location = row.miles + 'mi ' + row.yards.toFixed(0) + 'yds';
                dataRows.push(row);
            }
        }
    }

    if (dataRows.length === 0) {
        throw new Error('No measurement data rows found. Check file format.');
    }

    const normalized = normalizeRunData(dataRows, meta);
    return { data: normalized.data, meta: meta, traceFlipped: normalized.flipped, flipReason: normalized.reason };
}

function normalizeRunData(dataRows, meta) {
    if (!dataRows.length) return { data: dataRows, flipped: false, reason: '' };
    const direction = (meta['Direction Of Travel'] || '').toLowerCase();
    const metaDecrement = direction.includes('decrement');
    const firstPos = dataRows[0].miles * 1760 + dataRows[0].yards;
    const lastPos = dataRows[dataRows.length - 1].miles * 1760 + dataRows[dataRows.length - 1].yards;
    const isDescending = firstPos > lastPos;
    if (!metaDecrement && !isDescending) {
        return { data: dataRows, flipped: false, reason: '' };
    }
    const flippedData = dataRows.slice().reverse().map(row => ({
        ...row,
        twist1: Number.isFinite(row.twist1) ? -row.twist1 : row.twist1,
        twist2: Number.isFinite(row.twist2) ? -row.twist2 : row.twist2,
        xlevel: Number.isFinite(row.xlevel) ? -row.xlevel : row.xlevel
    }));
    const reasonParts = [];
    if (metaDecrement) reasonParts.push('Direction Of Travel: Decrement');
    if (isDescending && !metaDecrement) reasonParts.push('mileage descending');
    return { data: flippedData, flipped: true, reason: reasonParts.join('; ') };
}

function onAllFilesLoaded(errors) {
    if (errors.length > 0 && allRuns.length === 0) {
        alert('Failed to parse files:\n' + errors.join('\n'));
        return;
    }
    if (errors.length > 0) {
        alert('Some files had errors:\n' + errors.join('\n') + '\n\nSuccessfully loaded ' + allRuns.length + ' run(s).');
    }

    // Show run selector if multiple runs
    updateRunSelector();
    switchRun(0);

    document.getElementById('uploadScreen').style.display = 'none';
    document.getElementById('reportContainer').classList.add('active');
}

function updateRunSelector() {
    const bar = document.getElementById('runSelectorBar');
    const sel = document.getElementById('runSelector');
    const countEl = document.getElementById('runCount');

    if (allRuns.length > 1) {
        bar.style.display = 'flex';
        sel.innerHTML = allRuns.map((run, i) => {
            const label = run.metadata['Route ID']
                ? run.metadata['Route ID'] + ' / ' + (run.metadata['Track ID'] || '') + ' (' + run.filename + ')'
                : run.filename;
            return `<option value="${i}">${label}</option>`;
        }).join('');
        countEl.textContent = allRuns.length + ' runs loaded';
    } else {
        bar.style.display = 'none';
    }
}

function switchRun(index) {
    index = parseInt(index);
    activeRunIndex = index;
    const run = allRuns[index];
    parsedData = run.parsedData;
    metadata = run.metadata;
    runTraceFlipped = run.traceFlipped || false;
    runFlipReason = run.flipReason || '';
    manualGaugeFaults = run.manualGaugeFaults;
    manualTwistFaults = run.manualTwistFaults;
    dismissedFaults = run.dismissedFaults || {};
    faultEdits = run.faultEdits || {};
    applyOverrideSettings(run.overrides || {});

    const savedSettings = run.settings || {};
    document.getElementById('runNameInput').value = savedSettings.runName || '';
    document.getElementById('inspectorInput').value = savedSettings.inspector || '';

    const savedLineSpeed = parseInt(savedSettings.lineSpeed, 10);
    if (Number.isFinite(savedLineSpeed) && savedLineSpeed >= 5) {
        document.getElementById('lineSpeedInput').value = savedLineSpeed;
    } else {
        const derivedSpeed = getLineSpeedFromZones(parsedData);
        document.getElementById('lineSpeedInput').value = Number.isFinite(derivedSpeed) ? derivedSpeed : '';
    }
    document.getElementById('trackCatInput').value = savedSettings.trackCat || '';

    document.getElementById('runSelector').value = index;
    identifyFaults();
    buildReport();
}

function handleFile(file) {
    handleFiles([file]);
}

// ---- Parsing ----
function parseData(content) {
    const result = parseDataForRun(content);
    parsedData = result.data;
    metadata = result.meta;
    runTraceFlipped = result.traceFlipped || false;
    runFlipReason = result.flipReason || '';
    identifyFaults();
}

function parseHTMLTable(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const rows = doc.querySelectorAll('tr');
    const result = [];
    rows.forEach(row => {
        const cells = [];
        row.querySelectorAll('td, th').forEach(cell => cells.push(cell.textContent.trim()));
        if (cells.length > 0) result.push(cells);
    });
    return result;
}

function formatLocation(row) {
    return row.miles + 'mi ' + row.yards.toFixed(0) + 'yds';
}

function parseZoneSpeedValue(zoneText) {
    if (!zoneText) return null;
    const rangeMatch = zoneText.match(/(\d+)\s*-\s*(\d+)\s*mph/i);
    if (rangeMatch) return parseInt(rangeMatch[2], 10);
    const singleMatch = zoneText.match(/(\d+)\s*mph/i);
    if (singleMatch) return parseInt(singleMatch[1], 10);
    return null;
}

function getLineSpeedFromZones(data) {
    const counts = new Map();
    data.forEach(row => {
        const speed = parseZoneSpeedValue(row.zone);
        if (!Number.isFinite(speed)) return;
        counts.set(speed, (counts.get(speed) || 0) + 1);
    });
    if (counts.size === 0) return null;
    let bestSpeed = null;
    let bestCount = -1;
    counts.forEach((count, speed) => {
        if (count > bestCount) {
            bestCount = count;
            bestSpeed = speed;
        }
    });
    return bestSpeed;
}

// ---- Fault Identification ----
function identifyFaults() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    identifyGaugeFaults(lineSpeed);
    identifyTwistFaults();
    identifyGaugeVariationFaults(lineSpeed);
}

function classifyGaugeVariationFault(absDelta, lineSpeed) {
    if (!lineSpeed || lineSpeed < 5 || !Number.isFinite(absDelta)) return null;
    if (lineSpeed >= 100 && lineSpeed <= 125 && absDelta >= 6) {
        return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il', action: 'Correct within 13 weeks', threshold: 6 };
    }
    if (lineSpeed >= 65 && lineSpeed <= 95 && absDelta >= 7) {
        return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il', action: 'Correct within 26 weeks', threshold: 7 };
    }
    if (lineSpeed >= 5 && lineSpeed <= 60 && absDelta >= 8) {
        return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il', action: 'Correct within 52 weeks', threshold: 8 };
    }
    return null;
}

function getGaugeVariationThreshold(lineSpeed) {
    const classification = classifyGaugeVariationFault(999, lineSpeed);
    return classification ? classification.threshold : null;
}

function identifyGaugeFaults(lineSpeed) {
    gaugeFaults = [];
    const thresholds = getGaugeDetectionThresholds(lineSpeed);
    let inFault = false;
    let currentFault = null;

    for (let i = 0; i < parsedData.length; i++) {
        const row = parsedData[i];
        const isTight = row.gauge <= thresholds.tightBelow;
        const isWide = row.gauge >= thresholds.wideAbove;
        const isFault = isTight || isWide;

        if (isFault) {
            if (!inFault) {
                currentFault = {
                    startIdx: i,
                    startLocation: formatLocation(row),
                    startMiles: row.miles,
                    startYards: row.yards,
                    worstGauge: row.gauge,
                    direction: isWide ? 'wide' : 'tight',
                    rows: [row]
                };
                inFault = true;
            } else {
                currentFault.rows.push(row);
                if (currentFault.direction === 'wide') {
                    if (row.gauge > currentFault.worstGauge) currentFault.worstGauge = row.gauge;
                } else {
                    if (row.gauge < currentFault.worstGauge) currentFault.worstGauge = row.gauge;
                }
            }
        } else {
            if (inFault) {
                finishGaugeFault(currentFault);
                gaugeFaults.push(currentFault);
                inFault = false;
                currentFault = null;
            }
        }
    }
    if (inFault) {
        finishGaugeFault(currentFault);
        gaugeFaults.push(currentFault);
    }
}

function finishGaugeFault(fault) {
    const lastRow = fault.rows[fault.rows.length - 1];
    fault.endLocation = formatLocation(lastRow);
    fault.endMiles = lastRow.miles;
    fault.endYards = lastRow.yards;
    fault.length = (fault.endYards - fault.startYards).toFixed(1);
    if (fault.direction === 'wide') {
        fault.deviation = '+' + (fault.worstGauge - 1435).toFixed(1);
    } else {
        fault.deviation = '-' + (1435 - fault.worstGauge).toFixed(1);
    }
}

function identifyTwistFaults() {
    const threshold = getTwistDetectionThreshold();
    twistFaults = [];
    twistFaultRadiusSettings = [];
    let inFault = false;
    let currentFault = null;

    for (let i = 0; i < parsedData.length; i++) {
        const row = parsedData[i];
        const hasTwist = row.twist1 !== null && !isNaN(row.twist1) &&
            Math.abs(row.twist1) >= threshold;

        if (hasTwist) {
            if (!inFault) {
                currentFault = {
                    startIdx: i,
                    startLocation: formatLocation(row),
                    startMiles: row.miles,
                    startYards: row.yards,
                    maxAbsTwist: Math.abs(row.twist1),
                    worstValue: row.twist1,
                    rows: [row]
                };
                inFault = true;
            } else {
                currentFault.rows.push(row);
                if (Math.abs(row.twist1) > currentFault.maxAbsTwist) {
                    currentFault.maxAbsTwist = Math.abs(row.twist1);
                    currentFault.worstValue = row.twist1;
                }
            }
        } else {
            if (inFault) {
                const lastRow = currentFault.rows[currentFault.rows.length - 1];
                currentFault.endLocation = formatLocation(lastRow);
                currentFault.endMiles = lastRow.miles;
                currentFault.endYards = lastRow.yards;
                currentFault.length = (currentFault.endYards - currentFault.startYards).toFixed(1);
                twistFaults.push(currentFault);
                twistFaultRadiusSettings.push(false); // default: >= 400m
                inFault = false;
                currentFault = null;
            }
        }
    }
    if (inFault) {
        const lastRow = currentFault.rows[currentFault.rows.length - 1];
        currentFault.endLocation = formatLocation(lastRow);
        currentFault.endMiles = lastRow.miles;
        currentFault.endYards = lastRow.yards;
        currentFault.length = (currentFault.endYards - currentFault.startYards).toFixed(1);
        twistFaults.push(currentFault);
        twistFaultRadiusSettings.push(false);
    }
}

function identifyGaugeVariationFaults(lineSpeed) {
    gaugeVariationFaults = [];
    const threshold = getGaugeVariationThreshold(lineSpeed);
    if (!threshold) return;

    let inFault = false;
    let currentFault = null;

    for (let i = 0; i < parsedData.length; i++) {
        const row = parsedData[i];
        const delta = Number.isFinite(row.gaugeDelta) ? row.gaugeDelta : null;
        const isFault = delta !== null && Math.abs(delta) >= threshold;

        if (isFault) {
            if (!inFault) {
                currentFault = {
                    startIdx: i,
                    startLocation: formatLocation(row),
                    startMiles: row.miles,
                    startYards: row.yards,
                    maxAbsGaugeDelta: Math.abs(delta),
                    worstGaugeDelta: delta,
                    rows: [row]
                };
                inFault = true;
            } else {
                currentFault.rows.push(row);
                if (Math.abs(delta) > currentFault.maxAbsGaugeDelta) {
                    currentFault.maxAbsGaugeDelta = Math.abs(delta);
                    currentFault.worstGaugeDelta = delta;
                }
            }
        } else if (inFault) {
            const lastRow = currentFault.rows[currentFault.rows.length - 1];
            currentFault.endLocation = formatLocation(lastRow);
            currentFault.endMiles = lastRow.miles;
            currentFault.endYards = lastRow.yards;
            currentFault.length = (currentFault.endYards - currentFault.startYards).toFixed(1);
            gaugeVariationFaults.push(currentFault);
            inFault = false;
            currentFault = null;
        }
    }

    if (inFault) {
        const lastRow = currentFault.rows[currentFault.rows.length - 1];
        currentFault.endLocation = formatLocation(lastRow);
        currentFault.endMiles = lastRow.miles;
        currentFault.endYards = lastRow.yards;
        currentFault.length = (currentFault.endYards - currentFault.startYards).toFixed(1);
        gaugeVariationFaults.push(currentFault);
    }
}

// ---- Build Report ----
function buildReport() {
    const route = metadata['Route ID'] || '';
    const track = metadata['Track ID'] || '';
    document.getElementById('reportTitle').textContent =
        'Track Inspection Report' + (route ? ' - ' + route : '') + (track ? ' / ' + track : '');

    // Metadata
    const metaGrid = document.getElementById('metaGrid');
    metaGrid.innerHTML = '';
    const flipNotice = document.getElementById('flipNotice');
    const displayKeys = [
        'Operator ID', 'Profile', 'Start Location', 'End Location',
        'Direction Of Travel', 'Job Reference', 'Route ID', 'Track ID',
        'Start Time', 'End Time', 'Serial Number', 'Reference Gauge',
        'Calibrated', 'Twist Base 1', 'Software Version', 'Acquisition Rate'
    ];
    displayKeys.forEach(key => {
        if (metadata[key]) {
            metaGrid.innerHTML += `<div class="meta-item"><span class="label">${key}</span><span class="value">${metadata[key]}</span></div>`;
        }
    });
    if (runTraceFlipped) {
        const isDecrement = runFlipReason.toLowerCase().includes('direction of travel');
        const reasonText = runFlipReason ? ` (${runFlipReason})` : '';
        const captureText = isDecrement ? 'captured in Decrement mode' : 'captured with decreasing mileage';
        flipNotice.textContent = `Note: This run was ${captureText} and has been flipped to display low-to-high mileage${reasonText}. Twist and cant values have been inverted to preserve right/left orientation.`;
        flipNotice.style.display = 'block';
    } else {
        flipNotice.textContent = '';
        flipNotice.style.display = 'none';
    }

    updateSummaryStats();
    buildCharts();
    buildSchematic();
    buildGaugeFaultTable();
    buildTwistFaultTable();
    buildGaugeVariationFaultTable();
    buildInvalidatedFaultTable();
    updateSpeedWarning();
    updateComparison();

    // Tab handling
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById('page-' + tab.dataset.page).classList.add('active');
        });
    });

    // Line speed + track cat change handlers
    document.getElementById('lineSpeedInput').addEventListener('change', onLineSpeedChange);
    document.getElementById('lineSpeedInput').addEventListener('input', onLineSpeedChange);
    document.getElementById('trackCatInput').addEventListener('change', onLineSpeedChange);
    document.getElementById('runNameInput').addEventListener('input', persistRunSettings);
    document.getElementById('inspectorInput').addEventListener('input', persistRunSettings);
    document.getElementById('overrideToggle').addEventListener('change', onOverrideChange);
    [
        'overrideGaugeWideAL', 'overrideGaugeWideIL', 'overrideGaugeWideIAL',
        'overrideGaugeTightAL', 'overrideGaugeTightIL', 'overrideGaugeTightIAL',
        'overrideTwistAL', 'overrideTwistIL', 'overrideTwistIAL'
    ].forEach(id => document.getElementById(id).addEventListener('input', onOverrideChange));
}

function applyOverrideSettings(overrides) {
    document.getElementById('overrideToggle').checked = !!overrides.enabled;
    document.getElementById('overrideGaugeWideAL').value = overrides.gaugeWideAL ?? '';
    document.getElementById('overrideGaugeWideIL').value = overrides.gaugeWideIL ?? '';
    document.getElementById('overrideGaugeWideIAL').value = overrides.gaugeWideIAL ?? '';
    document.getElementById('overrideGaugeTightAL').value = overrides.gaugeTightAL ?? '';
    document.getElementById('overrideGaugeTightIL').value = overrides.gaugeTightIL ?? '';
    document.getElementById('overrideGaugeTightIAL').value = overrides.gaugeTightIAL ?? '';
    document.getElementById('overrideTwistAL').value = overrides.twistAL ?? '';
    document.getElementById('overrideTwistIL').value = overrides.twistIL ?? '';
    document.getElementById('overrideTwistIAL').value = overrides.twistIAL ?? '';
}

function getOverrideSettings() {
    return {
        enabled: document.getElementById('overrideToggle').checked,
        gaugeWideAL: parseFloat(document.getElementById('overrideGaugeWideAL').value),
        gaugeWideIL: parseFloat(document.getElementById('overrideGaugeWideIL').value),
        gaugeWideIAL: parseFloat(document.getElementById('overrideGaugeWideIAL').value),
        gaugeTightAL: parseFloat(document.getElementById('overrideGaugeTightAL').value),
        gaugeTightIL: parseFloat(document.getElementById('overrideGaugeTightIL').value),
        gaugeTightIAL: parseFloat(document.getElementById('overrideGaugeTightIAL').value),
        twistAL: parseFloat(document.getElementById('overrideTwistAL').value),
        twistIL: parseFloat(document.getElementById('overrideTwistIL').value),
        twistIAL: parseFloat(document.getElementById('overrideTwistIAL').value)
    };
}

function onOverrideChange() {
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        const overrides = getOverrideSettings();
        allRuns[activeRunIndex].overrides = {
            enabled: overrides.enabled,
            gaugeWideAL: Number.isFinite(overrides.gaugeWideAL) ? overrides.gaugeWideAL : '',
            gaugeWideIL: Number.isFinite(overrides.gaugeWideIL) ? overrides.gaugeWideIL : '',
            gaugeWideIAL: Number.isFinite(overrides.gaugeWideIAL) ? overrides.gaugeWideIAL : '',
            gaugeTightAL: Number.isFinite(overrides.gaugeTightAL) ? overrides.gaugeTightAL : '',
            gaugeTightIL: Number.isFinite(overrides.gaugeTightIL) ? overrides.gaugeTightIL : '',
            gaugeTightIAL: Number.isFinite(overrides.gaugeTightIAL) ? overrides.gaugeTightIAL : '',
            twistAL: Number.isFinite(overrides.twistAL) ? overrides.twistAL : '',
            twistIL: Number.isFinite(overrides.twistIL) ? overrides.twistIL : '',
            twistIAL: Number.isFinite(overrides.twistIAL) ? overrides.twistIAL : ''
        };
    }
    onLineSpeedChange();
}

function onLineSpeedChange() {
    persistRunSettings();
    identifyFaults();
    updateSummaryStats();
    buildGaugeFaultTable();
    buildTwistFaultTable();
    buildGaugeVariationFaultTable();
    buildInvalidatedFaultTable();
    buildCharts();
    buildSchematic();
    updateSpeedWarning();
}

function persistRunSettings() {
    if (activeRunIndex < 0 || !allRuns[activeRunIndex]) return;
    const speedInput = document.getElementById('lineSpeedInput').value;
    const speed = parseInt(speedInput, 10);
    allRuns[activeRunIndex].settings = {
        runName: document.getElementById('runNameInput').value.trim(),
        inspector: document.getElementById('inspectorInput').value.trim(),
        lineSpeed: Number.isFinite(speed) ? speed : '',
        trackCat: getTrackCat()
    };
}

function getVisibleGaugeFaults() {
    return gaugeFaults.concat(manualGaugeFaults).filter((_, idx) => !isDismissed('gauge', idx));
}

function getVisibleTwistFaults() {
    return twistFaults.concat(manualTwistFaults).filter((_, idx) => !isDismissed('twist', idx));
}

function getFaultByTypeAndIndex(faultType, idx) {
    if (faultType === 'gauge') {
        const allGaugeFaults = gaugeFaults.concat(manualGaugeFaults);
        return allGaugeFaults[idx] || null;
    }
    if (faultType === 'twist') {
        const allTwistFaults = twistFaults.concat(manualTwistFaults);
        return allTwistFaults[idx] || null;
    }
    return null;
}

function getInvalidatedFaultRows() {
    return Object.entries(dismissedFaults)
        .map(([key, info]) => {
            const [faultType, idxText] = key.split('-');
            const idx = parseInt(idxText, 10);
            const sourceFault = getFaultByTypeAndIndex(faultType, idx);
            const effective = sourceFault ? getEffectiveFault(faultType, idx, sourceFault) : null;
            const valueText = faultType === 'gauge'
                ? (effective && Number.isFinite(effective.worstGauge) ? effective.worstGauge.toFixed(1) + ' mm' : '--')
                : (effective && Number.isFinite(effective.maxAbsTwist) ? effective.maxAbsTwist.toFixed(1) + ' mm' : '--');
            const locationText = effective
                ? (effective.startLocation + ' - ' + effective.endLocation)
                : (info.startLocation && info.endLocation ? info.startLocation + ' - ' + info.endLocation : '--');
            return {
                key,
                faultType,
                idx,
                typeLabel: faultType === 'gauge' ? 'Gauge' : 'Twist',
                locationText,
                valueText,
                removedBy: info.inspector || 'Unknown',
                removedAt: info.displayTime || '',
                reason: info.comment || '',
                timestamp: info.timestamp || ''
            };
        })
        .sort((a, b) => (a.timestamp || '').localeCompare(b.timestamp || ''));
}

function buildInvalidatedFaultTable() {
    const tbody = document.querySelector('#invalidatedFaultTable tbody');
    if (!tbody) return;
    const rows = getInvalidatedFaultRows();
    if (rows.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" style="text-align:center;padding:24px;color:#888;">No invalidated faults</td></tr>';
        return;
    }
    tbody.innerHTML = rows.map((row, i) => `
        <tr>
            <td>${i + 1}</td>
            <td>${row.typeLabel}</td>
            <td>${row.locationText}</td>
            <td>${row.valueText}</td>
            <td>${row.removedBy}</td>
            <td>${row.removedAt}</td>
            <td style="max-width:320px;">${row.reason}</td>
            <td><button class="btn-restore-fault" onclick="restoreFault('${row.faultType}', ${row.idx})">Restore</button></td>
        </tr>
    `).join('');
}

function updateSpeedWarning() {
    const speed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const warning = document.getElementById('speedWarning');
    if (speed < 5) {
        warning.classList.add('visible');
    } else {
        warning.classList.remove('visible');
    }
}

function updateSummaryStats() {
    const statsDiv = document.getElementById('summaryStats');
    const totalPoints = parsedData.length;
    const minGauge = Math.min(...parsedData.map(r => r.gauge));
    const maxGauge = Math.max(...parsedData.map(r => r.gauge));
    const twistValues = parsedData.filter(r => r.twist1 !== null).map(r => r.twist1);
    const maxTwist = twistValues.length ? Math.max(...twistValues.map(v => Math.abs(v))) : 0;
    const gaugeDeltaValues = parsedData.filter(r => Number.isFinite(r.gaugeDelta)).map(r => r.gaugeDelta);
    const maxGaugeVariation = gaugeDeltaValues.length ? Math.max(...gaugeDeltaValues.map(v => Math.abs(v))) : 0;

    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const allGaugeFaults = getVisibleGaugeFaults();
    const allTwistFaults = getVisibleTwistFaults();
    const ialGauge = allGaugeFaults.filter(f => { const c = classifyGaugeFault(f.worstGauge, lineSpeed, getTrackCat()); return c && c.category === 'IAL'; }).length;
    const ialTwist = allTwistFaults.filter((f, i) => {
        const isManual = i >= twistFaults.length;
        const radius = isManual ? f.curveRadiusLessThan400 : twistFaultRadiusSettings[i];
        const c = classifyTwistFault(f.maxAbsTwist, lineSpeed, radius);
        return c && c.category === 'IAL';
    }).length;

    const totalGauge = allGaugeFaults.length;
    const totalTwist = allTwistFaults.length;
    const totalGaugeVariation = gaugeVariationFaults.length;

    statsDiv.innerHTML = `
        <div class="stat-card"><div class="number">${totalPoints}</div><div class="label">Data Points</div></div>
        <div class="stat-card ${totalGauge > 0 ? 'danger' : ''}"><div class="number">${totalGauge}</div><div class="label">Gauge Faults${manualGaugeFaults.length > 0 ? ' (' + manualGaugeFaults.length + ' manual)' : ''}</div></div>
        <div class="stat-card ${totalTwist > 0 ? 'warning' : ''}"><div class="number">${totalTwist}</div><div class="label">Twist Faults${manualTwistFaults.length > 0 ? ' (' + manualTwistFaults.length + ' manual)' : ''}</div></div>
        <div class="stat-card ${ialGauge + ialTwist > 0 ? 'danger' : ''}"><div class="number">${ialGauge + ialTwist}</div><div class="label">IAL Faults</div></div>
        <div class="stat-card ${totalGaugeVariation > 0 ? 'warning' : ''}"><div class="number">${totalGaugeVariation}</div><div class="label">Gauge Variation Faults</div></div>
        <div class="stat-card"><div class="number">${minGauge.toFixed(1)}</div><div class="label">Min Gauge (mm)</div></div>
        <div class="stat-card"><div class="number">${maxTwist.toFixed(1)}</div><div class="label">Max |Twist| (mm)</div></div>
        <div class="stat-card"><div class="number">${maxGaugeVariation.toFixed(1)}</div><div class="label">Max |Gauge Delta| (mm)</div></div>
    `;
}

// ---- Chart threshold helpers ----
function getGaugeChartThresholds(lineSpeed) {
    const lines = [];
    const gaugeThresholds = getGaugeThresholds(lineSpeed);
    // Reference
    lines.push({ value: 1435, label: 'Reference (1435)', color: '#666', dash: [6, 4], width: 1 });

    // Wide gauge thresholds
    lines.push({ value: gaugeThresholds.wide.al, label: `Wide AL (${gaugeThresholds.wide.al})`, color: '#28a745', dash: [4, 4], width: 1 });
    lines.push({ value: gaugeThresholds.wide.il, label: `Wide IL (${gaugeThresholds.wide.il})`, color: '#e67e22', dash: [5, 3], width: 1 });
    lines.push({ value: gaugeThresholds.wide.ial, label: `Wide IAL (${gaugeThresholds.wide.ial})`, color: '#c0392b', dash: [6, 3], width: 1.5 });

    if (lineSpeed >= 105) {
        lines.push({ value: 1472, label: 'Block Line (1472)', color: '#721c24', dash: [8, 4], width: 2, hidden: true });
    } else if (lineSpeed >= 5) {
        lines.push({ value: 1478, label: 'Block Line (1478)', color: '#721c24', dash: [8, 4], width: 2, hidden: true });
    }

    // Tight gauge thresholds
    lines.push({ value: gaugeThresholds.tight.al, label: `Tight AL (${gaugeThresholds.tight.al})`, color: '#28a745', dash: [4, 4], width: 1 });
    lines.push({ value: gaugeThresholds.tight.il, label: `Tight IL (${gaugeThresholds.tight.il})`, color: '#e67e22', dash: [5, 3], width: 1 });
    lines.push({ value: gaugeThresholds.tight.ial, label: `Tight IAL (${gaugeThresholds.tight.ial})`, color: '#c0392b', dash: [6, 3], width: 1.5 });

    return lines;
}

function getTwistChartThresholds(lineSpeed) {
    const lines = [];
    const twistThresholds = getTwistThresholds(lineSpeed);
    lines.push({ value: twistThresholds.al, label: `AL (${twistThresholds.al}mm)`, color: '#28a745', dash: [4, 4], width: 1 });
    lines.push({ value: twistThresholds.il, label: `IL (${twistThresholds.il}mm)`, color: '#e67e22', dash: [5, 3], width: 1 });
    lines.push({ value: twistThresholds.ial, label: `IAL (${twistThresholds.ial}mm)`, color: '#c0392b', dash: [6, 3], width: 1.5 });
    // Block line: 33mm
    lines.push({ value: 33, label: 'Block (33mm)', color: '#721c24', dash: [8, 4], width: 2 });
    return lines;
}

function splitDataByYards(data, segmentLength) {
    if (!data.length) return [];
    const positions = data.map(r => r.miles * 1760 + r.yards);
    const minPos = Math.min(...positions);
    const segments = [];
    data.forEach((row, idx) => {
        const pos = positions[idx];
        const segmentIndex = Math.floor((pos - minPos) / segmentLength);
        if (!segments[segmentIndex]) {
            segments[segmentIndex] = { rows: [] };
        }
        segments[segmentIndex].rows.push(row);
    });
    return segments.map((segment, index) => {
        const rows = segment.rows;
        return {
            rows,
            index,
            startLabel: rows.length ? formatLocation(rows[0]) : '',
            endLabel: rows.length ? formatLocation(rows[rows.length - 1]) : ''
        };
    }).filter(segment => segment.rows.length);
}

function buildPreviousTraceSeries(rows, field) {
    if (!previousRunData || !previousRunTraceEnabled || !Array.isArray(previousRunData.traceData)) {
        return null;
    }
    if (!previousRunData.traceLookup) {
        buildPreviousTraceLookup();
    }
    const data = rows.map(row => {
        const pos = row.miles * 1760 + row.yards;
        const prev = getPreviousTraceAtPosition(pos);
        if (!prev || prev[field] === undefined || prev[field] === null) return null;
        return prev[field];
    });
    const hasData = data.some(value => value !== null);
    return hasData ? data : null;
}

function buildCharts() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const segments = splitDataByYards(parsedData, 440);
    const gaugeContainer = document.getElementById('gaugeCharts');
    const twistContainer = document.getElementById('twistCharts');
    const xLevelContainer = document.getElementById('xlevelCharts');
    const gaugeVariationContainer = document.getElementById('gaugeVariationCharts');

    gaugeChartInstances.forEach(chart => chart.destroy());
    twistChartInstances.forEach(chart => chart.destroy());
    xLevelChartInstances.forEach(chart => chart.destroy());
    gaugeVariationChartInstances.forEach(chart => chart.destroy());
    gaugeChartInstances = [];
    twistChartInstances = [];
    xLevelChartInstances = [];
    gaugeVariationChartInstances = [];
    gaugeContainer.innerHTML = '';
    twistContainer.innerHTML = '';
    xLevelContainer.innerHTML = '';
    gaugeVariationContainer.innerHTML = '';

    segments.forEach(segment => {
        const rows = segment.rows;
        const labels = rows.map(r => r.miles + 'mi ' + r.yards.toFixed(0) + 'y');
        const step = Math.max(1, Math.floor(rows.length / 30));
        const displayLabels = labels.map((l, i) => i % step === 0 ? l : '');
        const n = rows.length;

        const segmentTitle = document.createElement('div');
        segmentTitle.className = 'chart-segment-title';
        segmentTitle.textContent = `${segment.startLabel} → ${segment.endLabel} (max 440 yds)`;

        // ---- Gauge chart ----
        const gaugeWrapper = document.createElement('div');
        gaugeWrapper.className = 'chart-wrapper';
        const gaugeCanvas = document.createElement('canvas');
        gaugeWrapper.appendChild(gaugeCanvas);
        gaugeContainer.appendChild(segmentTitle.cloneNode(true));
        gaugeContainer.appendChild(gaugeWrapper);

        const gaugeReference = 1435;
        const gaugeDatasets = [
            {
                label: 'Gauge (mm)',
                data: rows.map(r => r.gauge),
                borderColor: '#4a6cf7',
                backgroundColor: 'rgba(74,108,247,0.1)',
                fill: { target: { value: gaugeReference } },
                borderWidth: 1.5,
                pointRadius: 0,
                tension: 0.3
            }
        ];
        const prevGaugeData = buildPreviousTraceSeries(rows, 'gauge');
        if (prevGaugeData) {
            gaugeDatasets.push({
                label: 'Prev Gauge (mm)',
                data: prevGaugeData,
                borderColor: '#555',
                borderWidth: 1.5,
                borderDash: [6, 3],
                pointRadius: 0,
                fill: false,
                tension: 0.3
            });
        }

        const gaugeThresholds = getGaugeChartThresholds(lineSpeed);
        gaugeThresholds.forEach(t => {
            gaugeDatasets.push({
                label: t.label,
                data: Array(n).fill(t.value),
                borderColor: t.color, borderWidth: t.width, borderDash: t.dash,
                pointRadius: 0, fill: false, hidden: !!t.hidden
            });
        });

        const gaugeChart = new Chart(gaugeCanvas.getContext('2d'), {
            type: 'line',
            data: { labels: displayLabels, datasets: gaugeDatasets },
            options: {
                responsive: true, maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: { position: 'top', labels: { usePointStyle: true, padding: 12, font: { size: 10 } } },
                    tooltip: { callbacks: { title: (items) => labels[items[0].dataIndex] } }
                },
                scales: {
                    x: { ticks: { maxRotation: 45, font: { size: 10 } } },
                    y: { title: { display: true, text: 'Gauge (mm)' } }
                }
            }
        });
        gaugeChartInstances.push(gaugeChart);

        // ---- Twist chart ----
        const twistWrapper = document.createElement('div');
        twistWrapper.className = 'chart-wrapper';
        const twistCanvas = document.createElement('canvas');
        twistWrapper.appendChild(twistCanvas);
        twistContainer.appendChild(segmentTitle.cloneNode(true));
        twistContainer.appendChild(twistWrapper);

        const twistDatasets = [
            {
                label: 'Twist 1 - 3m (mm)',
                data: rows.map(r => r.twist1),
                borderColor: '#e67e22', backgroundColor: 'rgba(230,126,34,0.1)',
                fill: true, borderWidth: 1.5, pointRadius: 0, tension: 0.3, spanGaps: false
            },
            {
                label: 'Zero',
                data: Array(n).fill(0),
                borderColor: '#aaa', borderWidth: 1, borderDash: [3, 3], pointRadius: 0, fill: false
            }
        ];
        const prevTwistData = buildPreviousTraceSeries(rows, 'twist1');
        if (prevTwistData) {
            twistDatasets.push({
                label: 'Prev Twist 1 - 3m (mm)',
                data: prevTwistData,
                borderColor: '#555',
                borderWidth: 1.5,
                borderDash: [6, 3],
                pointRadius: 0,
                fill: false,
                tension: 0.3,
                spanGaps: false
            });
        }

        const twistThresholds = getTwistChartThresholds(lineSpeed);
        twistThresholds.forEach(t => {
            // Positive line (shown in legend)
            twistDatasets.push({
                label: '+' + t.label,
                data: Array(n).fill(t.value),
                borderColor: t.color, borderWidth: t.width, borderDash: t.dash,
                pointRadius: 0, fill: false
            });
            // Negative mirror (hidden from legend)
            twistDatasets.push({
                label: '-' + t.label,
                data: Array(n).fill(-t.value),
                borderColor: t.color, borderWidth: t.width, borderDash: t.dash,
                pointRadius: 0, fill: false
            });
        });

        const twistChart = new Chart(twistCanvas.getContext('2d'), {
            type: 'line',
            data: { labels: displayLabels, datasets: twistDatasets },
            options: {
                responsive: true, maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            usePointStyle: true, padding: 12, font: { size: 10 },
                            filter: (item) => !item.text.startsWith('-')
                        }
                    },
                    tooltip: { callbacks: { title: (items) => labels[items[0].dataIndex] } }
                },
                scales: {
                    x: { ticks: { maxRotation: 45, font: { size: 10 } } },
                    y: { title: { display: true, text: 'Twist (mm)' } }
                }
            }
        });
        twistChartInstances.push(twistChart);

        // ---- X-level (Cant) chart ----
        const xLevelWrapper = document.createElement('div');
        xLevelWrapper.className = 'chart-wrapper';
        const xLevelCanvas = document.createElement('canvas');
        xLevelWrapper.appendChild(xLevelCanvas);
        xLevelContainer.appendChild(segmentTitle.cloneNode(true));
        xLevelContainer.appendChild(xLevelWrapper);

        const xLevelDatasets = [
            {
                label: 'Cant (X-Level) (mm)',
                data: rows.map(r => r.xlevel),
                borderColor: '#16a085', backgroundColor: 'rgba(22,160,133,0.12)',
                fill: true, borderWidth: 1.5, pointRadius: 0, tension: 0.3, spanGaps: false
            },
            {
                label: 'Zero',
                data: Array(n).fill(0),
                borderColor: '#aaa', borderWidth: 1, borderDash: [3, 3], pointRadius: 0, fill: false
            }
        ];
        const prevXLevelData = buildPreviousTraceSeries(rows, 'xlevel');
        if (prevXLevelData) {
            xLevelDatasets.push({
                label: 'Prev Cant (X-Level) (mm)',
                data: prevXLevelData,
                borderColor: '#555',
                borderWidth: 1.5,
                borderDash: [6, 3],
                pointRadius: 0,
                fill: false,
                tension: 0.3,
                spanGaps: false
            });
        }

        const xLevelChart = new Chart(xLevelCanvas.getContext('2d'), {
            type: 'line',
            data: { labels: displayLabels, datasets: xLevelDatasets },
            options: {
                responsive: true, maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: { position: 'top', labels: { usePointStyle: true, padding: 12, font: { size: 10 } } },
                    tooltip: { callbacks: { title: (items) => labels[items[0].dataIndex] } }
                },
                scales: {
                    x: { ticks: { maxRotation: 45, font: { size: 10 } } },
                    y: { title: { display: true, text: 'Cant (mm)' } }
                }
            }
        });
        xLevelChartInstances.push(xLevelChart);

        // ---- Gauge variation chart ----
        const gvWrapper = document.createElement('div');
        gvWrapper.className = 'chart-wrapper';
        const gvCanvas = document.createElement('canvas');
        gvWrapper.appendChild(gvCanvas);
        gaugeVariationContainer.appendChild(segmentTitle.cloneNode(true));
        gaugeVariationContainer.appendChild(gvWrapper);

        const gaugeVariationThreshold = getGaugeVariationThreshold(lineSpeed);
        const gaugeVariationDatasets = [
            {
                label: 'Gauge Delta (mm)',
                data: rows.map(r => Number.isFinite(r.gaugeDelta) ? r.gaugeDelta : null),
                borderColor: '#8e44ad',
                backgroundColor: 'rgba(142,68,173,0.12)',
                fill: true,
                borderWidth: 1.5,
                pointRadius: 0,
                tension: 0.3,
                spanGaps: false
            },
            {
                label: 'Zero',
                data: Array(n).fill(0),
                borderColor: '#aaa', borderWidth: 1, borderDash: [3, 3], pointRadius: 0, fill: false
            }
        ];
        if (gaugeVariationThreshold) {
            gaugeVariationDatasets.push({
                label: `+IL (${gaugeVariationThreshold}mm)`,
                data: Array(n).fill(gaugeVariationThreshold),
                borderColor: '#e67e22', borderWidth: 1, borderDash: [5, 3], pointRadius: 0, fill: false
            });
            gaugeVariationDatasets.push({
                label: `-IL (${gaugeVariationThreshold}mm)`,
                data: Array(n).fill(-gaugeVariationThreshold),
                borderColor: '#e67e22', borderWidth: 1, borderDash: [5, 3], pointRadius: 0, fill: false
            });
        }

        const gaugeVariationChart = new Chart(gvCanvas.getContext('2d'), {
            type: 'line',
            data: { labels: displayLabels, datasets: gaugeVariationDatasets },
            options: {
                responsive: true, maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: { position: 'top', labels: { usePointStyle: true, padding: 12, font: { size: 10 } } },
                    tooltip: { callbacks: { title: (items) => labels[items[0].dataIndex] } }
                },
                scales: {
                    x: { ticks: { maxRotation: 45, font: { size: 10 } } },
                    y: { title: { display: true, text: 'Gauge Delta (mm)' } }
                }
            }
        });
        gaugeVariationChartInstances.push(gaugeVariationChart);
    });
}

function buildGaugeFaultTable() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const tbody = document.querySelector('#gaugeFaultTable tbody');
    tbody.innerHTML = '';
    const allGaugeFaults = gaugeFaults.concat(manualGaugeFaults);
    if (allGaugeFaults.length === 0) {
        tbody.innerHTML = '<tr><td colspan="11" style="text-align:center;padding:30px;color:#888;">No gauge faults detected</td></tr>';
        return;
    }

    let visibleIdx = 0;
    allGaugeFaults.forEach((f, idx) => {
        const effective = getEffectiveFault('gauge', idx, f);
        if (isDismissed('gauge', idx)) return;
        const classification = classifyGaugeFault(effective.worstGauge, lineSpeed, getTrackCat());
        const tr = document.createElement('tr');
        tr.className = classification ? classification.rowClass : '';

        const catBadge = classification
            ? `<span class="badge ${classification.badge}">${classification.category}</span>`
            : '<span style="color:#999;">--</span>';
        const faultType = classification ? classification.type : (effective.direction === 'wide' ? 'Wide Gauge' : 'Tight Gauge');
        const actionText = classification ? classification.action : (lineSpeed < 5 ? 'Set line speed' : 'Below threshold');
        const manualTag = f.manual ? '<span class="manual-fault-tag">MANUAL</span>' : '';
        const removeBtn = f.manual ? `<button class="btn-remove-fault" onclick="removeManualGaugeFault(${idx - gaugeFaults.length})" title="Remove manual fault">X</button> ` : '';
        const editBtn = `<button class="btn-edit-fault" onclick="openEditFaultModal('gauge',${idx})">Edit</button>`;
        const editInfo = effective.edit
            ? `<span class="dismissed-info">Override by ${effective.edit.inspector}: ${effective.edit.commentary}</span>`
            : '';
        const defaultFaultNo = f.manual && f.faultNo ? f.faultNo : '';

        const dismissBtn = `<button class="btn-dismiss-fault" onclick="openDismissModal('gauge',${idx})">Delete</button>`;

        tr.innerHTML = `
            <td>${visibleIdx + 1} ${manualTag}</td>
            <td><input type="text" class="fault-no-input" data-type="gauge" data-idx="${idx}" placeholder="--" value="${defaultFaultNo}" style="width:55px;padding:3px 5px;border:1px solid #ccc;border-radius:4px;font-size:11px;text-align:center;"></td>
            <td>${effective.startLocation}</td>
            <td>${effective.endLocation}</td>
            <td>${effective.length}</td>
            <td>${effective.worstGauge.toFixed(1)}</td>
            <td>${effective.deviation}</td>
            <td>${faultType}</td>
            <td>${catBadge}</td>
            <td style="font-size:11px;max-width:220px;">${actionText} ${editBtn} ${removeBtn}${dismissBtn}${editInfo}</td>
            <td style="text-align:center;"><input type="checkbox" class="repeat-fault-cb" data-type="gauge" data-idx="${idx}"></td>
        `;
        tbody.appendChild(tr);
        visibleIdx++;
    });
}
function buildTwistFaultTable() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const tbody = document.querySelector('#twistFaultTable tbody');
    tbody.innerHTML = '';
    const allTwistFaults = twistFaults.concat(manualTwistFaults);
    if (allTwistFaults.length === 0) {
        tbody.innerHTML = '<tr><td colspan="11" style="text-align:center;padding:30px;color:#888;">No twist faults detected</td></tr>';
        return;
    }

    let visibleIdx = 0;
    allTwistFaults.forEach((f, idx) => {
        const effective = getEffectiveFault('twist', idx, f);
        if (isDismissed('twist', idx)) return;
        const isLessThan400 = f.manual ? f.curveRadiusLessThan400 : twistFaultRadiusSettings[idx];
        const classification = classifyTwistFault(effective.maxAbsTwist, lineSpeed, isLessThan400);
        const tr = document.createElement('tr');
        tr.className = classification ? classification.rowClass : '';

        const catBadge = classification
            ? `<span class="badge ${classification.badge}">${classification.category}</span>`
            : '<span style="color:#999;">--</span>';
        const actionText = classification ? classification.action : (lineSpeed < 5 ? 'Set line speed' : 'Below threshold');
        const manualTag = f.manual ? '<span class="manual-fault-tag">MANUAL</span>' : '';
        const removeBtn = f.manual ? `<button class="btn-remove-fault" onclick="removeManualTwistFault(${idx - twistFaults.length})" title="Remove manual fault">X</button> ` : '';
        const editBtn = `<button class="btn-edit-fault" onclick="openEditFaultModal('twist',${idx})">Edit</button>`;
        const editInfo = effective.edit
            ? `<span class="dismissed-info">Override by ${effective.edit.inspector}: ${effective.edit.commentary}</span>`
            : '';
        const defaultFaultNo = f.manual && f.faultNo ? f.faultNo : '';

        const dismissBtn = `<button class="btn-dismiss-fault" onclick="openDismissModal('twist',${idx})">Delete</button>`;

        tr.innerHTML = `
            <td>${visibleIdx + 1} ${manualTag}</td>
            <td><input type="text" class="fault-no-input" data-type="twist" data-idx="${idx}" placeholder="--" value="${defaultFaultNo}" style="width:55px;padding:3px 5px;border:1px solid #ccc;border-radius:4px;font-size:11px;text-align:center;"></td>
            <td>${effective.startLocation}</td>
            <td>${effective.endLocation}</td>
            <td>${effective.length}</td>
            <td>${effective.maxAbsTwist.toFixed(1)}</td>
            <td>${effective.worstValue.toFixed(1)}</td>
            <td>
                <select class="radius-select" data-twist-idx="${idx}" onchange="onRadiusChange(this)">
                    <option value="gte400" ${!isLessThan400 ? 'selected' : ''}>&ge; 400m</option>
                    <option value="lt400" ${isLessThan400 ? 'selected' : ''}>&lt; 400m</option>
                </select>
            </td>
            <td>${catBadge}</td>
            <td style="font-size:11px;max-width:220px;">${actionText} ${editBtn} ${removeBtn}${dismissBtn}${editInfo}</td>
            <td style="text-align:center;"><input type="checkbox" class="repeat-fault-cb" data-type="twist" data-idx="${idx}"></td>
        `;
        tbody.appendChild(tr);
        visibleIdx++;
    });
}
function onRadiusChange(selectEl) {
    const idx = parseInt(selectEl.dataset.twistIdx);
    const isManual = idx >= twistFaults.length;
    if (isManual) {
        const manualIdx = idx - twistFaults.length;
        manualTwistFaults[manualIdx].curveRadiusLessThan400 = (selectEl.value === 'lt400');
    } else {
        twistFaultRadiusSettings[idx] = (selectEl.value === 'lt400');
    }
    buildTwistFaultTable();
    updateSummaryStats();
}

// ---- Navigation ----
function goBack() {
    document.getElementById('uploadScreen').style.display = 'flex';
    document.getElementById('reportContainer').classList.remove('active');
    document.getElementById('runSelectorBar').style.display = 'none';
    fileInput.value = '';
    allRuns = [];
    activeRunIndex = -1;
    manualGaugeFaults = [];
    manualTwistFaults = [];
    dismissedFaults = {};
    faultEdits = {};
    runTraceFlipped = false;
    runFlipReason = '';
}

// ---- Manual Fault Modals ----

function buildGaugeVariationFaultTable() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const tbody = document.querySelector('#gaugeVariationFaultTable tbody');
    tbody.innerHTML = '';

    if (!gaugeVariationFaults.length) {
        const hasGaugeDelta = parsedData && parsedData.some(r => Number.isFinite(r.gaugeDelta));
        const emptyText = hasGaugeDelta
            ? 'No gauge variation faults detected'
            : 'Gauge Delta column not found in this run';
        tbody.innerHTML = `<tr><td colspan="8" style="text-align:center;padding:30px;color:#888;">${emptyText}</td></tr>`;
        return;
    }

    gaugeVariationFaults.forEach((f, idx) => {
        const effective = getEffectiveFault('gaugeVariation', idx, f);
        const classification = classifyGaugeVariationFault(effective.maxAbsGaugeDelta, lineSpeed);
        const tr = document.createElement('tr');
        tr.className = classification ? classification.rowClass : '';
        const catBadge = classification
            ? `<span class="badge ${classification.badge}">${classification.category}</span>`
            : '<span style="color:#999;">--</span>';
        const actionText = classification ? classification.action : (lineSpeed < 5 ? 'Set line speed' : 'Below threshold');
        const editBtn = `<button class="btn-edit-fault" onclick="openEditFaultModal('gaugeVariation',${idx})">Edit</button>`;
        const editInfo = effective.edit
            ? `<span class="dismissed-info">Override by ${effective.edit.inspector}: ${effective.edit.commentary}</span>`
            : '';
        tr.innerHTML = `
            <td>${idx + 1}</td>
            <td>${effective.startLocation}</td>
            <td>${effective.endLocation}</td>
            <td>${effective.length}</td>
            <td>${effective.maxAbsGaugeDelta.toFixed(1)}</td>
            <td>${effective.worstGaugeDelta.toFixed(1)}</td>
            <td>${catBadge}</td>
            <td style="font-size:11px;max-width:220px;">${actionText} ${editBtn}${editInfo}</td>
        `;
        tbody.appendChild(tr);
    });
}
function openManualGaugeFaultModal() {
    document.getElementById('mgStartMiles').value = '';
    document.getElementById('mgStartYards').value = '';
    document.getElementById('mgEndMiles').value = '';
    document.getElementById('mgEndYards').value = '';
    document.getElementById('mgWorstGauge').value = '';
    document.getElementById('mgFaultDirection').value = 'wide';
    document.getElementById('mgFaultNo').value = '';
    document.getElementById('gaugeModal').classList.add('active');
}

function openManualTwistFaultModal() {
    document.getElementById('mtStartMiles').value = '';
    document.getElementById('mtStartYards').value = '';
    document.getElementById('mtEndMiles').value = '';
    document.getElementById('mtEndYards').value = '';
    document.getElementById('mtMaxTwist').value = '';
    document.getElementById('mtWorstValue').value = '';
    document.getElementById('mtCurveRadius').value = 'gte400';
    document.getElementById('mtFaultNo').value = '';
    document.getElementById('twistModal').classList.add('active');
}

function closeModal(id) {
    document.getElementById(id).classList.remove('active');
}

function saveManualGaugeFault() {
    const startMiles = parseFloat(document.getElementById('mgStartMiles').value);
    const startYards = parseFloat(document.getElementById('mgStartYards').value);
    const endMiles = parseFloat(document.getElementById('mgEndMiles').value);
    const endYards = parseFloat(document.getElementById('mgEndYards').value);
    const worstGauge = parseFloat(document.getElementById('mgWorstGauge').value);
    const direction = document.getElementById('mgFaultDirection').value;
    const faultNo = document.getElementById('mgFaultNo').value;

    if (isNaN(startMiles) || isNaN(startYards) || isNaN(endMiles) || isNaN(endYards) || isNaN(worstGauge)) {
        alert('Please fill in all required fields (miles, yards, worst gauge).');
        return;
    }

    const fault = {
        startLocation: startMiles + 'mi ' + startYards.toFixed(0) + 'yds',
        endLocation: endMiles + 'mi ' + endYards.toFixed(0) + 'yds',
        startMiles, startYards, endMiles, endYards,
        worstGauge: worstGauge,
        direction: direction,
        length: (endYards - startYards).toFixed(1),
        deviation: direction === 'wide'
            ? '+' + (worstGauge - 1435).toFixed(1)
            : '-' + (1435 - worstGauge).toFixed(1),
        manual: true,
        faultNo: faultNo,
        rows: []
    };

    manualGaugeFaults.push(fault);
    // Persist to current run
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].manualGaugeFaults = manualGaugeFaults;
    }

    closeModal('gaugeModal');
    buildGaugeFaultTable();
    updateSummaryStats();
}

function saveManualTwistFault() {
    const startMiles = parseFloat(document.getElementById('mtStartMiles').value);
    const startYards = parseFloat(document.getElementById('mtStartYards').value);
    const endMiles = parseFloat(document.getElementById('mtEndMiles').value);
    const endYards = parseFloat(document.getElementById('mtEndYards').value);
    const maxTwist = parseFloat(document.getElementById('mtMaxTwist').value);
    const worstValue = parseFloat(document.getElementById('mtWorstValue').value);
    const curveRadius = document.getElementById('mtCurveRadius').value;
    const faultNo = document.getElementById('mtFaultNo').value;

    if (isNaN(startMiles) || isNaN(startYards) || isNaN(endMiles) || isNaN(endYards) || isNaN(maxTwist) || isNaN(worstValue)) {
        alert('Please fill in all required fields.');
        return;
    }

    const fault = {
        startLocation: startMiles + 'mi ' + startYards.toFixed(0) + 'yds',
        endLocation: endMiles + 'mi ' + endYards.toFixed(0) + 'yds',
        startMiles, startYards, endMiles, endYards,
        maxAbsTwist: maxTwist,
        worstValue: worstValue,
        length: (endYards - startYards).toFixed(1),
        manual: true,
        faultNo: faultNo,
        curveRadiusLessThan400: curveRadius === 'lt400',
        rows: []
    };

    manualTwistFaults.push(fault);
    twistFaultRadiusSettings.push(fault.curveRadiusLessThan400);
    // Persist to current run
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].manualTwistFaults = manualTwistFaults;
    }

    closeModal('twistModal');
    buildTwistFaultTable();
    updateSummaryStats();
}

function removeManualGaugeFault(manualIdx) {
    manualGaugeFaults.splice(manualIdx, 1);
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].manualGaugeFaults = manualGaugeFaults;
    }
    buildGaugeFaultTable();
    updateSummaryStats();
}

function removeManualTwistFault(manualIdx) {
    // Find the position in the combined array to remove the radius setting
    const combinedIdx = twistFaults.length + manualIdx;
    twistFaultRadiusSettings.splice(combinedIdx, 1);
    manualTwistFaults.splice(manualIdx, 1);
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].manualTwistFaults = manualTwistFaults;
    }
    buildTwistFaultTable();
    updateSummaryStats();
}

// ---- Delete Faults ----
function openDismissModal(faultType, idx) {
    document.getElementById('dismissFaultType').value = faultType;
    document.getElementById('dismissFaultIdx').value = idx;
    document.getElementById('dismissInspector').value = '';
    document.getElementById('dismissReason').value = '';
    document.getElementById('dismissModal').classList.add('active');
}

function confirmDismissFault() {
    const faultType = document.getElementById('dismissFaultType').value;
    const idx = parseInt(document.getElementById('dismissFaultIdx').value);
    const inspector = document.getElementById('dismissInspector').value.trim();
    const reason = document.getElementById('dismissReason').value.trim();

    if (!reason) {
        alert('Please provide a reason for deletion.');
        return;
    }

    const key = faultType + '-' + idx;
    const now = new Date();
    const sourceFault = getFaultByTypeAndIndex(faultType, idx);
    const effective = sourceFault ? getEffectiveFault(faultType, idx, sourceFault) : null;
    dismissedFaults[key] = {
        timestamp: now.toISOString(),
        displayTime: now.toLocaleDateString('en-GB') + ' ' + now.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' }),
        comment: reason,
        inspector: inspector || 'Unknown',
        startLocation: effective ? effective.startLocation : '',
        endLocation: effective ? effective.endLocation : ''
    };

    // Persist to current run
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].dismissedFaults = Object.assign({}, dismissedFaults);
    }

    closeModal('dismissModal');
    if (faultType === 'gauge') {
        buildGaugeFaultTable();
    } else {
        buildTwistFaultTable();
    }
    buildInvalidatedFaultTable();
    updateSummaryStats();
}

function restoreFault(faultType, idx) {
    const key = faultType + '-' + idx;
    delete dismissedFaults[key];
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].dismissedFaults = Object.assign({}, dismissedFaults);
    }
    buildGaugeFaultTable();
    buildTwistFaultTable();
    buildInvalidatedFaultTable();
    updateSummaryStats();
}

function isDismissed(faultType, idx) {
    return dismissedFaults[faultType + '-' + idx] || null;
}


function getFaultEdit(faultType, idx) {
    return faultEdits[faultType + '-' + idx] || null;
}

function formatFaultLocation(miles, yards) {
    if (!Number.isFinite(miles) || !Number.isFinite(yards)) return '--';
    return miles + 'mi ' + yards.toFixed(0) + 'yds';
}

function getEffectiveFault(faultType, idx, fault) {
    const edit = getFaultEdit(faultType, idx);
    if (!edit) return { ...fault, edit: null };

    const startMiles = Number.isFinite(edit.startMiles) ? edit.startMiles : fault.startMiles;
    const startYards = Number.isFinite(edit.startYards) ? edit.startYards : fault.startYards;
    const endMiles = Number.isFinite(edit.endMiles) ? edit.endMiles : fault.endMiles;
    const endYards = Number.isFinite(edit.endYards) ? edit.endYards : fault.endYards;

    const out = {
        ...fault,
        startMiles,
        startYards,
        endMiles,
        endYards,
        startLocation: formatFaultLocation(startMiles, startYards),
        endLocation: formatFaultLocation(endMiles, endYards),
        edit
    };

    if (faultType === 'gauge') {
        if (Number.isFinite(edit.primaryValue)) {
            out.worstGauge = edit.primaryValue;
            out.deviation = (out.worstGauge >= 1435 ? '+' : '-') + Math.abs(out.worstGauge - 1435).toFixed(1);
            if (!out.manual) out.direction = out.worstGauge >= 1435 ? 'wide' : 'tight';
        }
    } else if (faultType === 'twist') {
        if (Number.isFinite(edit.primaryValue)) {
            out.worstValue = edit.primaryValue;
            out.maxAbsTwist = Math.abs(edit.primaryValue);
        }
    } else if (faultType === 'gaugeVariation') {
        if (Number.isFinite(edit.primaryValue)) {
            out.worstGaugeDelta = edit.primaryValue;
            out.maxAbsGaugeDelta = Math.abs(edit.primaryValue);
        }
    }

    const startPos = Number.isFinite(startMiles) && Number.isFinite(startYards) ? startMiles * 1760 + startYards : null;
    const endPos = Number.isFinite(endMiles) && Number.isFinite(endYards) ? endMiles * 1760 + endYards : null;
    if (startPos !== null && endPos !== null) {
        out.length = Math.max(0, endPos - startPos).toFixed(1);
    }

    return out;
}

function openEditFaultModal(faultType, idx) {
    const allGaugeFaults = gaugeFaults.concat(manualGaugeFaults);
    const allTwistFaults = twistFaults.concat(manualTwistFaults);
    const sourceFault = faultType === 'gauge'
        ? allGaugeFaults[idx]
        : faultType === 'twist'
            ? allTwistFaults[idx]
            : gaugeVariationFaults[idx];
    if (!sourceFault) return;

    const effective = getEffectiveFault(faultType, idx, sourceFault);
    const edit = getFaultEdit(faultType, idx);

    document.getElementById('editFaultType').value = faultType;
    document.getElementById('editFaultIdx').value = idx;
    document.getElementById('editStartMiles').value = Number.isFinite(effective.startMiles) ? effective.startMiles : '';
    document.getElementById('editStartYards').value = Number.isFinite(effective.startYards) ? effective.startYards : '';
    document.getElementById('editEndMiles').value = Number.isFinite(effective.endMiles) ? effective.endMiles : '';
    document.getElementById('editEndYards').value = Number.isFinite(effective.endYards) ? effective.endYards : '';

    const primaryLabel = document.getElementById('editPrimaryLabel');
    if (faultType === 'gauge') {
        primaryLabel.textContent = 'Worst Gauge (mm)';
        document.getElementById('editPrimaryValue').value = Number.isFinite(effective.worstGauge) ? effective.worstGauge : '';
    } else if (faultType === 'twist') {
        primaryLabel.textContent = 'Worst Twist Value (mm)';
        document.getElementById('editPrimaryValue').value = Number.isFinite(effective.worstValue) ? effective.worstValue : '';
    } else {
        primaryLabel.textContent = 'Worst Gauge Delta (mm)';
        document.getElementById('editPrimaryValue').value = Number.isFinite(effective.worstGaugeDelta) ? effective.worstGaugeDelta : '';
    }

    document.getElementById('editInspector').value = edit ? (edit.inspector || '') : '';
    document.getElementById('editCommentary').value = edit ? (edit.commentary || '') : '';
    document.getElementById('editFaultModal').classList.add('active');
}

function confirmEditFault() {
    const faultType = document.getElementById('editFaultType').value;
    const idx = parseInt(document.getElementById('editFaultIdx').value);
    const commentary = document.getElementById('editCommentary').value.trim();
    if (!commentary) {
        alert('Please provide commentary for the override.');
        return;
    }

    const entry = {
        startMiles: parseFloat(document.getElementById('editStartMiles').value),
        startYards: parseFloat(document.getElementById('editStartYards').value),
        endMiles: parseFloat(document.getElementById('editEndMiles').value),
        endYards: parseFloat(document.getElementById('editEndYards').value),
        primaryValue: parseFloat(document.getElementById('editPrimaryValue').value),
        inspector: document.getElementById('editInspector').value.trim() || 'Unknown',
        commentary,
        updatedAt: new Date().toISOString()
    };

    const key = faultType + '-' + idx;
    faultEdits[key] = entry;

    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].faultEdits = Object.assign({}, faultEdits);
    }

    closeModal('editFaultModal');
    buildGaugeFaultTable();
    buildTwistFaultTable();
    buildGaugeVariationFaultTable();
    updateSummaryStats();
    buildSchematic();
}

// ---- Linear Schematic ----
function buildSchematic() {
    const canvas = document.getElementById('schematicCanvas');
    const container = document.getElementById('schematicContainer');
    if (!canvas || !container || !parsedData.length) return;

    const ctx = canvas.getContext('2d');
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const trackCat = getTrackCat();

    const allPoints = parsedData.map(r => r.miles * 1760 + r.yards);
    const minPos = Math.min(...allPoints);
    const maxPos = Math.max(...allPoints);
    const range = maxPos - minPos || 1;

    const availableWidth = Math.max(container.clientWidth - 16, 720);
    const height = 200;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(availableWidth * dpr);
    canvas.height = Math.round(height * dpr);
    canvas.style.width = `${availableWidth}px`;
    canvas.style.height = `${height}px`;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    const padL = 80;
    const padR = 30;
    const trackY = 85;
    const trackH = 12;
    const drawW = availableWidth - padL - padR;

    const posToX = (miles, yards) => padL + ((miles * 1760 + yards - minPos) / range) * drawW;

    ctx.clearRect(0, 0, availableWidth, height);
    ctx.fillStyle = '#fafafa';
    ctx.fillRect(0, 0, availableWidth, height);

    ctx.fillStyle = '#e3e6eb';
    ctx.fillRect(padL, trackY - 1, drawW, trackH);
    ctx.strokeStyle = '#9aa3ad';
    ctx.lineWidth = 1.2;
    ctx.strokeRect(padL, trackY - 1, drawW, trackH);

    const startMiles = parsedData[0].miles;
    const endMiles = parsedData[parsedData.length - 1].miles;
    ctx.fillStyle = '#666';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    for (let m = startMiles; m <= endMiles; m++) {
        const x = posToX(m, 0);
        if (x >= padL && x <= padL + drawW) {
            ctx.beginPath();
            ctx.moveTo(x, trackY + trackH);
            ctx.lineTo(x, trackY + trackH + 6);
            ctx.strokeStyle = '#999';
            ctx.stroke();
            ctx.fillText(`${m}mi`, x, trackY + trackH + 18);
        }
    }

    ctx.textAlign = 'left';
    ctx.fillStyle = '#555';
    ctx.font = '10px sans-serif';
    ctx.fillText(formatLocation(parsedData[0]), padL, trackY - 18);
    ctx.textAlign = 'right';
    ctx.fillText(formatLocation(parsedData[parsedData.length - 1]), padL + drawW, trackY - 18);

    const catColours = { 'IAL': '#c0392b', 'IL': '#e67e22', 'AL': '#28a745' };

    const allGF = gaugeFaults.concat(manualGaugeFaults);
    allGF.forEach((f, i) => {
        if (isDismissed('gauge', i)) return;
        const effective = getEffectiveFault('gauge', i, f);
        const c = classifyGaugeFault(effective.worstGauge, lineSpeed, trackCat);
        if (!c) return;
        const x1 = posToX(effective.startMiles, effective.startYards);
        const x2 = posToX(effective.endMiles || effective.startMiles, effective.endYards || effective.startYards);
        const faultW = Math.max(x2 - x1, 3);
        ctx.fillStyle = catColours[c.category] || '#999';
        ctx.fillRect(x1, trackY - 22, faultW, 14);
    });

    const allTF = twistFaults.concat(manualTwistFaults);
    allTF.forEach((f, i) => {
        if (isDismissed('twist', i)) return;
        const effective = getEffectiveFault('twist', i, f);
        const isLt400 = f.manual ? f.curveRadiusLessThan400 : twistFaultRadiusSettings[i];
        const c = classifyTwistFault(effective.maxAbsTwist, lineSpeed, isLt400);
        if (!c) return;
        const x1 = posToX(effective.startMiles, effective.startYards);
        const x2 = posToX(effective.endMiles || effective.startMiles, effective.endYards || effective.startYards);
        const faultW = Math.max(x2 - x1, 3);
        ctx.fillStyle = catColours[c.category] || '#999';
        ctx.fillRect(x1, trackY + trackH + 6, faultW, 14);
    });

    ctx.fillStyle = '#333';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Gauge', padL - 12, trackY - 10);
    ctx.fillText('Twist', padL - 12, trackY + trackH + 20);

    ctx.textAlign = 'left';
    let lx = padL;
    const ly = height - 14;
    [['IAL', '#c0392b'], ['IL', '#e67e22'], ['AL', '#28a745']].forEach(([label, col]) => {
        ctx.fillStyle = col;
        ctx.fillRect(lx, ly - 9, 12, 10);
        ctx.fillStyle = '#333';
        ctx.font = '10px sans-serif';
        ctx.fillText(label, lx + 15, ly);
        lx += 50;
    });

    if (previousRunData) {
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(lx, ly - 8, 12, 10);
        ctx.strokeStyle = '#333';
        ctx.setLineDash([2, 2]);
        ctx.strokeRect(lx, ly - 8, 12, 10);
        ctx.setLineDash([]);
        ctx.fillStyle = '#333';
        ctx.fillText('Previous', lx + 15, ly);

        (previousRunData.gaugeFaults || []).forEach(f => {
            if (f.startMiles === undefined) return;
            const x1 = posToX(f.startMiles, f.startYards);
            const x2 = posToX(f.endMiles || f.startMiles, f.endYards || f.startYards);
            const faultW = Math.max(x2 - x1, 3);
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([3, 2]);
            ctx.strokeRect(x1, trackY - 22, faultW, 14);
            ctx.setLineDash([]);
        });
        (previousRunData.twistFaults || []).forEach(f => {
            if (f.startMiles === undefined) return;
            const x1 = posToX(f.startMiles, f.startYards);
            const x2 = posToX(f.endMiles || f.startMiles, f.endYards || f.startYards);
            const faultW = Math.max(x2 - x1, 3);
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([3, 2]);
            ctx.strokeRect(x1, trackY + trackH + 6, faultW, 14);
            ctx.setLineDash([]);
        });
    }
}

// ---- Previous Run PDF Comparison ----
let previousRunData = null; // {gaugeFaults:[], twistFaults:[], metadata:{}, lineSpeed, trackCat, traceData:[]}
let previousRunTraceOffsetYards = 0;
let previousRunTraceEnabled = true;

function buildPreviousTraceLookup() {
    if (!previousRunData || !Array.isArray(previousRunData.traceData)) {
        return null;
    }
    const map = new Map();
    previousRunData.traceData.forEach(row => {
        if (row.miles === undefined || row.yards === undefined) return;
        const pos = row.miles * 1760 + row.yards;
        const key = Math.round(pos * 10);
        map.set(key, row);
    });
    previousRunData.traceLookup = map;
    return map;
}

function getPreviousTraceAtPosition(positionYards) {
    if (!previousRunData || !previousRunData.traceLookup || !previousRunTraceEnabled) return null;
    const shifted = positionYards - previousRunTraceOffsetYards;
    const baseKey = Math.round(shifted * 10);
    if (previousRunData.traceLookup.has(baseKey)) {
        return previousRunData.traceLookup.get(baseKey);
    }
    const tolerance = 5;
    for (let i = 1; i <= tolerance; i++) {
        const plus = baseKey + i;
        const minus = baseKey - i;
        if (previousRunData.traceLookup.has(plus)) return previousRunData.traceLookup.get(plus);
        if (previousRunData.traceLookup.has(minus)) return previousRunData.traceLookup.get(minus);
    }
    return null;
}

function updatePreviousTraceOverlay() {
    buildCharts();
}

function setPreviousRunTraceEnabled(checked) {
    previousRunTraceEnabled = checked;
    updatePreviousTraceOverlay();
}

function setPreviousRunOffset(value) {
    const parsed = parseFloat(value);
    previousRunTraceOffsetYards = Number.isFinite(parsed) ? parsed : 0;
    updatePreviousTraceOverlay();
}

function loadPreviousRunPDF(inputEl) {
    const file = inputEl.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async function(e) {
        try {
            const typedArray = new Uint8Array(e.target.result);
            const pdf = await pdfjsLib.getDocument(typedArray).promise;

            // Try to read embedded JSON from PDF metadata first
            const pdfMeta = await pdf.getMetadata();
            let embedded = null;
            // Check keywords field for embedded data
            if (pdfMeta && pdfMeta.info && pdfMeta.info.Keywords) {
                const kw = pdfMeta.info.Keywords;
                const prefix = 'AmberTrolleyData:';
                if (kw.startsWith(prefix)) {
                    try {
                        embedded = JSON.parse(kw.substring(prefix.length));
                    } catch(ex) { /* fall through to text parsing */ }
                }
            }

            if (embedded) {
                previousRunData = embedded;
            } else {
                // Fallback: parse text from PDF pages
                previousRunData = await parsePreviousRunFromText(pdf);
            }

            previousRunData.metadata = previousRunData.metadata || {};
            previousRunData.filename = file.name;
            previousRunTraceOffsetYards = 0;
            previousRunTraceEnabled = true;
            buildPreviousTraceLookup();
            updateComparison();
            buildSchematic();
            buildCharts();
        } catch(err) {
            alert('Error reading previous PDF: ' + err.message);
            console.error(err);
        }
    };
    reader.readAsArrayBuffer(file);
}

async function parsePreviousRunFromText(pdf) {
    const result = { gaugeFaults: [], twistFaults: [], metadata: {}, lineSpeed: 0, trackCat: '' };
    let allText = '';

    for (let p = 1; p <= pdf.numPages; p++) {
        const page = await pdf.getPage(p);
        const content = await page.getTextContent();
        const pageText = content.items.map(item => item.str).join(' ');
        allText += pageText + '\n';
    }

    // Extract line speed
    const speedMatch = allText.match(/Line Speed:\s*(\d+)/);
    if (speedMatch) result.lineSpeed = parseInt(speedMatch[1]);

    // Extract track category
    const catMatch = allText.match(/Track Cat:\s*(\w+)/);
    if (catMatch) result.trackCat = catMatch[1];

    // Extract route/track
    const routeMatch = allText.match(/Route:\s*(\S+)/);
    if (routeMatch) result.metadata['Route ID'] = routeMatch[1];

    // Parse gauge fault rows (look for patterns like "21mi 1160.0yds")
    const locationPattern = /(\d+)mi\s+([\d.]+)yds/g;
    const gaugeFaultPattern = /(\d+)\s+(?:\*\s*)?(\d+mi\s+[\d.]+yds)\s+([\d]+mi\s+[\d.]+yds)\s+([\d.]+)\s+([\d.]+)\s+([+-][\d.]+)/g;

    // Simplified: extract fault summary from the table data
    // We look for patterns in the gauge faults page
    const gaugeSection = allText.split(/Twist Faults/)[0] || allText;
    const twistSection = allText.split(/Twist Faults/)[1] || '';

    // Parse location pairs from gauge section
    const gaugeLocs = [];
    let locMatch;
    const gLocRe = /(\d+)mi\s+([\d.]+)yds/g;
    const gaugePart = gaugeSection.split(/Gauge Faults/)[1] || gaugeSection;
    while ((locMatch = gLocRe.exec(gaugePart)) !== null) {
        gaugeLocs.push({ miles: parseInt(locMatch[1]), yards: parseFloat(locMatch[2]) });
    }
    // Pair up as start/end (every 2 locations)
    for (let i = 0; i + 1 < gaugeLocs.length; i += 2) {
        result.gaugeFaults.push({
            startMiles: gaugeLocs[i].miles, startYards: gaugeLocs[i].yards,
            startLocation: gaugeLocs[i].miles + 'mi ' + gaugeLocs[i].yards.toFixed(0) + 'yds',
            endMiles: gaugeLocs[i+1].miles, endYards: gaugeLocs[i+1].yards,
            endLocation: gaugeLocs[i+1].miles + 'mi ' + gaugeLocs[i+1].yards.toFixed(0) + 'yds'
        });
    }

    // Parse twist section
    const twistLocs = [];
    const tLocRe = /(\d+)mi\s+([\d.]+)yds/g;
    while ((locMatch = tLocRe.exec(twistSection)) !== null) {
        twistLocs.push({ miles: parseInt(locMatch[1]), yards: parseFloat(locMatch[2]) });
    }
    for (let i = 0; i + 1 < twistLocs.length; i += 2) {
        result.twistFaults.push({
            startMiles: twistLocs[i].miles, startYards: twistLocs[i].yards,
            startLocation: twistLocs[i].miles + 'mi ' + twistLocs[i].yards.toFixed(0) + 'yds',
            endMiles: twistLocs[i+1].miles, endYards: twistLocs[i+1].yards,
            endLocation: twistLocs[i+1].miles + 'mi ' + twistLocs[i+1].yards.toFixed(0) + 'yds'
        });
    }

    return result;
}

function clearPreviousRun() {
    previousRunData = null;
    previousRunTraceOffsetYards = 0;
    previousRunTraceEnabled = true;
    document.getElementById('prevRunInput').value = '';
    document.getElementById('comparisonResults').style.display = 'none';
    document.getElementById('comparisonEmpty').style.display = 'block';
    buildSchematic();
    buildCharts();
}

function updateComparison() {
    if (!previousRunData) return;

    const resultsDiv = document.getElementById('comparisonResults');
    const emptyDiv = document.getElementById('comparisonEmpty');
    emptyDiv.style.display = 'none';
    resultsDiv.style.display = 'block';

    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const trackCat = getTrackCat();
    const allGF = gaugeFaults.concat(manualGaugeFaults);
    const allTF = twistFaults.concat(manualTwistFaults);
    const prevGF = previousRunData.gaugeFaults || [];
    const prevTF = previousRunData.twistFaults || [];
    const traceAvailable = Array.isArray(previousRunData.traceData) && previousRunData.traceData.length > 0;

    // Compare faults by location overlap
    function locOverlaps(a, b) {
        const aStart = a.startMiles * 1760 + a.startYards;
        const aEnd = (a.endMiles || a.startMiles) * 1760 + (a.endYards || a.startYards);
        const bStart = b.startMiles * 1760 + b.startYards;
        const bEnd = (b.endMiles || b.startMiles) * 1760 + (b.endYards || b.startYards);
        return aStart <= bEnd + 5 && bStart <= aEnd + 5; // 5yd tolerance
    }

    // Categorise gauge faults
    const gaugePersists = [], gaugeNew = [], gaugeResolved = [];
    const prevGMatched = new Set();
    allGF.forEach((f, i) => {
        if (isDismissed('gauge', i)) return;
        const match = prevGF.findIndex((pf, pi) => !prevGMatched.has(pi) && locOverlaps(f, pf));
        if (match >= 0) {
            prevGMatched.add(match);
            gaugePersists.push({ current: f, previous: prevGF[match] });
        } else {
            gaugeNew.push(f);
        }
    });
    prevGF.forEach((pf, i) => {
        if (!prevGMatched.has(i)) gaugeResolved.push(pf);
    });

    // Categorise twist faults
    const twistPersists = [], twistNew = [], twistResolved = [];
    const prevTMatched = new Set();
    allTF.forEach((f, i) => {
        if (isDismissed('twist', i)) return;
        const match = prevTF.findIndex((pf, pi) => !prevTMatched.has(pi) && locOverlaps(f, pf));
        if (match >= 0) {
            prevTMatched.add(match);
            twistPersists.push({ current: f, previous: prevTF[match] });
        } else {
            twistNew.push(f);
        }
    });
    prevTF.forEach((pf, i) => {
        if (!prevTMatched.has(i)) twistResolved.push(pf);
    });

    let html = `
        <div class="prev-run-info">
            Previous run: <strong>${previousRunData.filename || 'Loaded PDF'}</strong>
            ${previousRunData.metadata['Route ID'] ? ' | Route: ' + previousRunData.metadata['Route ID'] : ''}
            ${previousRunData.lineSpeed ? ' | Speed: ' + previousRunData.lineSpeed + ' mph' : ''}
            <button class="btn-clear-comparison" onclick="clearPreviousRun()">Remove</button>
        </div>
        <div class="comp-legend">
            <span class="comp-new">New fault</span>
            <span class="comp-resolved">Resolved</span>
            <span class="comp-persists">Persisting</span>
        </div>
        <div class="trace-controls">
            <label>
                <input type="checkbox" ${previousRunTraceEnabled ? 'checked' : ''} ${traceAvailable ? '' : 'disabled'}
                    onchange="setPreviousRunTraceEnabled(this.checked)">
                Show previous run traces
            </label>
            <label>
                Trace offset (yds)
                <input type="number" step="0.1" value="${previousRunTraceOffsetYards}"
                    ${traceAvailable ? '' : 'disabled'}
                    oninput="setPreviousRunOffset(this.value)">
            </label>
            <span>${traceAvailable ? 'Adjust offset to align traces.' : 'No trace data found in this PDF.'}</span>
        </div>
        <h4 style="font-size:13px;color:#1a1a2e;margin:12px 0 6px;">Gauge Faults Comparison</h4>
    `;

    if (gaugeNew.length + gaugeResolved.length + gaugePersists.length === 0) {
        html += '<p style="color:#888;font-size:12px;">No gauge faults in either run.</p>';
    } else {
        html += '<table class="comparison-table"><thead><tr><th>Status</th><th>Location</th><th>Details</th></tr></thead><tbody>';
        gaugeNew.forEach(f => {
            const c = classifyGaugeFault(f.worstGauge, lineSpeed, trackCat);
            html += `<tr class="comp-new"><td>NEW</td><td>${f.startLocation} - ${f.endLocation}</td><td>${f.worstGauge.toFixed(1)}mm ${c ? '(' + c.category + ')' : ''}</td></tr>`;
        });
        gaugePersists.forEach(p => {
            const c = classifyGaugeFault(p.current.worstGauge, lineSpeed, trackCat);
            html += `<tr class="comp-persists"><td>PERSISTS</td><td>${p.current.startLocation} - ${p.current.endLocation}</td><td>${p.current.worstGauge.toFixed(1)}mm ${c ? '(' + c.category + ')' : ''}</td></tr>`;
        });
        gaugeResolved.forEach(f => {
            html += `<tr class="comp-resolved"><td>RESOLVED</td><td>${f.startLocation} - ${f.endLocation}</td><td>Not present in current run</td></tr>`;
        });
        html += '</tbody></table>';
    }

    html += '<h4 style="font-size:13px;color:#1a1a2e;margin:16px 0 6px;">Twist Faults Comparison</h4>';

    if (twistNew.length + twistResolved.length + twistPersists.length === 0) {
        html += '<p style="color:#888;font-size:12px;">No twist faults in either run.</p>';
    } else {
        html += '<table class="comparison-table"><thead><tr><th>Status</th><th>Location</th><th>Details</th></tr></thead><tbody>';
        twistNew.forEach(f => {
            const isLt = f.manual ? f.curveRadiusLessThan400 : false;
            const c = classifyTwistFault(f.maxAbsTwist, lineSpeed, isLt);
            html += `<tr class="comp-new"><td>NEW</td><td>${f.startLocation} - ${f.endLocation}</td><td>${f.maxAbsTwist.toFixed(1)}mm ${c ? '(' + c.category + ')' : ''}</td></tr>`;
        });
        twistPersists.forEach(p => {
            const isLt = p.current.manual ? p.current.curveRadiusLessThan400 : false;
            const c = classifyTwistFault(p.current.maxAbsTwist, lineSpeed, isLt);
            html += `<tr class="comp-persists"><td>PERSISTS</td><td>${p.current.startLocation} - ${p.current.endLocation}</td><td>${p.current.maxAbsTwist.toFixed(1)}mm ${c ? '(' + c.category + ')' : ''}</td></tr>`;
        });
        twistResolved.forEach(f => {
            html += `<tr class="comp-resolved"><td>RESOLVED</td><td>${f.startLocation} - ${f.endLocation}</td><td>Not present in current run</td></tr>`;
        });
        html += '</tbody></table>';
    }

    html += `<p style="margin-top:10px;font-size:11px;color:#888;">
        Summary: ${gaugeNew.length + twistNew.length} new, ${gaugePersists.length + twistPersists.length} persisting, ${gaugeResolved.length + twistResolved.length} resolved
    </p>`;

    resultsDiv.innerHTML = html;
}

// ---- Export Excel ----
function exportExcel() {
    const wb = XLSX.utils.book_new();
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;

    const runName = document.getElementById('runNameInput').value;
    const inspector = document.getElementById('inspectorInput').value;
    const metaArr = [
        { Field: 'Run Name', Value: runName },
        { Field: 'Inspector', Value: inspector },
        { Field: 'Line Speed (mph)', Value: lineSpeed || 'Not set' },
        { Field: 'Track Category', Value: getTrackCat() || 'Not set' },
        ...Object.entries(metadata).map(([k, v]) => ({ Field: k, Value: v }))
    ];
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(metaArr), 'Survey Info');

    const allData = parsedData.map(r => ({
        Miles: r.miles,
        Yards: r.yards,
        'Gauge (mm)': r.gauge,
        'X-Level (mm)': r.xlevel,
        'Twist 1 (mm)': r.twist1,
        'Gauge Delta (mm)': Number.isFinite(r.gaugeDelta) ? r.gaugeDelta : '',
        Zone: r.zone
    }));
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(allData), 'All Data');

    const allGaugeFaultsExport = gaugeFaults.concat(manualGaugeFaults);
    const gaugeFaultNos = document.querySelectorAll('.fault-no-input[data-type="gauge"]');
    const gaugeRepeatCbs = document.querySelectorAll('.repeat-fault-cb[data-type="gauge"]');
    const gfData = allGaugeFaultsExport.map((f, i) => {
        if (isDismissed('gauge', i)) return null;
        const effective = getEffectiveFault('gauge', i, f);
        const c = classifyGaugeFault(effective.worstGauge, lineSpeed, getTrackCat());
        return {
            '#': i + 1,
            'Fault No.': gaugeFaultNos[i] ? gaugeFaultNos[i].value : '',
            'Start Location': effective.startLocation,
            'End Location': effective.endLocation,
            'Length (yds)': effective.length,
            'Worst Gauge (mm)': effective.worstGauge.toFixed(1),
            'Deviation (mm)': effective.deviation,
            'Fault Type': c ? c.type : (effective.direction === 'wide' ? 'Wide Gauge' : 'Tight Gauge'),
            'Category': c ? c.category : '',
            'Required Action': c ? c.action : '',
            'Repeat Fault': gaugeRepeatCbs[i] && gaugeRepeatCbs[i].checked ? 'Yes' : 'No',
            'Edit Commentary': effective.edit ? effective.edit.commentary : '',
            'Edited By': effective.edit ? effective.edit.inspector : ''
        };
    }).filter(Boolean);
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(gfData.length ? gfData : [{ Info: 'No gauge faults' }]), 'Gauge Faults');

    const allTwistFaultsExport = twistFaults.concat(manualTwistFaults);
    const twistFaultNos = document.querySelectorAll('.fault-no-input[data-type="twist"]');
    const twistRepeatCbs = document.querySelectorAll('.repeat-fault-cb[data-type="twist"]');
    const tfData = allTwistFaultsExport.map((f, i) => {
        if (isDismissed('twist', i)) return null;
        const effective = getEffectiveFault('twist', i, f);
        const radius = f.manual ? f.curveRadiusLessThan400 : twistFaultRadiusSettings[i];
        const c = classifyTwistFault(effective.maxAbsTwist, lineSpeed, radius);
        return {
            '#': i + 1,
            'Fault No.': twistFaultNos[i] ? twistFaultNos[i].value : '',
            'Start Location': effective.startLocation,
            'End Location': effective.endLocation,
            'Length (yds)': effective.length,
            'Max |Twist| (mm)': effective.maxAbsTwist.toFixed(1),
            'Worst Value (mm)': effective.worstValue.toFixed(1),
            'Curve Radius': radius ? '< 400m' : '>= 400m',
            'Category': c ? c.category : '',
            'Required Action': c ? c.action : '',
            'Repeat Fault': twistRepeatCbs[i] && twistRepeatCbs[i].checked ? 'Yes' : 'No',
            'Edit Commentary': effective.edit ? effective.edit.commentary : '',
            'Edited By': effective.edit ? effective.edit.inspector : ''
        };
    }).filter(Boolean);
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(tfData.length ? tfData : [{ Info: 'No twist faults' }]), 'Twist Faults');

    const invalidatedData = getInvalidatedFaultRows().map((row, i) => ({
        '#': i + 1,
        'Fault Type': row.typeLabel,
        'Location': row.locationText,
        'Value': row.valueText,
        'Removed By': row.removedBy,
        'Removed At': row.removedAt,
        'Reason': row.reason
    }));
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(invalidatedData.length ? invalidatedData : [{ Info: 'No invalidated faults' }]), 'Invalidated Faults');

    const gvData = gaugeVariationFaults.map((f, i) => {
        const effective = getEffectiveFault('gaugeVariation', i, f);
        const c = classifyGaugeVariationFault(effective.maxAbsGaugeDelta, lineSpeed);
        return {
            '#': i + 1,
            'Start Location': effective.startLocation,
            'End Location': effective.endLocation,
            'Length (yds)': effective.length,
            'Max |Gauge Delta| (mm)': effective.maxAbsGaugeDelta.toFixed(1),
            'Worst Value (mm)': effective.worstGaugeDelta.toFixed(1),
            'Category': c ? c.category : '',
            'Required Action': c ? c.action : '',
            'Edit Commentary': effective.edit ? effective.edit.commentary : '',
            'Edited By': effective.edit ? effective.edit.inspector : ''
        };
    });
    XLSX.utils.book_append_sheet(wb, XLSX.utils.json_to_sheet(gvData.length ? gvData : [{ Info: 'No gauge variation faults' }]), 'Gauge Variation');

    const filename = 'TrackInspection_' + (metadata['Route ID'] || 'Report') + '_' + (metadata['Track ID'] || '') + '.xlsx';
    XLSX.writeFile(wb, filename);
}

// ---- Export PDF ----
function exportPDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('landscape', 'mm', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;

    // Page 1: Survey info + summary
    const pdfRunName = document.getElementById('runNameInput').value;
    const pdfInspector = document.getElementById('inspectorInput').value;

    doc.setFontSize(18);
    doc.setTextColor(26, 26, 46);
    doc.text('Track Inspection Report', 14, 20);
    doc.setFontSize(10);
    doc.setTextColor(100);
    const route = metadata['Route ID'] || '';
    const track = metadata['Track ID'] || '';
    const pdfTrackCat = getTrackCat();
    doc.text(`Run Name: ${pdfRunName}  |  Inspector: ${pdfInspector}  |  Line Speed: ${lineSpeed || 'N/A'} mph  |  Track Cat: ${pdfTrackCat || 'N/A'}`, 14, 28);
    doc.text(`Route: ${route}  |  Track: ${track}  |  ${metadata['Job Reference'] || ''}`, 14, 34);
    doc.text(`${metadata['Start Location'] || ''} to ${metadata['End Location'] || ''}`, 14, 40);
    doc.text(`Date: ${metadata['Start Time'] || ''}`, 14, 46);
    let summaryStartY = 54;
    if (runTraceFlipped) {
        const flipReasonText = runFlipReason ? ` (${runFlipReason})` : '';
        doc.setFontSize(9);
        doc.setTextColor(120);
        doc.text(`Note: Trace flipped to low-to-high mileage${flipReasonText}. Twist and cant signs inverted.`, 14, 52);
        summaryStartY = 60;
    }

    // Summary table
    doc.autoTable({
        startY: summaryStartY,
        head: [['Total Points', 'Gauge Faults', 'Twist Faults', 'Min Gauge', 'Max Gauge', 'Max |Twist|']],
        body: [[
            parsedData.length,
            getVisibleGaugeFaults().length,
            getVisibleTwistFaults().length,
            Math.min(...parsedData.map(r => r.gauge)).toFixed(1) + ' mm',
            Math.max(...parsedData.map(r => r.gauge)).toFixed(1) + ' mm',
            (parsedData.filter(r => r.twist1 !== null).length > 0
                ? Math.max(...parsedData.filter(r => r.twist1 !== null).map(r => Math.abs(r.twist1))).toFixed(1) + ' mm'
                : 'N/A')
        ]],
        theme: 'grid',
        headStyles: { fillColor: [26, 26, 46] },
        styles: { fontSize: 9 }
    });

    // Add chart images
    const gaugeCanvases = Array.from(document.querySelectorAll('#gaugeCharts canvas'));
    const twistCanvases = Array.from(document.querySelectorAll('#twistCharts canvas'));
    const chartW = pageWidth - 28;
    const baseChartH = 55;
    const chartGap = 4;
    const pageHeight = doc.internal.pageSize.getHeight();
    let chartY = doc.lastAutoTable.finalY + 8;

    const getCanvasImageData = (canvas) => {
        if (!canvas || !canvas.width || !canvas.height) return null;
        try {
            const dataUrl = canvas.toDataURL('image/png');
            if (!dataUrl || dataUrl === 'data:,' || !dataUrl.startsWith('data:image/png')) return null;
            return dataUrl;
        } catch (err) {
            console.warn('Skipping chart image due to PNG export error:', err);
            return null;
        }
    };

    const maxSegments = Math.max(gaugeCanvases.length, twistCanvases.length);
    for (let i = 0; i < maxSegments; i++) {
        const gaugeCanvas = gaugeCanvases[i];
        const twistCanvas = twistCanvases[i];
        if (!gaugeCanvas || !twistCanvas) continue;
        const gaugeImage = getCanvasImageData(gaugeCanvas);
        const twistImage = getCanvasImageData(twistCanvas);
        if (!gaugeImage || !twistImage) continue;
        let chartH = baseChartH;
        let blockHeight = chartH * 2 + (chartGap * 2);
        const availableHeight = pageHeight - chartY - 10;
        if (availableHeight < blockHeight) {
            const scaled = Math.max((availableHeight - (chartGap * 2)) / 2, 36);
            if (scaled < chartH) {
                chartH = scaled;
                blockHeight = chartH * 2 + (chartGap * 2);
            }
        }
        if (chartY + blockHeight > pageHeight - 10) {
            doc.addPage();
            chartY = 20;
            chartH = baseChartH;
            blockHeight = chartH * 2 + (chartGap * 2);
        }
        doc.addImage(gaugeImage, 'PNG', 14, chartY, chartW, chartH);
        doc.addImage(twistImage, 'PNG', 14, chartY + chartH + chartGap, chartW, chartH);
        chartY += blockHeight;
    }

    // Page 2: Gauge Faults
    doc.addPage();
    doc.setFontSize(14);
    doc.setTextColor(26, 26, 46);
    doc.text('Gauge Faults (Table 5 Limits) - Line Speed: ' + (lineSpeed || 'N/A') + ' mph - Track Cat: ' + (getTrackCat() || 'N/A'), 14, 20);

    const allGaugeFaultsPdf = gaugeFaults.concat(manualGaugeFaults);
    const visibleGaugeFaultsPdf = allGaugeFaultsPdf.filter((_, i) => !isDismissed('gauge', i));
    const pdfGaugeFaultNos = document.querySelectorAll('.fault-no-input[data-type="gauge"]');
    const pdfGaugeRepeatCbs = document.querySelectorAll('.repeat-fault-cb[data-type="gauge"]');
    if (visibleGaugeFaultsPdf.length === 0) {
        doc.setFontSize(11);
        doc.setTextColor(100);
        doc.text('No gauge faults detected.', 14, 32);
    } else {
        const gaugeTableBody = allGaugeFaultsPdf.map((f, i) => {
            if (isDismissed('gauge', i)) return null;
            const effective = getEffectiveFault('gauge', i, f);
            const c = classifyGaugeFault(effective.worstGauge, lineSpeed, getTrackCat());
            const editNote = effective.edit ? '[EDITED by ' + effective.edit.inspector + ': ' + effective.edit.commentary + ']' : '';
            let actionCol = c ? c.action : '';
            if (editNote) actionCol += '\n' + editNote;
            return [
                (f.manual ? '* ' : '') + (i + 1),
                pdfGaugeFaultNos[i] ? pdfGaugeFaultNos[i].value : '',
                effective.startLocation, effective.endLocation, effective.length,
                effective.worstGauge.toFixed(1), effective.deviation,
                c ? c.type : (effective.direction === 'wide' ? 'Wide' : 'Tight'),
                c ? c.category : '',
                actionCol,
                pdfGaugeRepeatCbs[i] && pdfGaugeRepeatCbs[i].checked ? 'Yes' : 'No'
            ];
        }).filter(Boolean);

        doc.autoTable({
            startY: 28,
            head: [['#', 'Fault No.', 'Start', 'End', 'Length', 'Worst Gauge', 'Deviation', 'Type', 'Cat.', 'Required Action', 'Repeat']],
            body: gaugeTableBody,
            theme: 'striped',
            headStyles: { fillColor: [26, 26, 46] },
            styles: { fontSize: 7 },
            columnStyles: { 9: { cellWidth: 50 } }
        });

    }

    // Gauge sign-off
    const gSignY = visibleGaugeFaultsPdf.length > 0 ? doc.lastAutoTable.finalY + 12 : 44;
    doc.setFontSize(12);
    doc.setTextColor(26, 26, 46);
    doc.text('Section Manager Sign-Off', 14, gSignY);
    doc.setFontSize(9);
    doc.setTextColor(80);
    doc.text(`Name: ${document.getElementById('gaugeSignOffName').value}`, 14, gSignY + 8);
    doc.text(`Date: ${document.getElementById('gaugeSignOffDate').value}`, 14, gSignY + 14);
    doc.text(`Signature: ${document.getElementById('gaugeSignOffSig').value}`, 120, gSignY + 8);
    doc.text(`Comments: ${document.getElementById('gaugeSignOffComments').value}`, 120, gSignY + 14);

    // Page 3: Twist Faults
    doc.addPage();
    doc.setFontSize(14);
    doc.setTextColor(26, 26, 46);
    doc.text('Twist Faults - 3m Base (Table 3 Limits) - Line Speed: ' + (lineSpeed || 'N/A') + ' mph', 14, 20);

    const allTwistFaultsPdf = twistFaults.concat(manualTwistFaults);
    const visibleTwistFaultsPdf = allTwistFaultsPdf.filter((_, i) => !isDismissed('twist', i));
    const pdfTwistFaultNos = document.querySelectorAll('.fault-no-input[data-type="twist"]');
    const pdfTwistRepeatCbs = document.querySelectorAll('.repeat-fault-cb[data-type="twist"]');
    if (visibleTwistFaultsPdf.length === 0) {
        doc.setFontSize(11);
        doc.setTextColor(100);
        doc.text('No twist faults detected.', 14, 32);
    } else {
        const twistTableBody = allTwistFaultsPdf.map((f, i) => {
            if (isDismissed('twist', i)) return null;
            const effective = getEffectiveFault('twist', i, f);
            const radius = f.manual ? f.curveRadiusLessThan400 : twistFaultRadiusSettings[i];
            const c = classifyTwistFault(effective.maxAbsTwist, lineSpeed, radius);
            const editNote = effective.edit ? '[EDITED by ' + effective.edit.inspector + ': ' + effective.edit.commentary + ']' : '';
            let actionCol = c ? c.action : '';
            if (editNote) actionCol += '\n' + editNote;
            return [
                (f.manual ? '* ' : '') + (i + 1),
                pdfTwistFaultNos[i] ? pdfTwistFaultNos[i].value : '',
                effective.startLocation, effective.endLocation, effective.length,
                effective.maxAbsTwist.toFixed(1), effective.worstValue.toFixed(1),
                radius ? '< 400m' : '>= 400m',
                c ? c.category : '',
                actionCol,
                pdfTwistRepeatCbs[i] && pdfTwistRepeatCbs[i].checked ? 'Yes' : 'No'
            ];
        }).filter(Boolean);

        doc.autoTable({
            startY: 28,
            head: [['#', 'Fault No.', 'Start', 'End', 'Length', 'Max |Twist|', 'Worst', 'Curve R', 'Cat.', 'Required Action', 'Repeat']],
            body: twistTableBody,
            theme: 'striped',
            headStyles: { fillColor: [26, 26, 46] },
            styles: { fontSize: 7 },
            columnStyles: { 9: { cellWidth: 50 } }
        });

    }

    // Twist sign-off
    const tSignY = visibleTwistFaultsPdf.length > 0 ? doc.lastAutoTable.finalY + 12 : 44;
    doc.setFontSize(12);
    doc.setTextColor(26, 26, 46);
    doc.text('Section Manager Sign-Off', 14, tSignY);
    doc.setFontSize(9);
    doc.setTextColor(80);
    doc.text(`Name: ${document.getElementById('twistSignOffName').value}`, 14, tSignY + 8);
    doc.text(`Date: ${document.getElementById('twistSignOffDate').value}`, 14, tSignY + 14);
    doc.text(`Signature: ${document.getElementById('twistSignOffSig').value}`, 120, tSignY + 8);
    doc.text(`Comments: ${document.getElementById('twistSignOffComments').value}`, 120, tSignY + 14);

    // Page 4: Invalidated Faults
    doc.addPage();
    doc.setFontSize(14);
    doc.setTextColor(26, 26, 46);
    doc.text('Invalidated Faults', 14, 20);

    const invalidatedRowsPdf = getInvalidatedFaultRows();
    if (invalidatedRowsPdf.length === 0) {
        doc.setFontSize(11);
        doc.setTextColor(100);
        doc.text('No invalidated faults.', 14, 32);
    } else {
        const invalidatedTableBody = invalidatedRowsPdf.map((row, i) => [
            i + 1,
            row.typeLabel,
            row.locationText,
            row.valueText,
            row.removedBy,
            row.removedAt,
            row.reason
        ]);
        doc.autoTable({
            startY: 28,
            head: [['#', 'Type', 'Location', 'Value', 'Removed By', 'Removed At', 'Reason']],
            body: invalidatedTableBody,
            theme: 'striped',
            headStyles: { fillColor: [26, 26, 46] },
            styles: { fontSize: 8 },
            columnStyles: { 2: { cellWidth: 60 }, 6: { cellWidth: 90 } }
        });
    }

    // Page 5: Gauge Variation Faults
    doc.addPage();
    doc.setFontSize(14);
    doc.setTextColor(26, 26, 46);
    doc.text('Gauge Variation Faults - 3m Base - Line Speed: ' + (lineSpeed || 'N/A') + ' mph', 14, 20);

    if (gaugeVariationFaults.length === 0) {
        doc.setFontSize(11);
        doc.setTextColor(100);
        doc.text('No gauge variation faults detected (or Gauge Delta unavailable).', 14, 32);
    } else {
        const gvTableBody = gaugeVariationFaults.map((f, i) => {
            const effective = getEffectiveFault('gaugeVariation', i, f);
            const c = classifyGaugeVariationFault(effective.maxAbsGaugeDelta, lineSpeed);
            const editNote = effective.edit ? '[EDITED by ' + effective.edit.inspector + ': ' + effective.edit.commentary + ']' : '';
            return [
                i + 1,
                effective.startLocation,
                effective.endLocation,
                effective.length,
                effective.maxAbsGaugeDelta.toFixed(1),
                effective.worstGaugeDelta.toFixed(1),
                c ? c.category : '',
                (c ? c.action : '') + (editNote ? '\n' + editNote : '')
            ];
        });

        doc.autoTable({
            startY: 28,
            head: [['#', 'Start', 'End', 'Length', 'Max |Gauge Delta|', 'Worst', 'Cat.', 'Required Action']],
            body: gvTableBody,
            theme: 'striped',
            headStyles: { fillColor: [26, 26, 46] },
            styles: { fontSize: 8 },
            columnStyles: { 7: { cellWidth: 70 } }
        });
    }

    // Embed fault data as JSON in PDF properties for run-on-run comparison
    const allGFExportPdf = gaugeFaults.concat(manualGaugeFaults);
    const allTFExportPdf = twistFaults.concat(manualTwistFaults);
    const embedData = {
        gaugeFaults: allGFExportPdf.map((f, i) => {
            if (isDismissed('gauge', i)) return null;
            const effective = getEffectiveFault('gauge', i, f);
            return {
                startMiles: effective.startMiles, startYards: effective.startYards,
                endMiles: effective.endMiles, endYards: effective.endYards,
                startLocation: effective.startLocation, endLocation: effective.endLocation,
                worstGauge: effective.worstGauge, deviation: effective.deviation,
                direction: effective.direction, length: effective.length,
                edit: effective.edit || null
            };
        }).filter(Boolean),
        twistFaults: allTFExportPdf.map((f, i) => {
            if (isDismissed('twist', i)) return null;
            const effective = getEffectiveFault('twist', i, f);
            return {
                startMiles: effective.startMiles, startYards: effective.startYards,
                endMiles: effective.endMiles, endYards: effective.endYards,
                startLocation: effective.startLocation, endLocation: effective.endLocation,
                maxAbsTwist: effective.maxAbsTwist, worstValue: effective.worstValue, length: effective.length,
                edit: effective.edit || null
            };
        }).filter(Boolean),
        gaugeVariationFaults: gaugeVariationFaults.map((f, i) => {
            const effective = getEffectiveFault('gaugeVariation', i, f);
            return {
                startMiles: effective.startMiles, startYards: effective.startYards,
                endMiles: effective.endMiles, endYards: effective.endYards,
                startLocation: effective.startLocation, endLocation: effective.endLocation,
                maxAbsGaugeDelta: effective.maxAbsGaugeDelta, worstGaugeDelta: effective.worstGaugeDelta, length: effective.length,
                edit: effective.edit || null
            };
        }),
        traceData: parsedData.map(r => ({
            miles: r.miles,
            yards: r.yards,
            gauge: r.gauge,
            gaugeDelta: r.gaugeDelta,
            twist1: r.twist1,
            xlevel: r.xlevel
        })),
        traceFlipped: runTraceFlipped,
        flipReason: runFlipReason,
        metadata: { 'Route ID': metadata['Route ID'] || '', 'Track ID': metadata['Track ID'] || '' },
        lineSpeed: lineSpeed,
        trackCat: getTrackCat(),
        faultEdits: faultEdits,
        invalidatedFaults: getInvalidatedFaultRows().map(row => ({
            faultType: row.faultType,
            location: row.locationText,
            value: row.valueText,
            removedBy: row.removedBy,
            removedAt: row.removedAt,
            reason: row.reason
        }))
    };
    doc.setProperties({
        title: 'Track Inspection Report - ' + (metadata['Route ID'] || ''),
        subject: 'Amber Trolley Track Inspection',
        creator: 'Amber Trolley Report Generator',
        keywords: 'AmberTrolleyData:' + JSON.stringify(embedData)
    });

    const filename = 'TrackInspection_' + (metadata['Route ID'] || 'Report') + '_' +
        (metadata['Track ID'] || '') + '.pdf';
    doc.save(filename);
}
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amber Trolley - Track Inspection Report Generator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f0f2f5; color: #333; }

        .upload-screen {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; padding: 40px;
        }
        .upload-screen h1 { font-size: 28px; margin-bottom: 8px; color: #1a1a2e; }
        .upload-screen p { color: #666; margin-bottom: 30px; }
        .drop-zone {
            width: 500px; max-width: 90vw; height: 200px;
            border: 3px dashed #aab; border-radius: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s; background: #fff;
        }
        .drop-zone:hover, .drop-zone.dragover { border-color: #4a6cf7; background: #f0f4ff; }
        .drop-zone span { font-size: 16px; color: #666; }
        .drop-zone .icon { font-size: 48px; margin-bottom: 12px; }
        .drop-zone input { display: none; }

        .report-container { display: none; max-width: 1400px; margin: 0 auto; padding: 20px; }
        .report-container.active { display: block; }

        .toolbar {
            display: flex; gap: 10px; align-items: center; margin-bottom: 20px;
            padding: 16px 20px; background: #1a1a2e; border-radius: 10px; flex-wrap: wrap;
        }
        .toolbar h2 { color: #fff; font-size: 18px; flex: 1; }
        .toolbar button {
            padding: 8px 18px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 14px; font-weight: 600; transition: all 0.2s;
        }
        .btn-excel { background: #1d6f42; color: #fff; }
        .btn-excel:hover { background: #175c36; }
        .btn-pdf { background: #c0392b; color: #fff; }
        .btn-pdf:hover { background: #a93226; }
        .btn-back { background: #555; color: #fff; }
        .btn-back:hover { background: #444; }

        .tabs {
            display: flex; gap: 4px; margin-bottom: 20px; background: #ddd; padding: 4px;
            border-radius: 8px;
        }
        .tab {
            flex: 1; padding: 12px 16px; text-align: center; border: none; background: none;
            cursor: pointer; border-radius: 6px; font-size: 14px; font-weight: 600;
            color: #666; transition: all 0.2s;
        }
        .tab.active { background: #fff; color: #1a1a2e; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

        .page { display: none; }
        .page.active { display: block; }

        .card {
            background: #fff; border-radius: 10px; padding: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); margin-bottom: 20px;
        }
        .card h3 { font-size: 16px; color: #1a1a2e; margin-bottom: 16px; border-bottom: 2px solid #eee; padding-bottom: 8px; }

        .meta-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 8px 24px;
        }
        .meta-item { display: flex; justify-content: space-between; padding: 4px 0; font-size: 13px; }
        .meta-item .label { color: #888; }
        .meta-item .value { font-weight: 600; color: #333; }

        .chart-row { display: grid; grid-template-columns: 1fr; gap: 20px; }
        .chart-wrapper { position: relative; height: 300px; }
        canvas { width: 100% !important; }

        table {
            width: 100%; border-collapse: collapse; font-size: 12px;
        }
        thead th {
            background: #1a1a2e; color: #fff; padding: 8px 10px; text-align: left;
            font-weight: 600; position: sticky; top: 0; white-space: nowrap;
        }
        tbody td { padding: 6px 10px; border-bottom: 1px solid #eee; }
        tbody tr:hover { background: #f8f9ff; }

        .summary-stats {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px; margin-bottom: 20px;
        }
        .stat-card {
            background: #fff; border-radius: 10px; padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); text-align: center;
        }
        .stat-card .number { font-size: 32px; font-weight: 700; color: #1a1a2e; }
        .stat-card .label { font-size: 13px; color: #888; margin-top: 4px; }
        .stat-card.warning .number { color: #e67e22; }
        .stat-card.danger .number { color: #c0392b; }

        .cat-ial { background: #f8d7da; border-left: 4px solid #c0392b; }
        .cat-ial-block { background: #f5c6cb; border-left: 4px solid #721c24; }
        .cat-il { background: #fff3cd; border-left: 4px solid #e67e22; }
        .cat-al { background: #d4edda; border-left: 4px solid #28a745; }

        .badge {
            display: inline-block; padding: 2px 8px; border-radius: 4px;
            font-size: 11px; font-weight: 700; color: #fff; white-space: nowrap;
        }
        .badge-ial { background: #c0392b; }
        .badge-il { background: #e67e22; }
        .badge-al { background: #28a745; }

        .run-info-bar {
            display: flex; gap: 20px; align-items: center; margin-bottom: 20px;
            padding: 16px 20px; background: #fff; border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); flex-wrap: wrap;
        }
        .run-info-bar label { font-size: 13px; color: #888; font-weight: 600; }
        .run-info-bar input, .run-info-bar select {
            padding: 6px 12px; border: 1px solid #ccc; border-radius: 6px;
            font-size: 14px; font-family: inherit; min-width: 120px;
        }
        .run-info-bar input:focus, .run-info-bar select:focus { outline: none; border-color: #4a6cf7; box-shadow: 0 0 0 2px rgba(74,108,247,0.15); }
        .run-info-group { display: flex; flex-direction: column; gap: 4px; }

        .speed-warning {
            display: none; padding: 10px 16px; background: #fff3cd; border: 1px solid #ffc107;
            border-radius: 8px; margin-bottom: 16px; font-size: 13px; color: #856404;
        }
        .speed-warning.visible { display: block; }

        .radius-select {
            padding: 3px 6px; border: 1px solid #ccc; border-radius: 4px;
            font-size: 11px; background: #fff; cursor: pointer;
        }

        .sign-off-section {
            margin-top: 20px; padding: 20px; background: #fafafa; border: 2px solid #ddd;
            border-radius: 10px;
        }
        .sign-off-section h4 { font-size: 14px; color: #1a1a2e; margin-bottom: 16px; border-bottom: 2px solid #ccc; padding-bottom: 8px; }
        .sign-off-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 16px 32px;
        }
        .sign-off-field { display: flex; flex-direction: column; gap: 4px; }
        .sign-off-field label { font-size: 12px; color: #888; font-weight: 600; text-transform: uppercase; }
        .sign-off-field input {
            padding: 8px 12px; border: none; border-bottom: 2px solid #999;
            background: transparent; font-size: 14px; font-family: inherit;
        }
        .sign-off-field input:focus { outline: none; border-bottom-color: #4a6cf7; }

        .note-box {
            margin-top: 12px; padding: 10px 14px; background: #f8f9fa; border-left: 3px solid #6c757d;
            font-size: 12px; color: #555; line-height: 1.5;
        }

        .run-selector-bar {
            display: flex; gap: 10px; align-items: center; margin-bottom: 20px;
            padding: 14px 20px; background: #fff; border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08); flex-wrap: wrap;
        }
        .run-selector-bar label { font-size: 13px; color: #888; font-weight: 600; }
        .run-selector-bar select {
            padding: 6px 12px; border: 1px solid #ccc; border-radius: 6px;
            font-size: 14px; font-family: inherit; min-width: 200px;
        }
        .run-selector-bar select:focus { outline: none; border-color: #4a6cf7; box-shadow: 0 0 0 2px rgba(74,108,247,0.15); }
        .run-selector-bar .run-count { font-size: 12px; color: #666; padding: 4px 10px; background: #eef; border-radius: 12px; }

        .btn-add-fault {
            padding: 8px 16px; border: 2px dashed #4a6cf7; border-radius: 6px;
            background: #f0f4ff; color: #4a6cf7; cursor: pointer; font-size: 13px;
            font-weight: 600; transition: all 0.2s; margin-bottom: 12px;
        }
        .btn-add-fault:hover { background: #4a6cf7; color: #fff; }

        .manual-fault-tag {
            display: inline-block; padding: 1px 6px; border-radius: 3px;
            font-size: 9px; font-weight: 700; color: #fff; background: #6c757d;
            margin-left: 4px; vertical-align: middle;
        }

        .btn-remove-fault {
            padding: 2px 6px; border: none; background: #dc3545; color: #fff;
            border-radius: 3px; cursor: pointer; font-size: 10px; font-weight: 700;
        }
        .btn-remove-fault:hover { background: #c82333; }

        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;
        }
        .modal-overlay.active { display: flex; }
        .modal {
            background: #fff; border-radius: 12px; padding: 28px; width: 500px; max-width: 90vw;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }
        .modal h3 { font-size: 18px; color: #1a1a2e; margin-bottom: 20px; }
        .modal-field { margin-bottom: 14px; }
        .modal-field label { display: block; font-size: 12px; color: #888; font-weight: 600; text-transform: uppercase; margin-bottom: 4px; }
        .modal-field input, .modal-field select {
            width: 100%; padding: 8px 12px; border: 1px solid #ccc; border-radius: 6px;
            font-size: 14px; font-family: inherit;
        }
        .modal-field input:focus, .modal-field select:focus { outline: none; border-color: #4a6cf7; }
        .modal-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .modal-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; }
        .modal-actions button {
            padding: 8px 20px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 14px; font-weight: 600;
        }
        .btn-modal-cancel { background: #eee; color: #666; }
        .btn-modal-cancel:hover { background: #ddd; }
        .btn-modal-save { background: #4a6cf7; color: #fff; }
        .btn-modal-save:hover { background: #3a5ce5; }

        @media print {
            .toolbar, .tabs, .run-selector-bar { display: none; }
            .page { display: block !important; page-break-after: always; }
            .card { box-shadow: none; border: 1px solid #ddd; }
        }
    </style>
</head>
<body>

<div class="upload-screen" id="uploadScreen">
    <h1>Amber Trolley Report Generator</h1>
    <p>Upload a raw data HTML file from the Amber trolley to generate an inspection report</p>
    <div class="drop-zone" id="dropZone">
        <div class="icon">&#128196;</div>
        <span>Drop file(s) here or click to browse â€” select multiple for bulk upload</span>
        <input type="file" id="fileInput" accept=".html,.htm,.txt,.csv" multiple>
    </div>
    <div style="margin-top: 30px; max-width: 560px;">
        <p style="font-size: 13px; color: #999; text-align: center;">
            Classifies twist and gauge faults against Table 3 &amp; Table 5 limits
            (IAL / IL / AL) with speed-dependent thresholds and remedial actions.
            Upload multiple files at once to process several runs. Export as Excel or PDF.
        </p>
    </div>
</div>

<div class="report-container" id="reportContainer">
    <div class="toolbar">
        <h2 id="reportTitle">Track Inspection Report</h2>
        <button class="btn-back" onclick="goBack()">Load New File</button>
        <button class="btn-excel" onclick="exportExcel()">Export Excel</button>
        <button class="btn-pdf" onclick="exportPDF()">Export PDF</button>
    </div>

    <div class="run-selector-bar" id="runSelectorBar" style="display:none;">
        <label>Active Run</label>
        <select id="runSelector" onchange="switchRun(this.value)"></select>
        <span class="run-count" id="runCount"></span>
    </div>

    <div class="run-info-bar">
        <div class="run-info-group">
            <label>Run Name</label>
            <input type="text" id="runNameInput" placeholder="Enter run name...">
        </div>
        <div class="run-info-group">
            <label>Inspector</label>
            <input type="text" id="inspectorInput" placeholder="Enter inspector name...">
        </div>
        <div class="run-info-group">
            <label>Line Speed (mph)</label>
            <input type="number" id="lineSpeedInput" placeholder="e.g. 75" min="5" max="125" style="width:100px;">
        </div>
    </div>

    <div class="speed-warning" id="speedWarning">
        Please enter a Line Speed (5-125 mph) above to classify faults against the correct thresholds.
    </div>

    <div class="tabs">
        <button class="tab active" data-page="overview">Overview &amp; Graphs</button>
        <button class="tab" data-page="gaugeFaults">Gauge Faults</button>
        <button class="tab" data-page="twistFaults">Twist Faults</button>
    </div>

    <!-- Page 1: Overview & Graphs -->
    <div class="page active" id="page-overview">
        <div class="card">
            <h3>Survey Information</h3>
            <div class="meta-grid" id="metaGrid"></div>
        </div>

        <div class="summary-stats" id="summaryStats"></div>

        <div class="card">
            <h3>Gauge Profile (mm)</h3>
            <div class="chart-wrapper"><canvas id="gaugeChart"></canvas></div>
        </div>
        <div class="card">
            <h3>Twist over 3m (mm)</h3>
            <div class="chart-wrapper"><canvas id="twistChart"></canvas></div>
        </div>
    </div>

    <!-- Page 2: Gauge Faults -->
    <div class="page" id="page-gaugeFaults">
        <div class="card">
            <h3>Gauge Faults (Table 5 Limits)</h3>
            <p style="margin-bottom: 12px; color: #666; font-size: 13px;">
                Wide gauge and tight gauge faults classified per Table 5 thresholds for the configured line speed.
            </p>
            <button class="btn-add-fault" onclick="openManualGaugeFaultModal()">+ Add Manual Gauge Fault</button>
            <div style="overflow-x: auto;">
                <table id="gaugeFaultTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Fault No.</th>
                            <th>Start Location</th>
                            <th>End Location</th>
                            <th>Length (yds)</th>
                            <th>Worst Gauge (mm)</th>
                            <th>Deviation (mm)</th>
                            <th>Fault Type</th>
                            <th>Category</th>
                            <th>Required Action</th>
                            <th>Repeat</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="note-box">
                <strong>Note 1:</strong> These actions assume no significant associated faults at the same location. If other faults exist, complete the action to a shorter timescale.<br>
                <strong>Note 2:</strong> These are based upon nominal gauge for that type of track. Any design gauge widening is to be added to the lower limit for the action threshold.
            </div>
            <div class="sign-off-section">
                <h4>Section Manager Sign-Off</h4>
                <div class="sign-off-grid">
                    <div class="sign-off-field">
                        <label>Name</label>
                        <input type="text" id="gaugeSignOffName" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Date</label>
                        <input type="date" id="gaugeSignOffDate">
                    </div>
                    <div class="sign-off-field">
                        <label>Signature</label>
                        <input type="text" id="gaugeSignOffSig" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Comments</label>
                        <input type="text" id="gaugeSignOffComments" placeholder="">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Page 3: Twist Faults -->
    <div class="page" id="page-twistFaults">
        <div class="card">
            <h3>Twist Faults - 3m Base (Table 3 Limits)</h3>
            <p style="margin-bottom: 12px; color: #666; font-size: 13px;">
                Twist faults classified per Table 3 thresholds. Set the curve radius toggle per fault to adjust IL timescales.
            </p>
            <button class="btn-add-fault" onclick="openManualTwistFaultModal()">+ Add Manual Twist Fault</button>
            <div style="overflow-x: auto;">
                <table id="twistFaultTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Fault No.</th>
                            <th>Start Location</th>
                            <th>End Location</th>
                            <th>Length (yds)</th>
                            <th>Max |Twist| (mm)</th>
                            <th>Worst Value (mm)</th>
                            <th>Curve Radius</th>
                            <th>Category</th>
                            <th>Required Action</th>
                            <th>Repeat</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="note-box">
                <strong>Note 1:</strong> Where twist faults at Intervention Limit or above are adjacent to structures with tight clearances, complete the action to a shorter timescale.<br>
                <strong>Note 2:</strong> These actions assume no significant associated faults at the same location. If other faults exist, complete the action to a shorter timescale.
            </div>
            <div class="sign-off-section">
                <h4>Section Manager Sign-Off</h4>
                <div class="sign-off-grid">
                    <div class="sign-off-field">
                        <label>Name</label>
                        <input type="text" id="twistSignOffName" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Date</label>
                        <input type="date" id="twistSignOffDate">
                    </div>
                    <div class="sign-off-field">
                        <label>Signature</label>
                        <input type="text" id="twistSignOffSig" placeholder="">
                    </div>
                    <div class="sign-off-field">
                        <label>Comments</label>
                        <input type="text" id="twistSignOffComments" placeholder="">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Manual Gauge Fault Modal -->
<div class="modal-overlay" id="gaugeModal">
    <div class="modal">
        <h3>Add Manual Gauge Fault</h3>
        <div class="modal-row">
            <div class="modal-field">
                <label>Start Miles</label>
                <input type="number" id="mgStartMiles" step="1" min="0" placeholder="e.g. 21">
            </div>
            <div class="modal-field">
                <label>Start Yards</label>
                <input type="number" id="mgStartYards" step="0.1" min="0" placeholder="e.g. 1160.0">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>End Miles</label>
                <input type="number" id="mgEndMiles" step="1" min="0" placeholder="e.g. 21">
            </div>
            <div class="modal-field">
                <label>End Yards</label>
                <input type="number" id="mgEndYards" step="0.1" min="0" placeholder="e.g. 1165.0">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>Worst Gauge (mm)</label>
                <input type="number" id="mgWorstGauge" step="0.1" placeholder="e.g. 1450.5">
            </div>
            <div class="modal-field">
                <label>Fault Type</label>
                <select id="mgFaultDirection">
                    <option value="wide">Wide Gauge</option>
                    <option value="tight">Tight Gauge</option>
                </select>
            </div>
        </div>
        <div class="modal-field">
            <label>Fault No. (optional)</label>
            <input type="text" id="mgFaultNo" placeholder="e.g. GF-001">
        </div>
        <div class="modal-actions">
            <button class="btn-modal-cancel" onclick="closeModal('gaugeModal')">Cancel</button>
            <button class="btn-modal-save" onclick="saveManualGaugeFault()">Add Fault</button>
        </div>
    </div>
</div>

<!-- Manual Twist Fault Modal -->
<div class="modal-overlay" id="twistModal">
    <div class="modal">
        <h3>Add Manual Twist Fault</h3>
        <div class="modal-row">
            <div class="modal-field">
                <label>Start Miles</label>
                <input type="number" id="mtStartMiles" step="1" min="0" placeholder="e.g. 21">
            </div>
            <div class="modal-field">
                <label>Start Yards</label>
                <input type="number" id="mtStartYards" step="0.1" min="0" placeholder="e.g. 1160.0">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>End Miles</label>
                <input type="number" id="mtEndMiles" step="1" min="0" placeholder="e.g. 21">
            </div>
            <div class="modal-field">
                <label>End Yards</label>
                <input type="number" id="mtEndYards" step="0.1" min="0" placeholder="e.g. 1165.0">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>Max |Twist| (mm)</label>
                <input type="number" id="mtMaxTwist" step="0.1" min="0" placeholder="e.g. 18.5">
            </div>
            <div class="modal-field">
                <label>Worst Value (mm, signed)</label>
                <input type="number" id="mtWorstValue" step="0.1" placeholder="e.g. -18.5">
            </div>
        </div>
        <div class="modal-row">
            <div class="modal-field">
                <label>Curve Radius</label>
                <select id="mtCurveRadius">
                    <option value="gte400">&ge; 400m</option>
                    <option value="lt400">&lt; 400m</option>
                </select>
            </div>
            <div class="modal-field">
                <label>Fault No. (optional)</label>
                <input type="text" id="mtFaultNo" placeholder="e.g. TF-001">
            </div>
        </div>
        <div class="modal-actions">
            <button class="btn-modal-cancel" onclick="closeModal('twistModal')">Cancel</button>
            <button class="btn-modal-save" onclick="saveManualTwistFault()">Add Fault</button>
        </div>
    </div>
</div>

<script>
// ---- State ----
let parsedData = null;
let gaugeFaults = [];
let twistFaults = [];
let metadata = {};
let gaugeChartInstance = null;
let twistChartInstance = null;

// Manual faults (kept separate so we can tag them)
let manualGaugeFaults = [];
let manualTwistFaults = [];

// Bulk upload: store all loaded runs
let allRuns = []; // [{parsedData, metadata, filename}, ...]
let activeRunIndex = -1;

// Per-fault curve radius settings (indexed by fault index)
let twistFaultRadiusSettings = []; // true = <400m, false = >=400m

// ---- Table 3: Twist Fault Limits (3m base) ----
function classifyTwistFault(absValue, lineSpeed, curveRadiusLessThan400) {
    if (!lineSpeed || lineSpeed < 5) return null;

    // IAL - Block the line: all speeds, >= 33mm
    if (absValue >= 33) {
        return { category: 'IAL', badge: 'badge-ial', rowClass: 'cat-ial-block',
            action: 'BLOCK THE LINE - Correct before opening to traffic' };
    }

    // IAL - Correct within 36 hours
    if (lineSpeed <= 75 && absValue >= 24 && absValue < 33) {
        return { category: 'IAL', badge: 'badge-ial', rowClass: 'cat-ial',
            action: 'Correct within 36 hours' };
    }
    if (lineSpeed >= 80 && absValue >= 21 && absValue < 33) {
        return { category: 'IAL', badge: 'badge-ial', rowClass: 'cat-ial',
            action: 'Correct within 36 hours' };
    }

    // IL - Curve radius < 400m (max 65mph)
    if (curveRadiusLessThan400 && lineSpeed <= 65) {
        if (absValue >= 18 && absValue < 24) {
            return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Correct within 7 days' };
        }
        if (absValue >= 15 && absValue < 18) {
            return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Correct within 10 days' };
        }
    }

    // IL - Curve radius >= 400m (or < 400m but speed > 65 falls through to these)
    if (!curveRadiusLessThan400 || lineSpeed > 65) {
        if (lineSpeed <= 75) {
            if (absValue >= 21 && absValue < 24) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 14 days' };
            }
            if (absValue >= 18 && absValue < 21) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 21 days' };
            }
            if (absValue >= 15 && absValue < 18) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 28 days' };
            }
        }
        if (lineSpeed >= 80) {
            if (absValue >= 18 && absValue < 21) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 14 days' };
            }
            if (absValue >= 15 && absValue < 18) {
                return { category: 'IL', badge: 'badge-il', rowClass: 'cat-il',
                    action: 'Correct within 21 days' };
            }
        }
    }

    // AL - All speeds: 12mm to < 15mm
    if (absValue >= 12 && absValue < 15) {
        return { category: 'AL', badge: 'badge-al', rowClass: 'cat-al',
            action: 'Monitor (Alert Limit)' };
    }

    return null;
}

// ---- Table 5: Gauge Fault Limits ----
function classifyGaugeFault(gaugeValue, lineSpeed) {
    if (!lineSpeed || lineSpeed < 5) return null;

    // --- WIDE GAUGE (gauge above nominal 1435mm) ---
    if (gaugeValue >= 1435) {

        // IAL - Block the line (Static plus dynamic movement)
        if (lineSpeed >= 105 && gaugeValue >= 1472) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial-block',
                action: 'BLOCK THE LINE - Correct before opening to traffic' };
        }
        if (lineSpeed <= 100 && gaugeValue >= 1478) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial-block',
                action: 'BLOCK THE LINE - Correct before opening to traffic' };
        }

        // IAL - Correct within 36 hours (Static plus dynamic movement)
        if (lineSpeed >= 105 && gaugeValue >= 1463 && gaugeValue < 1472) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }
        if (lineSpeed <= 100 && gaugeValue >= 1470 && gaugeValue < 1478) {
            return { category: 'IAL', type: 'Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }

        // IAL - Correct within 36 hours (Static Wide Gauge)
        if (lineSpeed > 25 && gaugeValue >= 1458 && gaugeValue <= 1471) {
            return { category: 'IAL', type: 'Static Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }
        if (lineSpeed <= 25 && gaugeValue >= 1460 && gaugeValue <= 1477) {
            return { category: 'IAL', type: 'Static Wide Gauge', badge: 'badge-ial', rowClass: 'cat-ial',
                action: 'Correct within 36 hours' };
        }

        // IL - Wide Gauge (Static plus dynamic movement)
        if (lineSpeed >= 105 && gaugeValue >= 1458 && gaugeValue < 1463) {
            return { category: 'IL', type: 'Wide Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Track Cat 1A-3: correct within 14 days; Cat 4-6: correct within 28 days' };
        }
        if (lineSpeed <= 100 && gaugeValue >= 1460 && gaugeValue < 1470) {
            return { category: 'IL', type: 'Wide Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Track Cat 1A-3: correct within 14 days; Cat 4-6: correct within 28 days' };
        }

        // IL - Static Wide Gauge
        if (lineSpeed >= 30 && gaugeValue >= 1450 && gaugeValue < 1458) {
            return { category: 'IL', type: 'Static Wide Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Correct within 14 days' };
        }
        if (lineSpeed <= 25 && gaugeValue >= 1450 && gaugeValue < 1460) {
            return { category: 'IL', type: 'Static Wide Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Correct within 14 days' };
        }

        // AL - Wide Gauge (Static plus dynamic movement)
        if (lineSpeed >= 105 && gaugeValue >= 1450 && gaugeValue < 1458) {
            return { category: 'AL', type: 'Wide Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
        if (lineSpeed >= 30 && lineSpeed <= 100 && gaugeValue >= 1450 && gaugeValue < 1460) {
            return { category: 'AL', type: 'Wide Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
        if (lineSpeed <= 25 && gaugeValue >= 1455 && gaugeValue < 1460) {
            return { category: 'AL', type: 'Wide Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }

        // AL - Static Wide Gauge (all speeds)
        if (gaugeValue >= 1445 && gaugeValue < 1450) {
            return { category: 'AL', type: 'Static Wide Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
    }

    // --- TIGHT GAUGE (gauge below nominal) ---
    if (gaugeValue < 1435) {

        // IL - Tight Gauge (severe)
        if (lineSpeed >= 105 && gaugeValue <= 1426) {
            return { category: 'IL', type: 'Tight Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Inspect within 14 days, correct within 84 days' };
        }
        if (lineSpeed <= 100 && gaugeValue <= 1422) {
            return { category: 'IL', type: 'Tight Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Inspect within 14 days, correct within 84 days' };
        }

        // IL - Tight Gauge (review for hunting/rough rides)
        if (lineSpeed >= 105 && gaugeValue > 1426 && gaugeValue <= 1428) {
            return { category: 'IL', type: 'Tight Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Review for reports of Hunting or Rough Rides within 28 days' };
        }
        if (lineSpeed <= 100 && gaugeValue > 1422 && gaugeValue <= 1424) {
            return { category: 'IL', type: 'Tight Gauge', badge: 'badge-il', rowClass: 'cat-il',
                action: 'Review for reports of Hunting or Rough Rides within 28 days' };
        }

        // AL - Tight Gauge
        if (lineSpeed >= 105 && gaugeValue > 1428 && gaugeValue <= 1430) {
            return { category: 'AL', type: 'Tight Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
        if (lineSpeed <= 100 && gaugeValue > 1424 && gaugeValue <= 1426) {
            return { category: 'AL', type: 'Tight Gauge', badge: 'badge-al', rowClass: 'cat-al',
                action: 'Monitor (Alert Limit)' };
        }
    }

    return null;
}

// Get the detection thresholds for gauge based on line speed
function getGaugeDetectionThresholds(lineSpeed) {
    if (!lineSpeed || lineSpeed < 5) {
        // Default broadest thresholds
        return { tightBelow: 1430, wideAbove: 1445 };
    }
    if (lineSpeed >= 105) {
        return { tightBelow: 1430, wideAbove: 1445 };
    }
    // 5 to 100mph
    return { tightBelow: 1426, wideAbove: 1445 };
}

// Get the detection threshold for twist (lowest AL = 12mm)
function getTwistDetectionThreshold() {
    return 12;
}

// ---- Upload (supports bulk / multiple files) ----
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');

dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    if (e.dataTransfer.files.length) handleFiles(e.dataTransfer.files);
});
fileInput.addEventListener('change', e => { if (e.target.files.length) handleFiles(e.target.files); });

function handleFiles(files) {
    const fileArray = Array.from(files);
    let loaded = 0;
    const errors = [];

    fileArray.forEach(file => {
        const reader = new FileReader();
        reader.onload = e => {
            try {
                const content = e.target.result;
                const result = parseDataForRun(content);
                allRuns.push({
                    parsedData: result.data,
                    metadata: result.meta,
                    filename: file.name,
                    manualGaugeFaults: [],
                    manualTwistFaults: []
                });
            } catch (err) {
                errors.push(file.name + ': ' + err.message);
            }
            loaded++;
            if (loaded === fileArray.length) {
                onAllFilesLoaded(errors);
            }
        };
        reader.readAsText(file);
    });
}

function parseDataForRun(content) {
    let lines;
    if (content.includes('<table') || content.includes('<TABLE')) {
        lines = parseHTMLTable(content);
    } else {
        lines = content.split('\n').map(l => l.trim()).filter(l => l);
    }

    const meta = {};
    const dataRows = [];
    let headerFound = false;

    for (let i = 0; i < lines.length; i++) {
        const line = typeof lines[i] === 'string' ? lines[i] : lines[i].join('\t');
        const cells = typeof lines[i] === 'string'
            ? line.split('\t').map(c => c.trim())
            : lines[i].map(c => (c || '').trim());

        if (!headerFound && cells[0] === 'Miles' && cells[1] === 'Yards') {
            headerFound = true;
            continue;
        }

        if (!headerFound) {
            if (cells.length >= 2 && cells[0] && cells[1]) {
                meta[cells[0]] = cells[1];
            } else if (cells.length === 1 && cells[0].includes('\t')) {
                const parts = cells[0].split('\t');
                if (parts.length >= 2) meta[parts[0].trim()] = parts[1].trim();
            }
            if (typeof lines[i] === 'string' && !cells[1] && line.includes('\t')) {
                const parts = line.split('\t');
                if (parts.length >= 2 && parts[0].trim()) {
                    meta[parts[0].trim()] = parts[1].trim();
                }
            }
            continue;
        }

        if (headerFound && cells[0] && !isNaN(parseFloat(cells[0]))) {
            const row = {
                miles: parseFloat(cells[0]),
                yards: parseFloat(cells[1]),
                gauge: parseFloat(cells[2]),
                xlevel: parseFloat(cells[3]),
                twist1: cells[4] !== '' && cells[4] !== undefined ? parseFloat(cells[4]) : null,
                twist2: cells[5] !== '' && cells[5] !== undefined ? parseFloat(cells[5]) : null,
                zone: cells[7] || cells[6] || ''
            };
            if (!isNaN(row.miles) && !isNaN(row.yards) && !isNaN(row.gauge)) {
                row.location = row.miles + 'mi ' + row.yards.toFixed(1) + 'yds';
                dataRows.push(row);
            }
        }
    }

    if (dataRows.length === 0) {
        throw new Error('No measurement data rows found. Check file format.');
    }

    return { data: dataRows, meta: meta };
}

function onAllFilesLoaded(errors) {
    if (errors.length > 0 && allRuns.length === 0) {
        alert('Failed to parse files:\n' + errors.join('\n'));
        return;
    }
    if (errors.length > 0) {
        alert('Some files had errors:\n' + errors.join('\n') + '\n\nSuccessfully loaded ' + allRuns.length + ' run(s).');
    }

    // Show run selector if multiple runs
    updateRunSelector();
    switchRun(0);

    document.getElementById('uploadScreen').style.display = 'none';
    document.getElementById('reportContainer').classList.add('active');
}

function updateRunSelector() {
    const bar = document.getElementById('runSelectorBar');
    const sel = document.getElementById('runSelector');
    const countEl = document.getElementById('runCount');

    if (allRuns.length > 1) {
        bar.style.display = 'flex';
        sel.innerHTML = allRuns.map((run, i) => {
            const label = run.metadata['Route ID']
                ? run.metadata['Route ID'] + ' / ' + (run.metadata['Track ID'] || '') + ' (' + run.filename + ')'
                : run.filename;
            return `<option value="${i}">${label}</option>`;
        }).join('');
        countEl.textContent = allRuns.length + ' runs loaded';
    } else {
        bar.style.display = 'none';
    }
}

function switchRun(index) {
    index = parseInt(index);
    activeRunIndex = index;
    const run = allRuns[index];
    parsedData = run.parsedData;
    metadata = run.metadata;
    manualGaugeFaults = run.manualGaugeFaults;
    manualTwistFaults = run.manualTwistFaults;

    document.getElementById('runSelector').value = index;
    identifyFaults();
    buildReport();
}

function handleFile(file) {
    handleFiles([file]);
}

// ---- Parsing ----
function parseData(content) {
    const result = parseDataForRun(content);
    parsedData = result.data;
    metadata = result.meta;
    identifyFaults();
}

function parseHTMLTable(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const rows = doc.querySelectorAll('tr');
    const result = [];
    rows.forEach(row => {
        const cells = [];
        row.querySelectorAll('td, th').forEach(cell => cells.push(cell.textContent.trim()));
        if (cells.length > 0) result.push(cells);
    });
    return result;
}

function formatLocation(row) {
    return row.miles + 'mi ' + row.yards.toFixed(1) + 'yds';
}

// ---- Fault Identification ----
function identifyFaults() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    identifyGaugeFaults(lineSpeed);
    identifyTwistFaults();
}

function identifyGaugeFaults(lineSpeed) {
    gaugeFaults = [];
    const thresholds = getGaugeDetectionThresholds(lineSpeed);
    let inFault = false;
    let currentFault = null;

    for (let i = 0; i < parsedData.length; i++) {
        const row = parsedData[i];
        const isTight = row.gauge <= thresholds.tightBelow;
        const isWide = row.gauge >= thresholds.wideAbove;
        const isFault = isTight || isWide;

        if (isFault) {
            if (!inFault) {
                currentFault = {
                    startIdx: i,
                    startLocation: formatLocation(row),
                    startMiles: row.miles,
                    startYards: row.yards,
                    worstGauge: row.gauge,
                    direction: isWide ? 'wide' : 'tight',
                    rows: [row]
                };
                inFault = true;
            } else {
                currentFault.rows.push(row);
                if (currentFault.direction === 'wide') {
                    if (row.gauge > currentFault.worstGauge) currentFault.worstGauge = row.gauge;
                } else {
                    if (row.gauge < currentFault.worstGauge) currentFault.worstGauge = row.gauge;
                }
            }
        } else {
            if (inFault) {
                finishGaugeFault(currentFault);
                gaugeFaults.push(currentFault);
                inFault = false;
                currentFault = null;
            }
        }
    }
    if (inFault) {
        finishGaugeFault(currentFault);
        gaugeFaults.push(currentFault);
    }
}

function finishGaugeFault(fault) {
    const lastRow = fault.rows[fault.rows.length - 1];
    fault.endLocation = formatLocation(lastRow);
    fault.endMiles = lastRow.miles;
    fault.endYards = lastRow.yards;
    fault.length = (fault.endYards - fault.startYards).toFixed(1);
    if (fault.direction === 'wide') {
        fault.deviation = '+' + (fault.worstGauge - 1435).toFixed(1);
    } else {
        fault.deviation = '-' + (1435 - fault.worstGauge).toFixed(1);
    }
}

function identifyTwistFaults() {
    const threshold = getTwistDetectionThreshold();
    twistFaults = [];
    twistFaultRadiusSettings = [];
    let inFault = false;
    let currentFault = null;

    for (let i = 0; i < parsedData.length; i++) {
        const row = parsedData[i];
        const hasTwist = row.twist1 !== null && !isNaN(row.twist1) &&
            Math.abs(row.twist1) >= threshold;

        if (hasTwist) {
            if (!inFault) {
                currentFault = {
                    startIdx: i,
                    startLocation: formatLocation(row),
                    startMiles: row.miles,
                    startYards: row.yards,
                    maxAbsTwist: Math.abs(row.twist1),
                    worstValue: row.twist1,
                    rows: [row]
                };
                inFault = true;
            } else {
                currentFault.rows.push(row);
                if (Math.abs(row.twist1) > currentFault.maxAbsTwist) {
                    currentFault.maxAbsTwist = Math.abs(row.twist1);
                    currentFault.worstValue = row.twist1;
                }
            }
        } else {
            if (inFault) {
                const lastRow = currentFault.rows[currentFault.rows.length - 1];
                currentFault.endLocation = formatLocation(lastRow);
                currentFault.endMiles = lastRow.miles;
                currentFault.endYards = lastRow.yards;
                currentFault.length = (currentFault.endYards - currentFault.startYards).toFixed(1);
                twistFaults.push(currentFault);
                twistFaultRadiusSettings.push(false); // default: >= 400m
                inFault = false;
                currentFault = null;
            }
        }
    }
    if (inFault) {
        const lastRow = currentFault.rows[currentFault.rows.length - 1];
        currentFault.endLocation = formatLocation(lastRow);
        currentFault.endMiles = lastRow.miles;
        currentFault.endYards = lastRow.yards;
        currentFault.length = (currentFault.endYards - currentFault.startYards).toFixed(1);
        twistFaults.push(currentFault);
        twistFaultRadiusSettings.push(false);
    }
}

// ---- Build Report ----
function buildReport() {
    const route = metadata['Route ID'] || '';
    const track = metadata['Track ID'] || '';
    document.getElementById('reportTitle').textContent =
        'Track Inspection Report' + (route ? ' - ' + route : '') + (track ? ' / ' + track : '');

    // Metadata
    const metaGrid = document.getElementById('metaGrid');
    metaGrid.innerHTML = '';
    const displayKeys = [
        'Operator ID', 'Profile', 'Start Location', 'End Location',
        'Direction Of Travel', 'Job Reference', 'Route ID', 'Track ID',
        'Start Time', 'End Time', 'Serial Number', 'Reference Gauge',
        'Calibrated', 'Twist Base 1', 'Software Version', 'Acquisition Rate'
    ];
    displayKeys.forEach(key => {
        if (metadata[key]) {
            metaGrid.innerHTML += `<div class="meta-item"><span class="label">${key}</span><span class="value">${metadata[key]}</span></div>`;
        }
    });

    updateSummaryStats();
    buildCharts();
    buildGaugeFaultTable();
    buildTwistFaultTable();
    updateSpeedWarning();

    // Tab handling
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById('page-' + tab.dataset.page).classList.add('active');
        });
    });

    // Line speed change handler
    document.getElementById('lineSpeedInput').addEventListener('change', onLineSpeedChange);
    document.getElementById('lineSpeedInput').addEventListener('input', onLineSpeedChange);
}

function onLineSpeedChange() {
    identifyFaults();
    updateSummaryStats();
    buildGaugeFaultTable();
    buildTwistFaultTable();
    buildCharts();
    updateSpeedWarning();
}

function updateSpeedWarning() {
    const speed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const warning = document.getElementById('speedWarning');
    if (speed < 5) {
        warning.classList.add('visible');
    } else {
        warning.classList.remove('visible');
    }
}

function updateSummaryStats() {
    const statsDiv = document.getElementById('summaryStats');
    const totalPoints = parsedData.length;
    const minGauge = Math.min(...parsedData.map(r => r.gauge));
    const maxGauge = Math.max(...parsedData.map(r => r.gauge));
    const twistValues = parsedData.filter(r => r.twist1 !== null).map(r => r.twist1);
    const maxTwist = twistValues.length ? Math.max(...twistValues.map(v => Math.abs(v))) : 0;

    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const allGaugeFaults = gaugeFaults.concat(manualGaugeFaults);
    const allTwistFaults = twistFaults.concat(manualTwistFaults);
    const ialGauge = allGaugeFaults.filter(f => { const c = classifyGaugeFault(f.worstGauge, lineSpeed); return c && c.category === 'IAL'; }).length;
    const ialTwist = allTwistFaults.filter((f, i) => {
        const isManual = i >= twistFaults.length;
        const radius = isManual ? f.curveRadiusLessThan400 : twistFaultRadiusSettings[i];
        const c = classifyTwistFault(f.maxAbsTwist, lineSpeed, radius);
        return c && c.category === 'IAL';
    }).length;

    const totalGauge = allGaugeFaults.length;
    const totalTwist = allTwistFaults.length;
    const manualCount = manualGaugeFaults.length + manualTwistFaults.length;
    const manualNote = manualCount > 0 ? ` (${manualCount} manual)` : '';

    statsDiv.innerHTML = `
        <div class="stat-card"><div class="number">${totalPoints}</div><div class="label">Data Points</div></div>
        <div class="stat-card ${totalGauge > 0 ? 'danger' : ''}"><div class="number">${totalGauge}</div><div class="label">Gauge Faults${manualGaugeFaults.length > 0 ? ' (' + manualGaugeFaults.length + ' manual)' : ''}</div></div>
        <div class="stat-card ${totalTwist > 0 ? 'warning' : ''}"><div class="number">${totalTwist}</div><div class="label">Twist Faults${manualTwistFaults.length > 0 ? ' (' + manualTwistFaults.length + ' manual)' : ''}</div></div>
        <div class="stat-card ${ialGauge + ialTwist > 0 ? 'danger' : ''}"><div class="number">${ialGauge + ialTwist}</div><div class="label">IAL Faults</div></div>
        <div class="stat-card"><div class="number">${minGauge.toFixed(1)}</div><div class="label">Min Gauge (mm)</div></div>
        <div class="stat-card"><div class="number">${maxTwist.toFixed(1)}</div><div class="label">Max |Twist| (mm)</div></div>
    `;
}

// ---- Chart threshold helpers ----
function getGaugeChartThresholds(lineSpeed) {
    const lines = [];
    // Reference
    lines.push({ value: 1435, label: 'Reference (1435)', color: '#666', dash: [6, 4], width: 1 });

    // Wide gauge thresholds
    lines.push({ value: 1445, label: 'Wide AL (1445)', color: '#28a745', dash: [4, 4], width: 1 });

    if (lineSpeed >= 30) {
        lines.push({ value: 1450, label: 'Wide IL (1450)', color: '#e67e22', dash: [5, 3], width: 1 });
    } else if (lineSpeed >= 5) {
        lines.push({ value: 1450, label: 'Wide IL (1450)', color: '#e67e22', dash: [5, 3], width: 1 });
    }

    if (lineSpeed > 25) {
        lines.push({ value: 1458, label: 'Wide IAL (1458)', color: '#c0392b', dash: [6, 3], width: 1.5 });
    } else if (lineSpeed >= 5) {
        lines.push({ value: 1460, label: 'Wide IAL (1460)', color: '#c0392b', dash: [6, 3], width: 1.5 });
    }

    if (lineSpeed >= 105) {
        lines.push({ value: 1472, label: 'Block Line (1472)', color: '#721c24', dash: [8, 4], width: 2 });
    } else if (lineSpeed >= 5) {
        lines.push({ value: 1478, label: 'Block Line (1478)', color: '#721c24', dash: [8, 4], width: 2 });
    }

    // Tight gauge thresholds
    if (lineSpeed >= 105) {
        lines.push({ value: 1430, label: 'Tight AL (1430)', color: '#28a745', dash: [4, 4], width: 1 });
        lines.push({ value: 1428, label: 'Tight IL (1428)', color: '#e67e22', dash: [5, 3], width: 1 });
        lines.push({ value: 1426, label: 'Tight IL (1426)', color: '#c0392b', dash: [6, 3], width: 1.5 });
    } else if (lineSpeed >= 5) {
        lines.push({ value: 1426, label: 'Tight AL (1426)', color: '#28a745', dash: [4, 4], width: 1 });
        lines.push({ value: 1424, label: 'Tight IL (1424)', color: '#e67e22', dash: [5, 3], width: 1 });
        lines.push({ value: 1422, label: 'Tight IL (1422)', color: '#c0392b', dash: [6, 3], width: 1.5 });
    }

    return lines;
}

function getTwistChartThresholds(lineSpeed) {
    const lines = [];
    // AL: 12mm
    lines.push({ value: 12, label: 'AL (12mm)', color: '#28a745', dash: [4, 4], width: 1 });
    // IL: 15mm (lowest IL across all configurations)
    lines.push({ value: 15, label: 'IL (15mm)', color: '#e67e22', dash: [5, 3], width: 1 });
    // IAL: speed-dependent
    if (lineSpeed >= 80) {
        lines.push({ value: 21, label: 'IAL (21mm)', color: '#c0392b', dash: [6, 3], width: 1.5 });
    } else if (lineSpeed >= 5) {
        lines.push({ value: 24, label: 'IAL (24mm)', color: '#c0392b', dash: [6, 3], width: 1.5 });
    }
    // Block line: 33mm
    lines.push({ value: 33, label: 'Block (33mm)', color: '#721c24', dash: [8, 4], width: 2 });
    return lines;
}

function buildCharts() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const labels = parsedData.map(r => r.miles + 'mi ' + r.yards.toFixed(0) + 'y');
    const step = Math.max(1, Math.floor(parsedData.length / 30));
    const displayLabels = labels.map((l, i) => i % step === 0 ? l : '');
    const n = parsedData.length;

    // ---- Gauge chart ----
    const gaugeCtx = document.getElementById('gaugeChart').getContext('2d');
    if (gaugeChartInstance) gaugeChartInstance.destroy();

    const gaugeDatasets = [
        {
            label: 'Gauge (mm)',
            data: parsedData.map(r => r.gauge),
            borderColor: '#4a6cf7',
            backgroundColor: 'rgba(74,108,247,0.1)',
            fill: true, borderWidth: 1.5, pointRadius: 0, tension: 0.3
        }
    ];

    const gaugeThresholds = getGaugeChartThresholds(lineSpeed);
    gaugeThresholds.forEach(t => {
        gaugeDatasets.push({
            label: t.label,
            data: Array(n).fill(t.value),
            borderColor: t.color, borderWidth: t.width, borderDash: t.dash,
            pointRadius: 0, fill: false
        });
    });

    gaugeChartInstance = new Chart(gaugeCtx, {
        type: 'line',
        data: { labels: displayLabels, datasets: gaugeDatasets },
        options: {
            responsive: true, maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            plugins: {
                legend: { position: 'top', labels: { usePointStyle: true, padding: 12, font: { size: 10 } } },
                tooltip: { callbacks: { title: (items) => labels[items[0].dataIndex] } }
            },
            scales: {
                x: { ticks: { maxRotation: 45, font: { size: 10 } } },
                y: { title: { display: true, text: 'Gauge (mm)' } }
            }
        }
    });

    // ---- Twist chart ----
    const twist1Data = parsedData.map(r => r.twist1);
    const twistCtx = document.getElementById('twistChart').getContext('2d');
    if (twistChartInstance) twistChartInstance.destroy();

    const twistDatasets = [
        {
            label: 'Twist 1 - 3m (mm)',
            data: twist1Data,
            borderColor: '#e67e22', backgroundColor: 'rgba(230,126,34,0.1)',
            fill: true, borderWidth: 1.5, pointRadius: 0, tension: 0.3, spanGaps: false
        },
        {
            label: 'Zero',
            data: Array(n).fill(0),
            borderColor: '#aaa', borderWidth: 1, borderDash: [3, 3], pointRadius: 0, fill: false
        }
    ];

    const twistThresholds = getTwistChartThresholds(lineSpeed);
    twistThresholds.forEach(t => {
        // Positive line (shown in legend)
        twistDatasets.push({
            label: '+' + t.label,
            data: Array(n).fill(t.value),
            borderColor: t.color, borderWidth: t.width, borderDash: t.dash,
            pointRadius: 0, fill: false
        });
        // Negative mirror (hidden from legend)
        twistDatasets.push({
            label: '-' + t.label,
            data: Array(n).fill(-t.value),
            borderColor: t.color, borderWidth: t.width, borderDash: t.dash,
            pointRadius: 0, fill: false
        });
    });

    twistChartInstance = new Chart(twistCtx, {
        type: 'line',
        data: { labels: displayLabels, datasets: twistDatasets },
        options: {
            responsive: true, maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true, padding: 12, font: { size: 10 },
                        filter: (item) => !item.text.startsWith('-')
                    }
                },
                tooltip: { callbacks: { title: (items) => labels[items[0].dataIndex] } }
            },
            scales: {
                x: { ticks: { maxRotation: 45, font: { size: 10 } } },
                y: { title: { display: true, text: 'Twist (mm)' } }
            }
        }
    });
}

function buildGaugeFaultTable() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const tbody = document.querySelector('#gaugeFaultTable tbody');
    tbody.innerHTML = '';
    const allGaugeFaults = gaugeFaults.concat(manualGaugeFaults);
    if (allGaugeFaults.length === 0) {
        tbody.innerHTML = '<tr><td colspan="11" style="text-align:center;padding:30px;color:#888;">No gauge faults detected</td></tr>';
        return;
    }
    allGaugeFaults.forEach((f, idx) => {
        const classification = classifyGaugeFault(f.worstGauge, lineSpeed);
        const tr = document.createElement('tr');
        tr.className = classification ? classification.rowClass : '';
        const catBadge = classification
            ? `<span class="badge ${classification.badge}">${classification.category}</span>`
            : '<span style="color:#999;">--</span>';
        const faultType = classification ? classification.type : (f.direction === 'wide' ? 'Wide Gauge' : 'Tight Gauge');
        const actionText = classification ? classification.action : (lineSpeed < 5 ? 'Set line speed' : 'Below threshold');
        const manualTag = f.manual ? '<span class="manual-fault-tag">MANUAL</span>' : '';
        const removeBtn = f.manual ? `<button class="btn-remove-fault" onclick="removeManualGaugeFault(${idx - gaugeFaults.length})" title="Remove manual fault">X</button>` : '';
        const defaultFaultNo = f.manual && f.faultNo ? f.faultNo : '';

        tr.innerHTML = `
            <td>${idx + 1} ${manualTag}</td>
            <td><input type="text" class="fault-no-input" data-type="gauge" data-idx="${idx}" placeholder="--" value="${defaultFaultNo}" style="width:55px;padding:3px 5px;border:1px solid #ccc;border-radius:4px;font-size:11px;text-align:center;"></td>
            <td>${f.startLocation}</td>
            <td>${f.endLocation}</td>
            <td>${f.length}</td>
            <td>${f.worstGauge.toFixed(1)}</td>
            <td>${f.deviation}</td>
            <td>${faultType}</td>
            <td>${catBadge}</td>
            <td style="font-size:11px;max-width:220px;">${actionText} ${removeBtn}</td>
            <td style="text-align:center;"><input type="checkbox" class="repeat-fault-cb" data-type="gauge" data-idx="${idx}"></td>
        `;
        tbody.appendChild(tr);
    });
}

function buildTwistFaultTable() {
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;
    const tbody = document.querySelector('#twistFaultTable tbody');
    tbody.innerHTML = '';
    const allTwistFaults = twistFaults.concat(manualTwistFaults);
    if (allTwistFaults.length === 0) {
        tbody.innerHTML = '<tr><td colspan="11" style="text-align:center;padding:30px;color:#888;">No twist faults detected</td></tr>';
        return;
    }
    allTwistFaults.forEach((f, idx) => {
        const isLessThan400 = f.manual ? f.curveRadiusLessThan400 : twistFaultRadiusSettings[idx];
        const classification = classifyTwistFault(f.maxAbsTwist, lineSpeed, isLessThan400);
        const tr = document.createElement('tr');
        tr.className = classification ? classification.rowClass : '';
        const catBadge = classification
            ? `<span class="badge ${classification.badge}">${classification.category}</span>`
            : '<span style="color:#999;">--</span>';
        const actionText = classification ? classification.action : (lineSpeed < 5 ? 'Set line speed' : 'Below threshold');
        const manualTag = f.manual ? '<span class="manual-fault-tag">MANUAL</span>' : '';
        const removeBtn = f.manual ? `<button class="btn-remove-fault" onclick="removeManualTwistFault(${idx - twistFaults.length})" title="Remove manual fault">X</button>` : '';
        const defaultFaultNo = f.manual && f.faultNo ? f.faultNo : '';

        tr.innerHTML = `
            <td>${idx + 1} ${manualTag}</td>
            <td><input type="text" class="fault-no-input" data-type="twist" data-idx="${idx}" placeholder="--" value="${defaultFaultNo}" style="width:55px;padding:3px 5px;border:1px solid #ccc;border-radius:4px;font-size:11px;text-align:center;"></td>
            <td>${f.startLocation}</td>
            <td>${f.endLocation}</td>
            <td>${f.length}</td>
            <td>${f.maxAbsTwist.toFixed(1)}</td>
            <td>${f.worstValue.toFixed(1)}</td>
            <td>
                <select class="radius-select" data-twist-idx="${idx}" onchange="onRadiusChange(this)">
                    <option value="gte400" ${!isLessThan400 ? 'selected' : ''}>&ge; 400m</option>
                    <option value="lt400" ${isLessThan400 ? 'selected' : ''}>&lt; 400m</option>
                </select>
            </td>
            <td>${catBadge}</td>
            <td style="font-size:11px;max-width:220px;">${actionText} ${removeBtn}</td>
            <td style="text-align:center;"><input type="checkbox" class="repeat-fault-cb" data-type="twist" data-idx="${idx}"></td>
        `;
        tbody.appendChild(tr);
    });
}

function onRadiusChange(selectEl) {
    const idx = parseInt(selectEl.dataset.twistIdx);
    const isManual = idx >= twistFaults.length;
    if (isManual) {
        const manualIdx = idx - twistFaults.length;
        manualTwistFaults[manualIdx].curveRadiusLessThan400 = (selectEl.value === 'lt400');
    } else {
        twistFaultRadiusSettings[idx] = (selectEl.value === 'lt400');
    }
    buildTwistFaultTable();
    updateSummaryStats();
}

// ---- Navigation ----
function goBack() {
    document.getElementById('uploadScreen').style.display = 'flex';
    document.getElementById('reportContainer').classList.remove('active');
    document.getElementById('runSelectorBar').style.display = 'none';
    fileInput.value = '';
    allRuns = [];
    activeRunIndex = -1;
    manualGaugeFaults = [];
    manualTwistFaults = [];
}

// ---- Manual Fault Modals ----
function openManualGaugeFaultModal() {
    document.getElementById('mgStartMiles').value = '';
    document.getElementById('mgStartYards').value = '';
    document.getElementById('mgEndMiles').value = '';
    document.getElementById('mgEndYards').value = '';
    document.getElementById('mgWorstGauge').value = '';
    document.getElementById('mgFaultDirection').value = 'wide';
    document.getElementById('mgFaultNo').value = '';
    document.getElementById('gaugeModal').classList.add('active');
}

function openManualTwistFaultModal() {
    document.getElementById('mtStartMiles').value = '';
    document.getElementById('mtStartYards').value = '';
    document.getElementById('mtEndMiles').value = '';
    document.getElementById('mtEndYards').value = '';
    document.getElementById('mtMaxTwist').value = '';
    document.getElementById('mtWorstValue').value = '';
    document.getElementById('mtCurveRadius').value = 'gte400';
    document.getElementById('mtFaultNo').value = '';
    document.getElementById('twistModal').classList.add('active');
}

function closeModal(id) {
    document.getElementById(id).classList.remove('active');
}

function saveManualGaugeFault() {
    const startMiles = parseFloat(document.getElementById('mgStartMiles').value);
    const startYards = parseFloat(document.getElementById('mgStartYards').value);
    const endMiles = parseFloat(document.getElementById('mgEndMiles').value);
    const endYards = parseFloat(document.getElementById('mgEndYards').value);
    const worstGauge = parseFloat(document.getElementById('mgWorstGauge').value);
    const direction = document.getElementById('mgFaultDirection').value;
    const faultNo = document.getElementById('mgFaultNo').value;

    if (isNaN(startMiles) || isNaN(startYards) || isNaN(endMiles) || isNaN(endYards) || isNaN(worstGauge)) {
        alert('Please fill in all required fields (miles, yards, worst gauge).');
        return;
    }

    const fault = {
        startLocation: startMiles + 'mi ' + startYards.toFixed(1) + 'yds',
        endLocation: endMiles + 'mi ' + endYards.toFixed(1) + 'yds',
        startMiles, startYards, endMiles, endYards,
        worstGauge: worstGauge,
        direction: direction,
        length: (endYards - startYards).toFixed(1),
        deviation: direction === 'wide'
            ? '+' + (worstGauge - 1435).toFixed(1)
            : '-' + (1435 - worstGauge).toFixed(1),
        manual: true,
        faultNo: faultNo,
        rows: []
    };

    manualGaugeFaults.push(fault);
    // Persist to current run
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].manualGaugeFaults = manualGaugeFaults;
    }

    closeModal('gaugeModal');
    buildGaugeFaultTable();
    updateSummaryStats();
}

function saveManualTwistFault() {
    const startMiles = parseFloat(document.getElementById('mtStartMiles').value);
    const startYards = parseFloat(document.getElementById('mtStartYards').value);
    const endMiles = parseFloat(document.getElementById('mtEndMiles').value);
    const endYards = parseFloat(document.getElementById('mtEndYards').value);
    const maxTwist = parseFloat(document.getElementById('mtMaxTwist').value);
    const worstValue = parseFloat(document.getElementById('mtWorstValue').value);
    const curveRadius = document.getElementById('mtCurveRadius').value;
    const faultNo = document.getElementById('mtFaultNo').value;

    if (isNaN(startMiles) || isNaN(startYards) || isNaN(endMiles) || isNaN(endYards) || isNaN(maxTwist) || isNaN(worstValue)) {
        alert('Please fill in all required fields.');
        return;
    }

    const fault = {
        startLocation: startMiles + 'mi ' + startYards.toFixed(1) + 'yds',
        endLocation: endMiles + 'mi ' + endYards.toFixed(1) + 'yds',
        startMiles, startYards, endMiles, endYards,
        maxAbsTwist: maxTwist,
        worstValue: worstValue,
        length: (endYards - startYards).toFixed(1),
        manual: true,
        faultNo: faultNo,
        curveRadiusLessThan400: curveRadius === 'lt400',
        rows: []
    };

    manualTwistFaults.push(fault);
    twistFaultRadiusSettings.push(fault.curveRadiusLessThan400);
    // Persist to current run
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].manualTwistFaults = manualTwistFaults;
    }

    closeModal('twistModal');
    buildTwistFaultTable();
    updateSummaryStats();
}

function removeManualGaugeFault(manualIdx) {
    manualGaugeFaults.splice(manualIdx, 1);
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].manualGaugeFaults = manualGaugeFaults;
    }
    buildGaugeFaultTable();
    updateSummaryStats();
}

function removeManualTwistFault(manualIdx) {
    // Find the position in the combined array to remove the radius setting
    const combinedIdx = twistFaults.length + manualIdx;
    twistFaultRadiusSettings.splice(combinedIdx, 1);
    manualTwistFaults.splice(manualIdx, 1);
    if (activeRunIndex >= 0 && allRuns[activeRunIndex]) {
        allRuns[activeRunIndex].manualTwistFaults = manualTwistFaults;
    }
    buildTwistFaultTable();
    updateSummaryStats();
}

// ---- Export Excel ----
function exportExcel() {
    const wb = XLSX.utils.book_new();
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;

    // Sheet 1: Survey Info
    const runName = document.getElementById('runNameInput').value;
    const inspector = document.getElementById('inspectorInput').value;
    const metaArr = [
        { Field: 'Run Name', Value: runName },
        { Field: 'Inspector', Value: inspector },
        { Field: 'Line Speed (mph)', Value: lineSpeed || 'Not set' },
        ...Object.entries(metadata).map(([k, v]) => ({ Field: k, Value: v }))
    ];
    const ws1 = XLSX.utils.json_to_sheet(metaArr);
    XLSX.utils.book_append_sheet(wb, ws1, 'Survey Info');

    // Sheet 2: All Data
    const allData = parsedData.map(r => ({
        Miles: r.miles,
        Yards: r.yards,
        'Gauge (mm)': r.gauge,
        'X-Level (mm)': r.xlevel,
        'Twist 1 (mm)': r.twist1,
        Zone: r.zone
    }));
    const ws2 = XLSX.utils.json_to_sheet(allData);
    XLSX.utils.book_append_sheet(wb, ws2, 'All Data');

    // Sheet 3: Gauge Faults (auto + manual)
    const allGaugeFaultsExport = gaugeFaults.concat(manualGaugeFaults);
    const gaugeFaultNos = document.querySelectorAll('.fault-no-input[data-type="gauge"]');
    const gaugeRepeatCbs = document.querySelectorAll('.repeat-fault-cb[data-type="gauge"]');
    const gfData = allGaugeFaultsExport.map((f, i) => {
        const c = classifyGaugeFault(f.worstGauge, lineSpeed);
        return {
            '#': i + 1,
            'Fault No.': gaugeFaultNos[i] ? gaugeFaultNos[i].value : '',
            'Start Location': f.startLocation,
            'End Location': f.endLocation,
            'Length (yds)': f.length,
            'Worst Gauge (mm)': f.worstGauge.toFixed(1),
            'Deviation (mm)': f.deviation,
            'Fault Type': c ? c.type : (f.direction === 'wide' ? 'Wide Gauge' : 'Tight Gauge'),
            'Category': c ? c.category : '',
            'Required Action': c ? c.action : '',
            'Repeat Fault': gaugeRepeatCbs[i] && gaugeRepeatCbs[i].checked ? 'Yes' : 'No'
        };
    });
    const ws3 = XLSX.utils.json_to_sheet(gfData.length ? gfData : [{ Info: 'No gauge faults' }]);
    XLSX.utils.book_append_sheet(wb, ws3, 'Gauge Faults');

    // Sheet 4: Twist Faults (auto + manual)
    const allTwistFaultsExport = twistFaults.concat(manualTwistFaults);
    const twistFaultNos = document.querySelectorAll('.fault-no-input[data-type="twist"]');
    const twistRepeatCbs = document.querySelectorAll('.repeat-fault-cb[data-type="twist"]');
    const tfData = allTwistFaultsExport.map((f, i) => {
        const isManual = f.manual;
        const radius = isManual ? f.curveRadiusLessThan400 : twistFaultRadiusSettings[i];
        const c = classifyTwistFault(f.maxAbsTwist, lineSpeed, radius);
        return {
            '#': i + 1,
            'Fault No.': twistFaultNos[i] ? twistFaultNos[i].value : '',
            'Start Location': f.startLocation,
            'End Location': f.endLocation,
            'Length (yds)': f.length,
            'Max |Twist| (mm)': f.maxAbsTwist.toFixed(1),
            'Worst Value (mm)': f.worstValue.toFixed(1),
            'Curve Radius': radius ? '< 400m' : '>= 400m',
            'Category': c ? c.category : '',
            'Required Action': c ? c.action : '',
            'Repeat Fault': twistRepeatCbs[i] && twistRepeatCbs[i].checked ? 'Yes' : 'No'
        };
    });
    const ws4 = XLSX.utils.json_to_sheet(tfData.length ? tfData : [{ Info: 'No twist faults' }]);
    XLSX.utils.book_append_sheet(wb, ws4, 'Twist Faults');

    const filename = 'TrackInspection_' + (metadata['Route ID'] || 'Report') + '_' +
        (metadata['Track ID'] || '') + '.xlsx';
    XLSX.writeFile(wb, filename);
}

// ---- Export PDF ----
function exportPDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('landscape', 'mm', 'a4');
    const pageWidth = doc.internal.pageSize.getWidth();
    const lineSpeed = parseInt(document.getElementById('lineSpeedInput').value) || 0;

    // Page 1: Survey info + summary
    const pdfRunName = document.getElementById('runNameInput').value;
    const pdfInspector = document.getElementById('inspectorInput').value;

    doc.setFontSize(18);
    doc.setTextColor(26, 26, 46);
    doc.text('Track Inspection Report', 14, 20);
    doc.setFontSize(10);
    doc.setTextColor(100);
    const route = metadata['Route ID'] || '';
    const track = metadata['Track ID'] || '';
    doc.text(`Run Name: ${pdfRunName}  |  Inspector: ${pdfInspector}  |  Line Speed: ${lineSpeed || 'N/A'} mph`, 14, 28);
    doc.text(`Route: ${route}  |  Track: ${track}  |  ${metadata['Job Reference'] || ''}`, 14, 34);
    doc.text(`${metadata['Start Location'] || ''} to ${metadata['End Location'] || ''}`, 14, 40);
    doc.text(`Date: ${metadata['Start Time'] || ''}`, 14, 46);

    // Summary table
    doc.autoTable({
        startY: 54,
        head: [['Total Points', 'Gauge Faults', 'Twist Faults', 'Min Gauge', 'Max Gauge', 'Max |Twist|']],
        body: [[
            parsedData.length,
            gaugeFaults.length + manualGaugeFaults.length,
            twistFaults.length + manualTwistFaults.length,
            Math.min(...parsedData.map(r => r.gauge)).toFixed(1) + ' mm',
            Math.max(...parsedData.map(r => r.gauge)).toFixed(1) + ' mm',
            (parsedData.filter(r => r.twist1 !== null).length > 0
                ? Math.max(...parsedData.filter(r => r.twist1 !== null).map(r => Math.abs(r.twist1))).toFixed(1) + ' mm'
                : 'N/A')
        ]],
        theme: 'grid',
        headStyles: { fillColor: [26, 26, 46] },
        styles: { fontSize: 9 }
    });

    // Add chart images
    const gaugeCanvas = document.getElementById('gaugeChart');
    const twistCanvas = document.getElementById('twistChart');
    const gaugeImg = gaugeCanvas.toDataURL('image/png');
    const twistImg = twistCanvas.toDataURL('image/png');

    const chartY = doc.lastAutoTable.finalY + 8;
    const chartW = pageWidth - 28;
    const chartH = 70;
    doc.addImage(gaugeImg, 'PNG', 14, chartY, chartW, chartH);
    doc.addImage(twistImg, 'PNG', 14, chartY + chartH + 6, chartW, chartH);

    // Page 2: Gauge Faults
    doc.addPage();
    doc.setFontSize(14);
    doc.setTextColor(26, 26, 46);
    doc.text('Gauge Faults (Table 5 Limits) - Line Speed: ' + (lineSpeed || 'N/A') + ' mph', 14, 20);

    const allGaugeFaultsPdf = gaugeFaults.concat(manualGaugeFaults);
    const pdfGaugeFaultNos = document.querySelectorAll('.fault-no-input[data-type="gauge"]');
    const pdfGaugeRepeatCbs = document.querySelectorAll('.repeat-fault-cb[data-type="gauge"]');
    if (allGaugeFaultsPdf.length === 0) {
        doc.setFontSize(11);
        doc.setTextColor(100);
        doc.text('No gauge faults detected.', 14, 32);
    } else {
        doc.autoTable({
            startY: 28,
            head: [['#', 'Fault No.', 'Start', 'End', 'Length', 'Worst Gauge', 'Deviation', 'Type', 'Cat.', 'Required Action', 'Repeat']],
            body: allGaugeFaultsPdf.map((f, i) => {
                const c = classifyGaugeFault(f.worstGauge, lineSpeed);
                return [
                    (f.manual ? '* ' : '') + (i + 1),
                    pdfGaugeFaultNos[i] ? pdfGaugeFaultNos[i].value : '',
                    f.startLocation, f.endLocation, f.length,
                    f.worstGauge.toFixed(1), f.deviation,
                    c ? c.type : (f.direction === 'wide' ? 'Wide' : 'Tight'),
                    c ? c.category : '',
                    c ? c.action : '',
                    pdfGaugeRepeatCbs[i] && pdfGaugeRepeatCbs[i].checked ? 'Yes' : 'No'
                ];
            }),
            theme: 'striped',
            headStyles: { fillColor: [26, 26, 46] },
            styles: { fontSize: 7 },
            columnStyles: { 9: { cellWidth: 50 } }
        });
    }

    // Gauge sign-off
    const gSignY = allGaugeFaultsPdf.length > 0 ? doc.lastAutoTable.finalY + 12 : 44;
    doc.setFontSize(12);
    doc.setTextColor(26, 26, 46);
    doc.text('Section Manager Sign-Off', 14, gSignY);
    doc.setFontSize(9);
    doc.setTextColor(80);
    doc.text(`Name: ${document.getElementById('gaugeSignOffName').value}`, 14, gSignY + 8);
    doc.text(`Date: ${document.getElementById('gaugeSignOffDate').value}`, 14, gSignY + 14);
    doc.text(`Signature: ${document.getElementById('gaugeSignOffSig').value}`, 120, gSignY + 8);
    doc.text(`Comments: ${document.getElementById('gaugeSignOffComments').value}`, 120, gSignY + 14);

    // Page 3: Twist Faults
    doc.addPage();
    doc.setFontSize(14);
    doc.setTextColor(26, 26, 46);
    doc.text('Twist Faults - 3m Base (Table 3 Limits) - Line Speed: ' + (lineSpeed || 'N/A') + ' mph', 14, 20);

    const allTwistFaultsPdf = twistFaults.concat(manualTwistFaults);
    const pdfTwistFaultNos = document.querySelectorAll('.fault-no-input[data-type="twist"]');
    const pdfTwistRepeatCbs = document.querySelectorAll('.repeat-fault-cb[data-type="twist"]');
    if (allTwistFaultsPdf.length === 0) {
        doc.setFontSize(11);
        doc.setTextColor(100);
        doc.text('No twist faults detected.', 14, 32);
    } else {
        doc.autoTable({
            startY: 28,
            head: [['#', 'Fault No.', 'Start', 'End', 'Length', 'Max |Twist|', 'Worst', 'Curve R', 'Cat.', 'Required Action', 'Repeat']],
            body: allTwistFaultsPdf.map((f, i) => {
                const isManual = f.manual;
                const radius = isManual ? f.curveRadiusLessThan400 : twistFaultRadiusSettings[i];
                const c = classifyTwistFault(f.maxAbsTwist, lineSpeed, radius);
                return [
                    (f.manual ? '* ' : '') + (i + 1),
                    pdfTwistFaultNos[i] ? pdfTwistFaultNos[i].value : '',
                    f.startLocation, f.endLocation, f.length,
                    f.maxAbsTwist.toFixed(1), f.worstValue.toFixed(1),
                    radius ? '< 400m' : '>= 400m',
                    c ? c.category : '',
                    c ? c.action : '',
                    pdfTwistRepeatCbs[i] && pdfTwistRepeatCbs[i].checked ? 'Yes' : 'No'
                ];
            }),
            theme: 'striped',
            headStyles: { fillColor: [26, 26, 46] },
            styles: { fontSize: 7 },
            columnStyles: { 9: { cellWidth: 50 } }
        });
    }

    // Twist sign-off
    const tSignY = allTwistFaultsPdf.length > 0 ? doc.lastAutoTable.finalY + 12 : 44;
    doc.setFontSize(12);
    doc.setTextColor(26, 26, 46);
    doc.text('Section Manager Sign-Off', 14, tSignY);
    doc.setFontSize(9);
    doc.setTextColor(80);
    doc.text(`Name: ${document.getElementById('twistSignOffName').value}`, 14, tSignY + 8);
    doc.text(`Date: ${document.getElementById('twistSignOffDate').value}`, 14, tSignY + 14);
    doc.text(`Signature: ${document.getElementById('twistSignOffSig').value}`, 120, tSignY + 8);
    doc.text(`Comments: ${document.getElementById('twistSignOffComments').value}`, 120, tSignY + 14);

    const filename = 'TrackInspection_' + (metadata['Route ID'] || 'Report') + '_' +
        (metadata['Track ID'] || '') + '.pdf';
    doc.save(filename);
}
</script>

</body>
</html>
